---

title: Deliver application services through business object views
abstract: Systems and methods for providing application services through business object views. In one aspect, a definition of at least one business object (BO) is included in a metadata of an application platform. The definition includes descriptions of entities of the BO, and an identification of a service provider of the BO. The service provider instantiates the business object in response to an application service request. In a further aspect, a definition of a business object view (BOV) is included in the metadata of the application platform. The definition includes description of entities of the BOV, and an identification of the BO. The BO is a data source of the BOV. In one other aspect, a transformation describes a mapping of BOV entities to data source BO entities. A service corresponding to a core service of a BOV entity is called at the BO service provider based on the mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08234308&OS=08234308&RS=08234308
owner: SAP AG
number: 08234308
owner_city: Walldorf
owner_country: DE
publication_date: 20091222
---
The field of the invention relates generally to data processing and digital processing systems. More specifically the invention is related to providing services to consumers within a computer systems environment.

According to the information technology IT industry terminology a business object BO could be defined as a uniquely identifiable business entity. In the context of a private computing environment the existing business objects represent the entities in a business domain supported by one or more business applications. Business applications deliver application services to consumers based on the business objects. The business applications are traditionally implemented on top of application platforms that provide software basis for the different application services. The application platforms also provide a variety of infrastructure services e.g. user interfaces report generation business object repositories software logistics and lifecycle management persistency abstraction etc. Generally the application platforms are developed and marketed by different software vendors. Proprietary application platforms are implemented in many private computing environments as well.

Often application platforms including the proprietary application platforms are developed to provide business functionality that is applicable for small medium and large sized business environments. Therefore the business objects that are presented within an application platform need to correspond to the most complex business domain target group. The BOs existing in such universal application platforms contain more functionality than small and medium sized companies really need. Part of the unnecessary functionality could be hidden behind adjustable business configuration or behind predefined user interfaces. However the entire functionality of the application platform including the whole complexity of the BOs would be visible in various use cases especially in Flexibility and Extensibility scenarios e.g. Ad hoc reporting UI extensibility etc. The task of limiting a consumer domain to access a narrower scope of the functionality presented by an application platform could require substantial resources and could cause tradeoff in terms of performance and maintenance.

Systems and methods for providing application services through business object views are described. In one aspect a definition of at least one business object BO is included in a metadata of an application platform. The definition includes descriptions of a number of entities of the BO and an identification of a service provider of the BO. The service provider instantiates the business object in response to an application service request. In a further aspect a definition of a business object view BOV is included in the metadata of the application platform. The definition includes description of a number of entities of the BOV and an identification of the BO. The BO is a data source or originator of the BOV. The BOV definition could specify more than one BO as a data source of the BOV. In one other aspect a transformation is stored in the metadata of the application platform to describe mapping of the BOV entities to the entities of the BOs specified as data sources of the BOV. In yet another aspect the definition of the BOV is loaded in the runtime environment of the application platform in response to a consumer call for a core service of a BOV entity. A service corresponding to the core service of the BOV entity is called at the BO service provider based on the mapping.

In an additional aspect BOVs can be nested at design time e.g. the BOV is defined on top of another BOV. In such a case the BOV includes an identification of the underlying BOV instead of the identification of the BO. Nevertheless at runtime nested or hierarchal core service calls are avoided by calling directly the service of the BO corresponding to the consumer core service call. The direct call at runtime is made possible via an optimized mapping calculated at compile time and described in the transformation.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for providing application services through business object views are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Broadly defined a business object BO represents a well defined and outlined business content that encapsulates an independent business concept recognized by the business world. Business objects can be categorized according to their business related nature among other things. Some business objects might describe organizational units or structures for conducting business. Other BOs correspond to business transaction documents representing business transactions. In either case BOs are characterized by their structure elements or entities. Table 1 represents an exemplar non exhaustive list of BO categories of entities 

A service is a resource that is able to perform a set of tasks e.g. service operations upon request by a consumer. Services are delivered by corresponding computer application instances within a computing environment. A core service is a service performing operations of a business object node. The set of all core services of a BO node completely encapsulates and controls the state of all node instances. Typically the BOs of an application platform are modeled and implemented in a strictly normalized way focused on service provisioning for complex business solutions. The normalized structure of the business objects ensures integrity and consistency of the allocated data and services and avoids the redundancy. However the normalized structures are not convenient for consumer access. Therefore a special category of business object views is presented. A business object view BOV is modeled as a specific business object based on a core business object. Additional data and actions can be joined in the BOV from other business objects to achieve structural simplifications and easier consumption.

Consumers form a consumer domain that may include user interfaces partner development tools or infrastructures various third party analytic applications forms etc. Consumers send method calls corresponding to different core services of the BOVs through remote consumer proxy RCP . The RCP maps the protocols used by the consumers for the method calls to the internal core service interfaces. The service calls received at RCP are handled by service adaptation engine . The service adaptation engine identifies the underlying BOs and requests corresponding to the core services of the BOs through service provider adapter based on transformations .

The requested services are executed by the appropriate service providers . Service providers could be different business applications. A service provider may instantiate a service provider class corresponding to a business object as defined in metadata . The instantiated service provider class creates an environment to perform the tasks associated with the requested service e.g. extracts data setup parameters carries data persistency etc. A service provider may also act as a service consumer as data of different business objects could be needed for executing the requested services. Such internal service calls from the service providers are sent to application platform through local consumer proxy LCP .

Both LCP and RCP implement metadata to provide the service providers and consumers respectively with access to the service interfaces of the BOVs . In general BOVs are developed to present a meta model of the required business functionality within computing environment that is more convenient than the meta model presented by the normalized BOs . Database could be used by application platform to store metadata . In one embodiment of the invention service adaptation engine and service provider adapters could create executable load based on the metadata and store it database . Service providers persist data associated with the respective BOs in database .

Once the model of the new BOV is built the correspondence between the entities of the existing BOs or BOVs and the entities of the new BOV is analyzed and described at . An entity of the new BOV could map directly to an entity of an underlying BO or BOV. In such a case the entity of the underlying BO or BOV projects all its properties into the entity of the new BOV. Alternatively a transformation rule could be assigned to the mapping. The transformation rule could be described with a function having at least one parameter presenting an entity of an underlying BO or BOV. The function is calculated at runtime and the result is mapped to the entity of the new BOV. For example an entity of the new BOV could be mapped to a concatenation of an entity of an underlying BO and a substring of an entity of an underlying BOV. The direct or indirect mapping of an entity of the new BOV to an entity of an existing BO or BOV could be defined in the meta model of the new BOV by a transformation including a mapping description and a transformation rule when required.

In one embodiment of the invention the nodes of a BOV can contain transformed elements which will be calculated at runtime. For such elements in the metadata repository a transformation including transformation rule shall be modeled to get a where used index of the source BO elements which will be transformed by the calculation. For example the where used index is needed in an extensibility framework. The calculation itself is provided as a backend service adaptation function. The nodes of a business object view can contain associations actions and queries that are directly or indirectly mapped to associations actions and queries of underlying BOs. It is not possible to provide a service provider class to implement such associations actions and queries.

Certain principles could be imposed regarding the mapping between different kinds of entities. For example such principles may forbid associations from the new BOV to other BOs or BOVs. The navigation from a BOV to other BOs or BOVs must be based on real foreign key relationships. The reason for such limitation is to establish self contained BOVs regarding the cross business object associations. Another rule regarding the association entities could ban generalized associations that are parameterized at runtime with specific filter e.g. the scope of the generalized associations is defined at runtime. Further it may not be allowed to use data objects directly in the BOVs and the data objects have to be mapped through corresponding business objects that host the necessary data.

The mapping principles could impose a requirement that the properties of the BOV entities are restricted by the values of the properties of the corresponding entities of the underlying BOs or BOVs. For example if an element of an underlying BO is editable then the mapped element in a derivative BOV can be editable or read only . Further if an element of the underlying BO is read only then the mapped element in the derivative BOV can only be read only .

The solution model built at the application platform includes complex and comprehensive business object structure. Some of the entities of this structure are for public use and they could be accessed by consumers and integrated in e.g. partner solutions. However many of the entities of the business object structure are for internal use only providing internal services. From consumer s perspective these entities are not regarded as pertinent to the business solution model of the application platform. At a status is assigned to the public entities of the new BOV to indicate that they could be accessed by the consumers. The entities of the underlying BOs or BOVs that correspond to the public entities of the new BOV could be marked with a status that indicates that they could no longer be accessed directly by the consumers.

In one embodiment of the invention an important status associated to the public entities indicates the availability of a stability contract. The stability contract guarantees that an associated BOV entity is available or will be available in a particular software release of the application platform. The stability contract for an entity of the new BOV could be described by a release status code assigned to the entity. For example the release status code could be set to not released released with restrictions released deprecated and revoked . If an entity has release status code set to released it guarantees that the entity is included in the current software release and will be included in at least the next software release of the application platform. The stability contracts guarantees the entities with release status code set to released or deprecated are fully supported by the current software release of the application platform and respectively all associated services are available to the consumers. Additionally a label could be assigned to some or all of the entities of the new BOV. The labels could present descriptions of the corresponding entities that are aligned with the terminology of a specific business solution and thus alleviate consumer s access to the relevant entities.

The new BOV derives directly or indirectly from one or more underlying BOs. The new BOV derives indirectly from a BO when it derives from a BOV which in turn derives directly or indirectly from the BO. For each BOV defined in an application platform the underlying BO needs to be defined. BOVs reuse a number of infrastructure mechanisms that are provided by the underlying BOs. At the new BOV is set to reuse infrastructure mechanisms provided by a main underlying BO. For example the BOV needs to reuse a messaging mechanism of an underlying BO to provide error and information messages. Similarly the authorization and the deployment mechanisms for the new BOV derives from the main underlying BO. Furthermore the BOVs in an application platform may not be security relevant objects. Respectively the access management services and BOV instances checks are delegated to corresponding frontend security objects and to the service providers of the underlying BOs respectively.

The new BOV is generated at . According to one embodiment of the invention the business object views are implemented within existing application platform architecture. For example the definitions of the BOVs could be stored in a general metadata repository where the definitions of the BOs implemented within the application platform are kept. The service providers of the BOs could execute the core services associated with BOVs respectively no service providers for the BOVs are required. Consumer proxies and service adaptation engines could generate interfaces based on the BOVs metadata to provide the consumers with access to the core services associated with the entities of the BOVs. The runtime environment of the BOVs could be presented by an existing service adaptation engine at the application platform. The metadata model of the new BOVs is compiled by a compiler and a corresponding executable load is created and stored e.g. in the metadata repository. The executable load is loaded by the service adaptation engine when a pertinent service call is received from a consumer.

Consumers especially those including partner development tools and customer extensibility tools display a solution business object layer during discovery. The solution business layer is provided by the application platform and includes the available business object view that is the BOVs containing public entities. If such business object views are not available business objects will be used for discovery. All kind of partner and customer consumer domains e.g. user interfaces A2X services reports analytics forms etc. are based on the business object views if available. The comprehensive support for the business object views in the application platform without any service provider and own written coding makes it possible to use a regular extensibility framework EXF for standard extensibility scenarios. A non exhaustive exemplary list of use cases involving consumption of public BOVs could include 

The evaluation of how different consumer domains e.g. user interface analytics etc. use normalized and complex business objects reveals similar simplification patterns that are used for building content in these domains. The simplification may affect the set of business object nodes or the structure elements of the business object nodes. Business object views could be modeled based on the assumptions related with simplification patterns applied by the consumers and further based on the constraints imposed to the business object views compared to the business objects. shows a process for modeling optimized business object views based on different simplification approaches according to one embodiment of the invention.

Process starts at with simplifying the associations between different business objects in a business object view. The normalized layout of the business objects in the application platform could produce a rather complex structure of associations between the nodes of the different BOs. One of the possible ways to simplify this association structure is to create a business object view based on a number of involved business objects. The node entities of the created BOV are mapped to nodes and node transformations from the different BOs wherein the node transformations could be based on the existing associations between the BOs. The modeled BOV is self contained e.g. no associations with other BOs or BOVs should be included. The de normalized structure of the modeled BOV includes additional nodes or node elements that may contain duplicated information but avoid complex associations between the nodes. For example an association between two nodes in two BOs could be resolved in the BOV by adding the referred BO node as an element to a BOV node mapped to the referring BO node.

At an optimization of the structure of the set of nodes of one or more BOs or BOVs that are included in a BOV is performed following a common simplification pattern. For example the reduction of the number of nodes leads to structures which are easier to consume by most consumer tools. A cardinality property defines how often a node is to be instantiated at runtime e.g. how many elements of this node are available at runtime. Typically a node with a 1 C cardinality C 0 or 1 up to one element for the node is instantiated is handled like a deep table structure by the consuming tools even though it does not behave as a deep structure. Therefore having fewer nodes with more elements fields is better from a consumption perspective than more nodes with fewer elements. The nodes with 1 C cardinality could be merged or joined to a parent node. Alternatively in a BO node with a table of entries each entry has an associated code value and for each code value exactly one entry is allowed. In the modeled BO a flat structure is created by introducing an element per code value in a parent BO node.

At an optimization of the node elements of the one or more BOs or BOVs that are included in the BOV is performed. The elements of a node define the node s structure. Consumers may not need to access to certain node elements of a BO or BOV. Respectively the unnecessary node elements will not be included in the modeled BOV. In general the modeled BOV should include only entities that are meaningful to the potential consumers. Another approach to optimize node elements in a BOV model is by reusable special transformations. For example an element of a BOV node could result from an associated transformation function having elements from one or more corresponding nodes as parameters. Further additional elements to alleviate the consumption of the modeled BOV could be presented e.g. for each foreign key to a master data BO at least one human readable text field could be made available.

The modeled BOV could derive from one or more previously defined BOVs thus forming layers of BOVs on different levels of interdependency. At runtime the layering could result in an inefficient service provisioning characterized by nested service calls and redundant load of executable BOV definitions. At the load path for the modeled BOV is optimized.

The root node of sales order BO is also associated with root node of business partner BO . Business partner BO also includes bill to pty node buyer party node used address node default convent phone node and default mobile phone node . The default convent phone node includes number element and default mobile phone node includes number element . Further the root node of sales order BO is associated with root node of product BO . Product BO also includes item product node with product key element product req spec node and description node with language code element and description element .

Sales order BOV includes root node with bill to pty phone number element bill to pty cell phone number element buyer pty phone number element and buyer pty cell phone number element . Sales order BOV also includes item node with product element product key element and product req spec description element .

Multiple nodes with 1 C cardinality from the business objects in an application platform could be joined using appropriate mapping by following an association from a referring node to the referred nodes of 1 C cardinality. Table 2 illustrates an example snippet of service adaptation description language SADL code that merges nodes with cardinality 1 C default convent phone node and default mobile phone node of business partner BO to root node of sales order BOV 

Regarding the optimizations of node elements Table 3 illustrates an example snippet of SADL code representing a mapping function providing reusable special transformation. The function is assigned to item node of sales order BO and concatenates product key element of item product node with description element of description node of product BO in product element in sales order BOV 

Further a node element could be optimized by enriching it with relevant texts in the modeled BOVs. The vast majority of the consumers user interfaces forms analytics etc. need a human readable text for data identification to efficiently access the available business functionality. In many cases the human readable text should be language dependant and only the text in the logon language of a user could be loaded. Table 4 illustrates an example snippet of SADL code for enriching item node of sales order BOV with product req spec description element containing read only texts in the logon language 

The optimization of a load path for a business object view is illustrated with and . is a block diagram of a business model that illustrates levels of business object views according to one embodiment of the invention. Business model includes sales order BO business partner BO and product BO . Sales order BOV derives from sales order BO . Transformation describes the mapping of the entities of the sales order BOV to the corresponding entities of the respective business objects. Sales order UI BOV derives from sales order BOV . Transformation describes the mapping of the entities of the sales order UI BOV to the corresponding entities of sales order BOV .

Sales order BO includes root node item node and schedule node . Root node is associated to item node e.g. each instance of root node includes a reference to at least one instance of item node . Similarly item node is associated with schedule node to define that for each instance of item node an instance of schedule node could be provided. The root node of sales order BO is also associated with root node of business partner BO . Further the item node of sales order BO is associated to root node of product BO . The existing associations between the nodes of a BO or BOV or the associations between nodes across BOs are illustrated with arrows in . Sales order BOV includes root node item node and schedule node . Sales order UI BOV includes root node and item node .

The load contains the mapping of the entities of the sales order UI BOV to the corresponding entities of the sales order BOV . Respectively the requested core service of the sales order UI BOV is provided by a corresponding core service of the sales order BOV . At service adaptation engine reads the instructions of the loaded executable content to call the corresponding core service of sales order BOV . The application platform utilizes consumer proxy to generate the call to the required core service of the sales order BOV at . At the consumer proxy again delegates the call for the core service to service adaptation engine. The service adaptation engine loads the executable content for the sales order BOV at .

The load for the sales order BOV contains the mapping of the entities of the sales order BOV to the entities of the sales order BO . Respectively the requested core service of the sales order BOV is provided by a corresponding service of the sales order BO . At service adaptation engine reads the instructions of the loaded executable content of the sales order BOV to call the corresponding service of sales order BO . At service adaptation engine sends a service call corresponding to the core service of the sales order BOV and respectively corresponding to the sales order UI BOV . The service call is sent to a service provider associated with the sales order BO via a service provider adapter.

Process could be optimized by excluding the actions associated with blocks to . This optimization of the process will be possible if the executable load of the sales order UI BOV contains instructions to send a service call corresponding to the core service directly to the service provider of the sales order BO without loading executable content for sales order BOV .

Generally a business model implemented in an application service could contain many levels of BOVs. The BOVs on one level directly derive from the BOVs on the previous level. The BOVs on the first level derive from the existing BOs. The load path optimization for a business object view that does not derive directly from a business object could be accomplished by modifying the mapping metadata during the compilation of the business object view. The compiler that is running on the application platform has access to the definitions e.g. to the metadata of all BOs and BOVs presented in the application platform. Respectively the compiler could trace the mapping of every entity of a BOV to one or more entities of any underlying BOV or BO. Compiler optimizes the loading path of a BOV by generating runtime mapping between the entities of the BOV to the corresponding entities of the underlying one or more BOs. This optimization is also called de layering of the loading path of a BOV.

At a check is performed to verify whether the category type of the data source object indicates a business object view. If the data source of the selected BOV to be compiled is a BOV at compiler reads the metadata of the allocated data source BOV. The mappings of the entities of the selected BOV to the entities of the allocated data source BOV are updated with the metadata of the allocated BOV at .

The process of updating the mappings of the selected BOV is also called de layering. For example as shown in the complete not optimized SADL mapping for the item node of sales order UI BOV is 

Sales order BOV has category type Business object view respectively the mapping of the item node of sales order UI BOV can be optimized e.g. de layered just by removing the part related to the Sales order BOV 

At a data source object of the data source BOV is allocated e.g. a data source object on a lower level for the selected BOV is allocated. At a check is performed to verify whether the category type of the allocated data source object on a lower level indicates a business object view. If the allocated data source object on a lower level is a BOV process repeats the actions presented by blocks through . If either of the checks at or at shows that the data source object category type does not indicate a business object view process continues at where the compiler generates the executable content e.g. the load for the selected BOV.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable medium as instructions. The term computer readable medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

A semantic layer is an abstraction overlying one or more data sources. It removes the need for a user to master the various subtleties of existing query languages when writing queries. The provided abstraction includes metadata description of the data sources. The metadata can include terms meaningful for a user in place of the logical or physical descriptions used by the data source. For example common business terms in place of table and column names. These terms can be localized and or domain specific. The layer may include logic associated with the underlying data allowing it to automatically formulate queries for execution against the underlying data sources. The logic includes connection to structure for and aspects of the data sources. Some semantic layers can be published so that it can be shared by many clients and users. Some semantic layers implement security at a granularity corresponding to the underlying data sources structure or at the semantic layer. The specific forms of semantic layers includes data model objects that describe the underlying data source and define dimensions attributes and measures with the underlying data. The objects can represent relationships between dimension members provides calculations associated with the underlying data.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

