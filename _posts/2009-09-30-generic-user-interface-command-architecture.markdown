---

title: Generic user interface command architecture
abstract: Certain aspects of a generic user interface command architecture allow an application to host commands for presentation on a computing device. The commands can be written by the same designer or author as the application, or alternatively by other parties (e.g., by a third-party developer). Other aspects of the generic UI command architecture describe an application programming interface (API) that can be used to allow the application to host the commands. Other aspects of the generic UI command architecture describe an activation mechanism by which registered commands can be activated by an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08359606&OS=08359606&RS=08359606
owner: Microsoft Corporation
number: 08359606
owner_city: Redmond
owner_country: US
publication_date: 20090930
---
This patent application is a divisional application of and claims priority to commonly owned U.S. patent application Ser. No. 10 838 462 filed on May 3 2004 issued as U.S. Pat. No. 7 636 922 on Dec. 22 2009 and entitled GENERIC USER INTERFACE COMMAND ARCHITECTURE to inventors Odins Lucas et al. The entire contents of the Application are hereby incorporated herein by reference.

This invention relates to computers and user interfaces and particularly to a generic user interface command architecture.

As computer technology has advanced and evolved so too have the user interfaces UIs that computers present to users. Graphical user interfaces GUIs have become commonplace resulting in user interfaces that are typically easier for users to interact with. Many different presentation models can be used with GUIs that allow command options to be presented to users in different ways such as menus toolbars buttons links and so forth.

One problem faced when designing such GUIs is the different presentation models that can be used with the GUIs. Typically a provider of a command must write a separate description and interface for each different presentation model supported by the GUI that the command is to be included in. This results in additional and duplicative work on the part of the provider of the command. Additional problems can result in situations where new presentation models are developed subsequent to the provider writing the command as the provider writing the command does not know of the new presentation model he or she typically cannot write the command to support the new presentation model.

In accordance with certain aspects a generic architecture is described that allows an application to host commands for presentation on a computing device. The architecture includes a command host and a command broker. The command host provides a workspace where a plurality of user interface commands can be presented. The command broker identifies a plurality of supported modes for a command and further negotiates with the command host to determine which of the plurality of supported modes is to be used for the command.

In accordance with certain aspects an application programming interface API is described that can be used to allow the application to host the commands. The API includes for example a command broker component that exposes a modes enumeration. In response to a requester such as a command host invoking the modes enumeration the command broker component returns a list of a plurality of different presentation models supported by the component for a particular command associated with the component.

In accordance with certain aspects an activation mechanism is discussed that describes a way in which commands can be registered for activation by an application. The activation mechanism creates a command broker by identifying an object definition that includes one or more arguments. For each of the one or more arguments that is a non literal argument one or more additional object definitions based on the argument are recursively identified. The command broker is then created as the objects defined by the identified object definitions.

A generic user interface command architecture is described herein. In accordance with certain aspects a generic architecture is described that allows an application to host commands for presentation on a computing device. The commands can be written by the same designer or author as the application or alternatively by other parties e.g. by a third party developer . Additionally an application programming interface API is described that can be used to allow the application to host the commands. Furthermore an activation mechanism is discussed that describes a way in which commands can be registered for activation by an application.

Computing device represents any of a variety of different devices having a processor or controller that presents a user interface. Examples of such devices include a desktop computer server computer notebook computer handheld or portable computer entertainment device game console personal digital assistant PDA cellular or mobile telephone and so forth. Applications represent any of a variety of applications. Examples of such applications include operating systems recreational programs utility programs educational programs productivity programs financial programs and so forth.

Command architecture is referred to as a UI command architecture because the architecture is designed for use with UI commands which are commands that are presented for user selection via the UI. Command architecture allows commands to be authored or written for presentation to and selection by a user via a user interface. Any type of commands can be supported by command architecture such as commands to access resources e.g. such as a file storage device input device output device etc. commands to present content to a user e.g. play back an audio file or an audio video file print out a hard copy of data etc. commands to allow the user to navigate to particular locations e.g. files network locations control panels etc. and so forth.

Command host is at least a portion of any application such as an application of that provides a shell or workspace where commands can be placed for presentation. A command host can provide a single such shell or workspace and multiple different command hosts can concurrently provide different shells or workspaces. Examples of such workspaces include a window or other portion of a display an audible list and so forth.

Command host supports one or more modes also referred to as one or more presentation models for the presentation of commands. These different modes or presentation models refer to different ways in which commands can be presented to a user via a user interface. Examples of modes or presentation models include menus menu lists context menus task bars buttons links e.g. hyperlinks and so forth. These different modes or presentation models typically include displaying commands visually such as in a GUI although other manners of presentation may also be used e.g. presenting commands audibly .

Each command broker is an intermediary that sits between command host and a final handler for the command referred to as a command provider as discussed in more detail below . Each command broker is associated with a particular command. Command broker enumerates the modes that are supported by the command and negotiates with command host as to which mode will be used for the command. If a particular mode is supported by command broker then command broker can create and give to command host a particular command provider associated with the mode. This negotiation is performed via an interface . In certain embodiments an application programming interface API is exposed by each command broker . This API can be called by command host during the negotiation process. An example of such an API is discussed in more detail below.

UI command architecture is referred to as generic because of this negotiation process and the variety of modes that a single command broker can support for its associated command. The same command broker can be used to allow the command to be presented in a variety of different presentation models and thus can be viewed as generic.

Command host negotiates with command broker each time execution of the command host begins. Different command brokers can be made accessible to command host allowing their associated commands to be presented via the UI by command host . One way in which command brokers can be made accessible to command host is by way of a command broker activation mechanism discussed in more detail below. Command host may also negotiate with command broker at different times such as whenever there is a change in selection e.g. which item s in the UI are selected whenever there is a change in the context of the command such as a change in the type of UI e.g. a change from a visual to an audible UI a change in the format of the UI e.g. a window being resized a change in the content of the UI e.g. a different application being executed from a command host that is an operating system and so forth.

As an example of this negotiation assume that an application may present a user interface having both menu and button modes. In this example command host would negotiate with command broker to determine which of the two modes menu and or button to use. Assume that command broker is associated with the print command which generates a hard copy of selected data using a printer. Further assume that command broker supports the button mode as well as a list mode. Command host would negotiate with command broker and determine that the only mode that both host and broker support is the button mode broker does not support the menu mode and host does not support the list mode . Thus the negotiation would result in selection of the button mode.

It should be noted that in certain embodiments command host may support additional modes than those supported by command broker . Additionally command host may have access to a program or other resource that can convert commands from one mode to another. Following the preceding example command host may have access to a program that can convert the information for a command in button mode to be useable for a command in menu mode. Thus during the negotiation process command host can select the button mode and then convert the information received regarding the print command in button mode into menu mode. Such a process allows for example command broker to be used with modes that are created after generation of command broker and that command broker had no knowledge of.

It should also be noted that command broker can enumerate its modes in different orders. In certain embodiments command broker enumerates its modes in order of preference e.g. the order in which command broker or the author of command broker would prefer that the modes are selected by command host . However in certain implementations command host can choose to ignore the order preferred by command broker . Other orderings could alternatively be used such as a random order alphabetical order and so forth.

Command broker can also enumerate different groups of commands. These groups are an indication to command host that particular commands should be located close to one another. Typically in certain embodiments command host is not required to follow the guidance provided by these indications but oftentimes tries to follow the guidance.

In certain embodiments command broker may also be a container for one or more other command brokers. For example a command broker may support one presentation mode which is a menu item in which the command would be presented as a single menu item in the UI. The command broker may also support a presentation mode which is a menu list in which the command broker is a container for multiple additional command brokers each of which is displayed in a list of menu items in the UI.

Command provider is the final handler for the particular command. Command provider controls the various actions that are followed when a command is invoked e.g. the actions involved in response to user selection of a command such as a print command . Command provider typically contains the instructions that are executed whenever the particular command is invoked. Command provider is an object that is instantiated by command broker upon completion of the mode negotiation with command host . A different command provider is associated with each mode supported by command broker . Thus when the mode negotiation has resulted in a particular mode s command broker instantiates an object for that particular mode s . The instantiated object is also passed to command host allowing command host to interact with command provider .

It should be noted that in certain situations command host may negotiate with command broker for multiple presentation models or modes. In such situations command broker instantiates multiple command providers one for each of the multiple presentation models or modes and passes each such instantiated command provider to command host .

In alternate embodiments command broker may be combined with one or more command providers . In such embodiments a separate command provider need not be instantiated. Rather after command host negotiates the mode with command broker command host can interact with command host as the final handler for the command rather than a command provider .

Command context is a list of context information that is supplied by command host and that can be accessed by command broker . The context information included in command context can vary. The context information refers to for example information describing the user interface information describing command host information describing what is currently being displayed and or how it is being displayed in the user interface information about available resources and so forth. Specific examples of context information include what items if any being presented in the UI are currently selected the size e.g. in pixels of the area in which commands will be located whether a particular item or feature is currently being presented in the UI whether particular resources are available on the computing device what other components the computing device is coupled to e.g. whether a printer is currently coupled to the computing device and so forth. Different command brokers may be interested in different context information and some command brokers may not be interested in any context information. When a particular command broker desires to be aware of particular context information the particular command broker will interact with command context to obtain the desired context information.

It should also be noted that the presentation models supported by command broker may change based on command context . For example command broker may support one particular presentation model in situations where a particular component such as a printer personal audio player speaker etc. is coupled to the computing device but not support that particular presentation model in situations where the particular component is not coupled to the computing device. By way of another example command broker may support different presentation models based on the size of the workspace provided by command host .

The generic UI command architecture facilitates authoring of commands. One way in which this facilitation is accomplished is by using command broker . Rather than requiring the author to register the same command multiple different times for multiple different presentation models all of the handlers for the command can be accessed via the same command broker . Additionally common functionality such as a display name or icon to be displayed for the command or the invocation action to be taken when the user selects the command can be shared for different modes. This sharing can be accomplished for example by each command provider referring to the same object that contains the set of instructions that are executed when the command associated with the command provider is selected by a user. Alternatively some common functionality can be made available to command host by command provider rather than being implemented in or accessed through the associated command provider .

Initially the command host and the command broker negotiate a mode act . In certain embodiments this negotiation is performed by the command broker identifying the modes it supports to the command host and the command host comparing those modes to the modes that the command host supports and then the command host selecting one of the modes that both the command host and the command broker support. Alternatively this negotiation may take other forms in other embodiments. For example the command host may identify the modes it supports to the command broker and the command broker compare those modes to the modes that the command broker supports and then the command broker selecting one of the modes that both the command host and command broker support. By way of another example the command host may go through the list of modes that it supports and for each such mode query the command broker as to whether the command broker supports the mode as soon as the command host identifies one of the modes that it supports that is also supported by the command broker the command host can stop querying the command broker.

Once the mode is negotiated the command broker instantiates or otherwise creates a command provider associated with the negotiated mode act . In certain implementations the command provider is instantiated by the command host invoking a GetProvider method exposed by the command broker. The GetProvider method is discussed in additional detail below.

The command host then places the command in the user interface based on the command provider instantiated or otherwise created in act act . This placing of the command refers to positioning an icon name and or other identifier of the command in the user interface. As discussed above the negotiated mode may not be the mode actually used by the command host for presentation of the command rather the command host may use the information obtained from the command provider for the negotiated mode to present the command using a different mode .

The command host then interacts with the command provider act . This interaction includes for example presenting the command s user interface as well as invoking the command s behavior as appropriate e.g. in the event of a user invoking the command .

A ProviderCategory and ContextObjectDescription are listed in Table I. The ContextObjectDescription serves as the name for an individual piece of context data held by the CommandContext object and provided by the host. The ProviderCategory is used to determine the volatility of the context data described. A volatile context value leaves the command context when any host context value is changed. A nonvolatile value stays in the context.

A ContextObjects class is listed in Table II. In certain embodiments a predefined set of ContextObjectDescriptions are kept in the ContextObjects static class. The CommandContext can also hold an extensible set of ContextObjectDescriptions that are not part of this predefined list.

A CommandContext is listed in Table III. The CommandContext is an indexer that maps ContextObjectDescriptions to object values. The CommandContext also has an event that fires when the context has changed. The CommandContext class includes properties methods and enumerations that are exposed by command context of and which can be invoked by command host and or command broker .

A ModeDescription is listed in Table IV. A ModeDescription is a string naming the mode and a managed type. The managed type refers to a requirement in this example that the broker return the command provider via the CommandBroker.GetProvider method.

A StandardModes class is listed in Table V. In certain embodiments a list of standard modes is available for a command broker to implement. In addition to these standard modes the set of modes is extensible to include additional modes.

A CommandBroker class is listed in Table VI. The CommandBroker class includes properties methods and enumerations that are exposed by command broker and which can be invoked by command host of .

An example of a command provider interface is listed in Table VII. This is the interface for an example command provider of . The example listed is the interface for commands that support the task button mode ITaskButtonProvider. The ITaskButtonProvider includes two strings ShortTitle and LongTitle which can be accessed and used by the command host. The ImageSource is the set of instructions that are executed when the command associated with this task button provider is selected by a user. When the command is selected the set of instructions are invoked by the command host invoking ITaskButtonProvider.Invoke .

IProviderChanges is an interface that the command provider can implement to give change notifications to the command host. ProviderChangeHandler is a managed delegate that declares the type of the ProviderChanged event that is fired from within IProviderChanges. The command host can use the ProviderChanged event to tell when it should re query certain state from the command provider.

For example if the ShortTitle of an ITaskButtonProvider changes e.g. because the selection changed then the command provider can inform the command host that its state has changed via the ProviderChanged event. In this example in response to the user changing the selection by interacting with the UI the command host changes the selected state inside the command context which causes the command context to fire a change notification to the command provider. The command provider decides that as a result of this context changed event it would like to change its ShortTitle so it fires a ProviderChanged event which the command host is listening to. The command host receives the ProviderChanged event via a method it has of the type ProviderChangeHandler. The command host as a result of this event re queries the command provider for its ShortText LongText IsEnabled and so forth obtaining enough information to re present the command given its new state. The command host uses the new information to update the UI associated with the command.

Additionally a helper class can optionally be included that implements the standard logic for writing a command intended to be used in the generic UI command architecture discussed herein. The helper class includes various ones of the interfaces discussed above in a single class to facilitate authoring commands using the generic UI command architecture discussed herein. Command broker authors can then derive from this helper class and override any desired parts of its functionality. Table VIII lists an example helper class ExplorerCommand which can be used for example with the Explorer in different versions of the Windows operating system.

Command broker of can be created in any of a variety of conventional manners. In certain embodiments a particular command broker activation mechanism that employs an activator is used to create command broker as discussed below. This creation is also referred to as instantiation or construction.

Definition source can be any of a variety of different sources. For example definition source may be a registry of a Windows operating system a database a file e.g. in an XML eXtensible Markup Language file or some other format and so forth.

Command broker definition can also take a variety of different forms. In certain embodiments command broker definition describes one or more objects in terms of their constructor arguments. These object descriptions which are also referred to herein as key names describe the objects that are to be instantiated or otherwise created to create command broker . Each object description can have zero or more constructor arguments. A constructor argument can be a literal e.g. a string a number an XML document or a byte array or a non literal e.g. another object description . In situations where an object description has one or more non literal arguments each of those non literal arguments is also instantiated or otherwise created recursively until all of the objects have been instantiated or otherwise created.

Assembly portion indicates an assembly from which this command broker can be instantiated. In certain implementations assembly portion indicates the strong name of the managed assembly dll which contains the code of the command broker to be instantiated. A strong name refers to a name that uniquely identifies an assembly e.g. on disk by name version public key token and culture.

Type portion includes an identifier of the object defined by object definition . Typically this identifier is an alphanumeric string although other characters or symbols can alternatively be used as the identifier. Different object definitions within different assemblies can have the same identifier in their respective type portions . The identifier in type portion in combination with the assembly in assembly portion allows objects to be uniquely identified.

Arguments portion is included to identify arguments for the object defined by object definition . A particular object may not have any arguments in which case arguments portion need not be included or may be included but be empty or include an indication that there are not arguments . Arguments as discussed above can be literals or non literals. For each non literal argument there is another object definition that defines the object that is that non literal argument. For each literal argument there is a definition in literal definitions field that defines that literal e.g. identifies a particular string a particular number a particular XML document or a particular byte array . If the object defined by object definition does not have any arguments then literal definitions portion need not be included or may be included but be empty or include an indication that there are no literals .

Initially a top level object definition is identified act . The identified object definition is then accessed act and any arguments of the identified object definition are identified act . A check is then made as to whether there are any arguments identified in act that are non literals act . If there are no such arguments e.g. there are no arguments or all arguments are literals then process is finished analyzing the identified object definition act . However if there is at least one argument which is a non literal then each of the non literal arguments is identified act . Each of these non literal arguments is another object definition. Process then returns to act to analyze each of the identified non literal arguments. Thus process continues recursively to analyze each object definition in the command broker definition until all object definitions are defined in terms of literals or no arguments . After all object definitions are defined in terms of literals or no arguments the individual objects defined by these object definitions and thus the command broker are instantiated by calling the constructor for each object act .

Each object thus defined can then be instantiated or otherwise created by working back up through the object definitions. For example activator can instantiate or otherwise create the objects defined in terms of only literals or those with no arguments then use those objects to instantiate or otherwise create other objects that are defined in terms of those objects just instantiated or otherwise created and so forth. When the top level object definition has been instantiated the command broker has been instantiated.

As can be seen in the example of Table IX a top level object definition or key name Test is defined with an assembly portion a type portion an arguments portion and a literals portion identified as the title line . Each of these portions is a separate line in the top level object definition example in Table IX. The assembly portion indicates an assembly FooAssembly from which to instantiate this command broker. The type portion indicates the object type FooBroker defined by this object definition. The arguments portion identifies two arguments title and bar for this object definition. Title is a string that is defined in the literal definitions portion which is the title line of the Test object definition as Hello World . The bar argument is another object which is defined in the next object definition.

During instantiation of the objects activator of searches definition source to identify another object definition which is below the top level object definition Test and also is the object definition for the bar object. This object definition is the Test bar key name.

The Test bar key name is also defined with an assembly portion a type portion an arguments portion and a title portion each of which is a line in Table IX . The assembly portion indicates an assembly FooAssembly from which to instantiate this command broker. This is the same command host as was identified in the top level key name Test. The type portion indicates the object type BarObject defined by this object definition. The arguments portion identifies two arguments count and snoo for this object definition. Count is an integer that is defined in the literal definitions portion which is the count line of the Test bar object definition as the hexadecimal value 38 . The snoo argument is another object which is defined in the next object definition.

During instantiation of the objects activator of searches definition source to identify another object definition which is below the Test bar object definition and also is the object definition for the snoo object. This object definition is the Test bar snoo key name.

The Test bar snoo key name is also defined with an assembly portion and a type portion. The object definition for the snoo object has no arguments so no arguments portion or literal definitions portion is included in the object definition. The assembly portion indicates an assembly FooAssembly from which to instantiate this command broker. This is the same command host as was identified in the top level key name Test and the Test bar key name. The type portion indicates the object type SnooObject defined by this object definition.

Table X lists an example API that supports the command broker activation discussed herein. Each object definition or key name discussed above is encapsulated by an IActivationDefinition interface listed in Table X. The assembly field and type field are both properties of the IActivationDefinition interface. Each argument and literal definition when present is an IDefinitionElement.

Computer environment includes a general purpose computing device in the form of a computer . Computer can be for example a computing device of . Computer can also be an encoder device that is the source of a multimedia presentation. The components of computer can include but are not limited to one or more processors or processing units a system memory and a system bus that couples various system components including the processor to the system memory .

The system bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example such architectures can include an Industry Standard Architecture ISA bus a Micro Channel Architecture MCA bus an Enhanced ISA EISA bus a Video Electronics Standards Association VESA local bus and a Peripheral Component Interconnects PCI bus also known as a Mezzanine bus.

Computer typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer and includes both volatile and non volatile media removable and non removable media.

The system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by the processing unit .

Computer may also include other removable non removable volatile non volatile computer storage media. By way of example illustrates a hard disk drive for reading from and writing to a non removable non volatile magnetic media not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . Alternatively the hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by one or more interfaces not shown .

The disk drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computer . Although the example illustrates a hard disk a removable magnetic disk and a removable optical disk it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electrically erasable programmable read only memory EEPROM and the like can also be utilized to implement the exemplary computing system and environment.

Any number of program modules can be stored on the hard disk magnetic disk optical disk ROM and or RAM including by way of example an operating system one or more application programs other program modules and program data . Each of such operating system one or more application programs other program modules and program data or some combination thereof may implement all or part of the resident components that support the distributed file system.

A user can enter commands and information into computer via input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad satellite dish serial port scanner and or the like. These and other input devices are connected to the processing unit via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the monitor other output peripheral devices can include components such as speakers not shown and a printer which can be connected to computer via the input output interfaces .

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computing device . By way of example the remote computing device can be a personal computer portable computer a server a router a network computer a peer device or other common network node and the like. The remote computing device is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .

Logical connections between computer and the remote computer are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When implemented in a LAN networking environment the computer is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the wide network . The modem which can be internal or external to computer can be connected to the system bus via the input output interfaces or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link s between the computers and can be employed.

In a networked environment such as that illustrated with computing environment program modules depicted relative to the computer or portions thereof may be stored in a remote memory storage device. By way of example remote application programs reside on a memory device of remote computer . For purposes of illustration application programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computing device and are executed by the data processor s of the computer.

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embodies computer readable instructions data structures or program modules. Communication media also includes any information delivery media but excludes signal bearing media. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media

Although the description above uses language that is specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the invention.

