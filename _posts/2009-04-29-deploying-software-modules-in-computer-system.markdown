---

title: Deploying software modules in computer system
abstract: Methods and systems are disclosed herein for deploying software modules in a computer system. In one embodiment, a number of containers are registered with a deployer. At least one container provides runtime environment for a corresponding type of software module in the computer system. The software modules are one of standalone software modules and components of software applications. From an archive file a number of files that include deployable software modules are extracted. The software modules corresponding to at least one of the containers are detected based on container specific detecting mechanisms. The detected software modules are validated in order to test their functionality and interoperability. When the software modules are validated, they are distributed for implementation in the corresponding containers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869140&OS=08869140&RS=08869140
owner: SAP SE
number: 08869140
owner_city: Walldorf
owner_country: DE
publication_date: 20090429
---
This application is related to U.S. Provisional Patent Application Ser. No. 61 051 692 entitled Java EE 5 Deployment in Application Server Java filed May 9 2008 from which priority is claimed and which is hereby incorporated by reference.

The field of the invention relates generally to electronic data processing and to software installation and management. More specifically a method and a system for deploying software modules in a computer system are described.

Due to the growing complexity of software solutions software lifecycle management has become a critical task. The number of requirements associated with the software lifecycle management is increasing. This is especially true with respect to the development and maintenance of large enterprise computer systems. The modern enterprise computer systems run software applications that are built from a number of separate sometimes independent software components or modules. Thus the deployment of a software application in an enterprise computer system involves installation and integration of a number of smaller software modules. At the same time the maintenance of enterprise computer systems has to comply with tight operational requirements to ensure minimum downtime high availability and cost efficiency. Accordingly the lifecycle of every software module in the computer system is managed individually to retain the operability of the rest of the software components if possible.

The existing enterprise computer systems are developed based on variety of architecture models. Traditional client server computer systems employ a two tiered architecture model such as model illustrated in . One or more software applications are executed on client of the two tiered architecture model . Application is developed as a monolithic set of program code that includes a graphical user interface GUI component presentation logic business logic etc.

Typically business logic component of a software application represents the core functionality of the application i.e. the rules governing the underlying process or services provided by this application. Whereas a presentation logic component of a software application describes the specific manner in which the results of business logic processing are formatted and presented to the user.

Furthermore application has a network interface that enables client to communicate with one or more servers over network . Network could be dedicated to connecting client with server within local area network LAN or wide area network WAN . Alternatively network could be operable for connecting a group of computer systems within an intranet or Internet environment. Finally network could apply any of the existing network communication protocols including transmission control protocol internet protocol TCP IP .

Client represents one of the tiers of the two tier computer system architecture model. Client provides an environment for executing application . Server represents the other tier. Database is maintained on server to provide storage for application . Database may store various types of business and system data depending on the functionality of application . For example on database application could save extract and process data for customers inventory records transaction logs etc. Furthermore database may hold source code files of the software modules on application . Database may also include data access logic used by the business logic of application to store and retrieve data.

The two tier architecture model for building computer systems can be effective but has certain limitations. These limitations become apparent when employed within large enterprise computer systems. For example even with the aid of automated administration tools the lifecycle management of two tiered applications on a large number of different clients is a difficult task. Moreover the tightly integrated business logic presentation logic and user interface logic make the program code of such applications very complex hard to maintain and prone to errors. For example a change to the user interface would require changes in business logic and presentation logic and vice versa.

In the enterprise world the established business rules change dynamically due to factors such as changes in statutory requirements market developments etc. Consequently there are frequent requirements to change the existing software applications or install new software applications that provide certain enterprise services or that support specific business processes. Therefore a more flexible architecture for building computer systems is appropriate.

To overcome the limitations associated with the two tiered client server architecture model a multi tiered architecture model for building computer systems has been developed as illustrated in . In a computer system with multi tiered architecture the presentation logic and the business logic are separated from each other and from the user interface. User interface in client is connected to presentation layer via network . Presentation layer is responsible for the definition and execution of the presentation logic and could be implemented on separate presentation server . Presentation layer communicates with business layer that could be implemented on business layer server . Database provides storage on database server for data relevant to the application including user interface presentation layer and business layer . Presentation server business layer server and database server could be implemented into one or more dedicated physical servers connected from client via physical network .

The separation between the logic components and the user interface provides more flexible and scalable architecture for building computer systems compared to the two tiered model. For example if business rules change only the business logic implemented in business layer could be changed to a new version without touching the program code on the rest of the levels. In another example presentation layer may provide support for a variety of third party user interfaces e.g. popular browsers such as Internet Explorer or Mozilla Firefox .

The multi tiered architecture model illustrated in may be implemented using a variety of different software technologies at each layer or tier including Microsoft.NET technology by Microsoft Corporation Advanced Business Application Programming ABAP technology by SAP AG etc. One of the most popular software technologies for developing multi tiered software applications is Java Enterprise Edition Java EE technology initially introduced by Sun Microsystems Inc. Java EE technology has been further co developed by many other software vendors and described in a special set of documentation that is referred to as Java EE Specification in this document. Due to its popularity and extensive use Java EE Specification is publicly recognized as a standard. Therefore different software developers could build applications compliant with Java EE Specification and these applications could be executed on computer systems that are compliant with Java EE Specification e.g. those that provide Java EE environment.

As enterprise application development projects grow larger and more diverse deployment and maintenance of applications becomes increasingly important. For example it is useful to have software lifecycle management involving a variety of container services application programming interfaces API transaction management modules notification systems resource pooling and security policy providers. Therefore software vendors develop deployment tools to ensure such means of lifecycle management of the software applications and their components such as software modules.

In this document the term deploy tool refers to administrative software application operable to deploying software application components to one or more destination computer systems such as application server or cluster of application servers running on one or more physical computer servers. There are various requirements for deployment of software applications on particular application servers. These requirements depend on the software technology upon which the application server is built. Respectively deployment tools may have to comply with the requirements of a certain application server software technology specification. For example to deploy software applications on Java EE application server a deployment tool may have to comply with the deployment requirements established in Java EE Specification.

In the example illustrated with various source code files of modules of an application are passed to archive builder . Archive builder creates two separate types of archive files. The first type of archive files are with extension .jar to indicate Java archive JAR files that contain business logic software modules. The second type of archive files are with extension .war to indicate Web archive WAR files that contain World Wide Web Web application software modules. JAR files and WAR files are then combined into an enterprise archive EAR file by assembler . An archive file is a file that contains other files e.g. file entries. The file entries in an archive file could be distributed within a directory structure.

Deployer receives EAR file analyzes its content and sends the various pieces to their appropriate destinations. In the simplified illustration of the content of JAR files is sent to EJB container and the content of WAR files is sent to Web container of application server . Application server is assumed to have base environment that provides a set of services . Containers and themselves can be viewed as subordinate environments of base environment each having additional layer of services according to Java EE Specification. Additionally different vendors could introduce containers other than those described by Java EE Specification to provide runtime environment for various other modules of a software application.

The Java EE compliant software applications are deployed on Java EE compliant application servers with the help of a compatible deploy tool. The compatibility of a deploy tool either vendor specific e.g. proprietary or standardized e.g. publicly recognized could be ensured by adding a plug in component. Such plug in component provides functionality that is required by a deploy tool in order to follow a specific software deployment process. In for instance deployer could be a plug in component to a third party deploy tool .

The vendors of application servers have to provide reliable and efficient deploy framework for installation and integration of software components. An application server developed by an independent vendor could comply with an established application server specification but in addition could include features that are not included in the specification. Accordingly deploy framework of such an application server has to ensure compliance with deployment requirements of the adopted technology specification and with the features that are not part of the specification. Based on the specified deployment requirements and the additional features different application server vendors provide various proprietary deployment solutions.

Methods and systems for deploying software modules in a computer system are described herein. A number of containers are registered with a deployer. At least one of the containers provides runtime environment for a specific type of software module in the computer system. From an archive file a number of files that contain deployable software modules are extracted. The software modules that correspond to one of the containers are detected based on container specific detecting mechanisms. The detected software modules are validated in order to test their functionality and interoperability. When the software modules are validated they are distributed for installation in the corresponding containers.

Described below are methods and systems for deploying software modules in a computer system. Throughout the description for the purpose of explanation many details pertinent to Java EE Specification are provided. However as one skilled in the art will understand the principles of the invention may be applied to other software technologies as well.

Software deployment processes typically aim to meet requirements as specified in recognized standards or specifications e.g. Java EE Specification. The deployment of software components in a computer system ensures efficient implementation and integration of the components within a runtime environment provided by the computer system. The runtime environment of the computer system may be provided by one or more application servers. In one embodiment of the invention a dedicated deploy service Deploy Service of an application server within the computer system conducts the whole process of deployment. Deploy Service preferably complies with the deployment requirements of a recognized specification.

Using Java EE Specification for illustration Deploy Service could be a core service within a Java EE compatible application server. This core service is responsible for the deployment of Java EE applications and for the distribution of their modules to the corresponding containers of the application server. Deploy Service controls actions that are performed on the software applications during their lifecycle including requesting containers for information about deployed software components or initiating a demand to modify deployed software component.

Deploy process may allow using third party deploy tools to deliver software modules for deployment in a computer system. The computer system hosts one or more application servers built upon a standard specification e.g. Java EE Specification to provide running environment for the delivered software modules. Deploy Service receives the software modules and conducts the deploy process within an application server. As an application server service Deploy Service may utilize various mechanisms provided by other services or system components of the application servers e.g. containers interfaces libraries etc. during the deploy process. Further the deploy process may allow deployment of software modules that are developed under different versions of the specification. The detecting and generating mechanisms could handle the discrepancies between versions.

In one embodiment of the invention the deploy framework can be implemented as a part of SAP NetWeaver application server Java AS Java . AS Java is an application server that is compliant with Java EE Specification and includes certain vendor specific features. This deploy framework and the realized deployment process are described in detail in the following paragraphs. Different solutions based either on Java EE Specification or on other application development technologies that embody the invention are also possible and obvious for one of ordinary skill in the art.

At block Deploy Service receives an archive file. For example a user provides an archive file e.g. an EAR file or standalone module WAR file JAR file etc. for deployment. Archive files are user entries for Deploy Service. At block the contents of the received archive file is initially analyzed. As part of this analysis Deploy Service decides how to handle the deployment of the archive. Furthermore Deploy Service parses the available metadata that describes the software modules included in the archives Based on the analysis and the parsed metadata Deploy Service extracts file entries from the archive in a temporary folder in a file system accessible by the application server. The extracted file entries contain the source code of the software modules to be deployed.

Once extracted the source files describing the software modules could be distributed to the registered containers for deployment. At block a correspondence is identified between the registered containers and the software modules in the archive. For each container corresponding software modules are detected. The detection of corresponding software modules could include various methods e.g. based on metadata provided by deployment descriptors or file annotations based on file names or file name extensions based on software module type etc. Each or some of the registered containers may provide module detector mechanism. Such mechanism is used by Detect Service to check the contents of the extracted files in order to establish correspondence between the container providing the module detector and a software module.

Additionally each or some of the registered containers could define a mechanism for generating software modules. At block Deploy Service generates software modules for each container that have implemented such mechanism when required. Whether a generation of a module is required or not is determined by one or more logical conditions established by a module generator mechanism implemented in a container. For example if the received EAR file contains certain type of software modules additional software modules are created. More specifically an EJB software module providing Web service could be included in a JAR file however a servlet should be available for the Web service to be accessible. Since EJB modules do not contain servlets originally a new WAR file is generated with the servlet in it. All this logic can be fulfilled with the mechanism for generating a new module. Furthermore generating mechanism could include logic for removing certain software modules from the deployment process.

After determining the module that have to be deployed in the registered containers at block a validation of every module is performed. Validated modules are distributed to their corresponding containers for installation e.g. technical or actual deployment. The validation of the determined modules includes tasks as checking the correspondence between the metadata and the class files of the software modules. For this purpose the metadata coming from deployment descriptors have to be merged with the metadata coming from annotations according to one embodiment of the invention. The output of this merge activity is a container specific model incorporating all descriptive data of the deployable archives Validity checks are executed over the model and once they have passed the validated model can be given to containers for further usage. An advantage is the fact that model is built and validated once and then simply handed over to containers. Model representations are specific for each container accordingly each container provides a logic for building the model which is invoked by Deploy Service or by a separate service or library dedicated to software module validation.

To continue with describing the deployment process a better understanding of the role and structure of the software modules is useful. The software modules are the simplest atomic units that can be deployed on an application server. Java EE Specification identifies four standard module types Web EJB java and connector modules. The standard modules to be deployed could be described by metadata included in a deployment descriptor according to the specification. There are two additional types of standard modules defined in Java EE Specification i.e. persistent unit and Web service modules. The software modules from the later two types are not described in deployment descriptors. They have to be detected at deploy time based on certain rules. For example based on file names matching rules.

Additionally AS Java supports proprietary containers that deploy other module types. Such proprietary containers are not described in Java EE Specification and therefore are referred to as non Java EE containers. Respectively the deployable modules of types that are not defined in Java EE Specification are referred to as non Java EE modules. There large number of containers that can deploy anything ranging from extensible markup language XML configuration files to music files of different formats.

Software modules typically characterized by two common properties a container type and a file. During deployment a software module is distributed to a corresponding container type. One file can contain more than one software module. The software modules of a single file can be deployed on one or more containers of different container types. Hence it is possible to have one or more software modules with the same file property but with different container types. In general the software modules define many to many relationships between the files within a deployable archive and the containers of one or more application servers in a computer system.

Application server could be realized as a standalone system module working on a single physical server. Alternatively computer system could include a number of application servers working simultaneously on one or more physical servers as illustrated in . Application servers in computer system may have similar configuration and all or part of application servers could operate as a cluster. illustrates the structure of only one of application servers .

Deploy tool could be a third party administrative client tool that is operable for a user to deploy software applications. Deploy tool includes deploy manager to integrate deploy tool with application server to manage the deployment of software modules. Deploy manager could be a plug in provided by the vendor of application server to enable third party administrative tools to integrate with the deploy framework. From a user s perspective deploy manager handles the lifecycle management of software modules on application servers in computer system .

Deploy tool connects to application server via network e.g. intranet Internet etc. When there are more than one application servers as illustrated in the deployment requests of deploy tool are routed to one of application servers by load balancer . Application servers could store shared data on storage . For example such shared data are the code files of the software modules. Thus when a software module is deployed on one of application servers the rest of the clustered application servers could execute the module from the code files stored on storage . Additionally each application server could store private data on storage as well.

The software applications or the software modules to be deployed on application server are delivered in the form of archive . Archive could be an enterprise archive EAR file. EAR files have extension .ear . The deployable software modules are included in one or more file entries in archive . Archive also contains other deployment information that is also included as file entries . According to one embodiment file entry refers to a file that is packed in an archive together with other files. File entries are packed in archive within directory structure . Respectively the packed files are placed in one or more folders within archive .

The software modules delivered with archive as file entries are deployed on application servers by one or more containers as modules . Containers provide runtime environment where the deployed software modules are executed. As there are different types of software modules preferably each container provides specific environment for a specific type of software module. The Java EE Specification defines several types of containers to provide runtime environment for the specified types of software modules. However the architecture of application server could be enhanced by including containers that are not originally defined in Java EE Specification e.g. non Java EE containers. Such non Java EE or non standard containers could deploy non standard software modules e.g. software modules of types that are not defined in Java EE Specification non Java EE .

In order to deploy the software modules in archive to their corresponding containers application server utilizes functionality provided by a deploy framework according to one embodiment of the invention. The deploy framework of application server comprises a Deploy Service . Deploy Service serves to extend and enhance the Java EE compliant architecture of application server . Deploy Service along with container API help to deploy the various deployable J2EE and non J2EE software modules using J2EE and non J2EE containers respectively.

Deploy Service is a core service of application server and manages containers via container interface provided by container API . Container API could be represented on application server as an interface defined as a development component. There is a contract established between containers and Deploy Service defined by container interface . Deploy Service conducts deployment process. Generally Deploy Service receives archive for deployment from deploy manager . Then Deploy Service invokes and controls the particular steps of the deployment process. The deployment logic as specified is carried out before software modules have actually reached containers .

According to one embodiment of the invention container API provides container interface that is implemented by container services associated with containers . Such implementation facilitates Deploy Service to identify containers and to invoke various functionalities of containers . Container API provides a container management for registration of containers with Deploy Service . Accordingly the container services may register their corresponding containers with Deploy Service through container API when containers become available and are ready to deploy software modules. Additionally containers may be unregistered when they stop or become unavailable.

With the registration of container an object is instantiated to provide information about the registered container. In one embodiment of the invention such object is containerInfo . The containerInfo object instantiated for particular container may include information for identifying container . Furthermore containerInfo object instance may have set of properties with set and get methods. Some of the properties include 

During the deployment process Deploy Service analyzes the content of archive to determine the software modules to be deployed and to extract the corresponding file entries. According to one embodiment such analysis is called byte code analysis and in order to perform it Deploy Service invokes byte code analyzer . The determination of the relevant software modules could depend on various factors including Java EE Specification definitions subscriptions of containers for files with specific names or extensions descriptive data etc. Archive could contain metadata that is parsed by byte code analyzer . The metadata could provide information about the software modules in archive . Furthermore metadata could provide important configuration information for the corresponding software modules. The metadata could be extracted from file entries .

After determining software modules to be deployed Deploy Service may extract file entries that represent the determined software modules. The software modules are then delivered for deployment to corresponding containers . According to one embodiment of the invention file names and file extensions of file entries may be used by Deploy Service to identify correspondence between the different software modules and containers . Accordingly Deploy Service may automatically recognize container to which a software component should be distributed based on the data in containerInfo instances. For example if a software module file has an extension .war WAR file and the Java EE Web container has specified this extension in its containerInfo instance Deploy Service may distribute the WAR file to Web container.

Some containers define a more complex mechanism for detecting corresponding software modules for deployment. Such containers implement module detector . Module detector is a mechanism that when invoked by Deploy Service performs predefined dynamic analysis of file entries to identify corresponding software modules. In addition to module detector some containers may further implement module generator . Module generator is a mechanism to generate one or more additional software modules e.g. class files under predefined conditions. Module generator could also be used for removing or ignoring software modules from the deployment process. When available module generator is invoked by Deploy Service . Generating and removing follow predefined logic of module generator . For example the predefined logic is based on characteristics of a detected software module.

The detected software modules are distributed by Deploy Service to corresponding containers for deployment. Before this final step according to one embodiment of the invention Deploy Service invokes validator to validate each of the detected software modules. Deploy Service collects data that is required for the tests of validator . Such data includes parsed metadata e.g. descriptive information and annotations the detected software modules and all outside resources referenced by the software modules or the location of these resources. Validator provides a report showing any encountered error or warning concerning the functionality of the software modules. For each correct software module Validator outputs a validated model that is distributed to corresponding container during deployment of the module.

According to one embodiment of the invention the deploy framework of application server is provided by integration between Deploy Service byte code analyzer validator container interface and registered containers . In addition to container interface container API may provide deploy communicator . Deploy communicator allows bi directional communication between Deploy Service and containers . Thus each container during registration with Deploy Service may obtain an instance of deploy communicator to communicate back with Deploy Service .

Using deploy communicator containers may send to Deploy Service information about their status to request runtime information to initiate operations etc. Such information allows the Deploy Service to be more efficient in managing the lifecycle of modules deployed in containers . For example through deploy communicator containers may request Deploy Service to lock or stop any of modules when required by a system process by a running software application.

The integration between the elements of the deploy framework of application server allows the deployment of the software modules included in archive . Software modules are deployed in containers as a result of a deployment process that is conducted by Deploy Service an element of deploy framework.

At block the received archive file is analyzed. The aim of this analysis is to obtain necessary information for the deployment of the application or of the standalone module. Deploy Service performs the analysis and based on the collected data decides how to handle the deployment of the archive e.g. whether annotations should be sought what data to supply software modules validation how to distribute software modules to containers etc. Deployment process continues at block with parsing deployment descriptors that are included in the received archive file. For example Deploy Service parses files META INF application.xml and META INF application j2ee engine.xml . These files are application deployment descriptors for deploying software modules in Web AS where the first file is defined by Java EE Specification and the second file is Web AS specific e.g. vendor specific .

Deployment descriptors provide configuration information which is often referred to as metadata. The metadata is parsed to objects for further processing during the deployment. The metadata may describe one or more software modules that are included in the received archive file. Additionally each container of the application server that is registered with the Deploy Service may subscribe for files with a specific file name or extension or subscribe for software modules of a specific type.

When a deployment descriptor is not present and when no container has subscribed for particular software modules the deployable software modules may be determined according to the following algorithm 

According to Java EE Specification MANIFEST.MF is a special file that can contain information about the files packaged in a JAR file. By checking the metadata stored in this file the purpose of the instant JAR file could be identified. The file application client.xml is a deployment descriptor file for a Java EE client side software module. The file EJB jar.xml is a deployment descriptor that provides persistence metadata necessary for container managed persistence of EJBs. The path to the metadata files in the JAR or EAR archives compatible with Java EE Specification is META INF . In other words the different deployment descriptor files and the manifest file for an application or for a standalone software module could be found in META INF directory of the corresponding EAR file or JAR file respectively.

Determining modules is preferably a functionality of the deploy framework and more specifically of the Deploy Service. In the described exemplar embodiment Deploy Service holds information for modules in instance of com.sap.engine.services.deploy.ear.Module class. Going in detail there are two generic types of software modules class J2EEModule for the standard software modules types described in Java EE Specification Web EJB Java and Connector and defined in com.sap.engine.services.deploy.ear.J2EEModule.Type enum enumerated type and class Module for the other modules.

For a software module from any of the standard types the class J2EEModule is abstract because one of its successors Java EJB Connector or Web classes is instantiated. The software modules represented with instances of J2EEModule class have constructors with parameters parentTmpDir and aUri . The first parameter provides a temporary directory where all module files of the deployable archive should be extracted. The second parameter provides a directory path from the temporary folder parentTmpDir to the instant module file. The modules represented with instances of J2EEModule class originating from Web standard module type have constructors with additional parameter aContextRoot providing reference to the context root.

The modules that are not from one of the four standard types are represented with instances of com.sap.engine.services.deploy.ear.Module class. The class Module has constructor with parameters parentTmpDir aUri and aModuleType . The parameter aModuleType provides the name of a container that will deploy the software module represented by a specific instance of the Module class. The container has to be registered with the Deploy Service. Table 1 shows example code snippets for defining classes representing deployable software modules 

A container subscribes for software modules with particular file names or particular extensions by providing appropriate information e.g. code in the configuration information of the container in class containerInfo . Table 2 shows example code snippets for containerInfo class providing subscription for software modules with particular file names and extensions 

Another mechanism for determining software modules in a deployable archive is based on rules related to software types according to an embodiment of the invention. For a particular software module the Deploy Service tries to determine all containers where the module will be deployed. When such a software module is delivered packed in an SDA file it might contain additional manifest file in the meta folder of the SDA file META INF . In the particular embodiment of the invention within Web AS environment the additional manifest file is SAP MANIFEST.MF . The file SAP MANIFEST.MF contains many properties including softwaretype and softwaresubtype .

Containers subscribe for software modules with particular softwaretype or softwaresubtype or both in a way that is similar to the subscriptions for particular file names or extensions. Software modules that have a particular value corresponding to softwaretype or softwaresubtype or both in SAP MANIFEST.MF will be deployed in a container with corresponding configuration information in its containerInfo class. Table 3 shows an example for a subscription for software modules having particular softwaretype 

Referring back to at block deployment process continues with extracting all software module entries that are determined either based on the metadata stored in the deployment descriptors and the manifest files or based on the established naming rules based on the subscriptions of the containers for software modules with certain file names and software types. The determined software modules entries or files are extracted in a temporary folder in the computer system where the archive is deployed.

In version 5 of the Java EE Specification a mechanism for adding annotations to the software modules class files is introduced. With the help of the annotations the developers of Java EE applications can provide the same metadata provided by the deployment descriptors. For the software modules where annotations are allowed deployment descriptors are optional. When both annotations and deployment descriptors are provided for a software module the metadata in the deployment descriptors have priority over the annotations.

At block a decision is taken whether to parse the deployable archive files for annotations. The decision depends on the version of the deployable application or standalone module packed in the received archive. The version of the application or the standalone module respectively could be identified from a corresponding deployment descriptor. For applications with Java EE version of the application deployment descriptor e.g. application.xml less than version 5 no annotations processing is performed. If application deployment descriptor does not exist or exists with Java EE version 5 or higher then version checks are performed for each JAR format file with extensions .war or .jar . Only files with no module deployment descriptor or with module deployment descriptor with Java EE version 5 or higher are sought for annotations. If a module contains a deployment descriptor with Java EE version less than version 5 no annotations are sought in it.

Standalone modules with file extension .war or .jar may contain annotations. If such a module does not contain a module deployment descriptor or contains one with Java EE version 5 or higher this module should be processed for annotations. Still if a module contains two module deployment descriptors and one of them is an old one no annotations are sought in it.

When the decision is to parse for annotations the class files in the received archive or the class file for a particular software module deployment server calls an AS Java library at block according to one embodiment of the invention. This library is named Byte Code Analysis BCAnalysis and is integrated with the deploy framework. Searching for annotations is an expensive operation that could consume a high amount of time and machine resources. There are several ways to optimize the parsing of annotations during deploy process. For example BCAnalysis is called once at most for a deployable archives Deploy Service could pass all found annotations to the containers saving the additional calls which would be performed by each interested container invoking the library on its own. Furthermore the Container Interface could provide detailed checks which application and standalone modules need for annotations processing. BCAnalysis could search only for a limited set of annotation types thus saving extra resources for finding annotation types unnecessary for the deployment process.

BCAnalysis library is the component where annotation processing is centralized for all containers and modules. It builds up a tree containing the result for the whole application. Deploy Service creates a class loader for all standard predefined annotations. Then it creates an instance of ReaderFactory object and initializes it with the created class loader. The instance of ReaderFactory object could be supplied with a filter for annotation types to be processed. On deployment Deploy Service instantiates ClassInfoReader object from the factory and provides it one or more software modules files. As an output an instance of ReadResult object is produced which keeps the whole processed information into a tree structure. The ReadResult instance is returned to Deploy Service at block . Objects ReaderFactory ClassInfoReader and ReadResult are classes of AS Java engine.

When the decision at block is not to parse annotations the BCAnalysis is not invoked and respectively deploy server does not receive any additional metadata.

At block the deployment process continues with selecting a container from the containers that are registered with Deploy Service. For the selected container a check is performed at block whether it is a container defined by Java EE Specification or a vendor specific container e.g. whether it is a standard or non standard container. Standard containers deploy standard Java EE software modules including EJB Web Java and Connector modules. All other containers are referred as non standard or non Java EE containers no matter to what extent they follow the definitions of Java EE Specification.

If the selected container is a Java EE container the received archive is checked for existing deployment descriptor DD at block . In one embodiment of the invention the folder META INF of the received archive is searched for file application.xml . According to Java EE Specification standard deployment descriptor application.xml if present specifies all software modules in the application to be deployed. Respectively there is no need to detect the software modules to be deployed in a Java EE container if they are specified in an available deployment descriptor.

If the selected container is not a Java EE container or if there is no deployment descriptor in the received archive deployment process continues at block . For each container there are software modules matching rules defined either by Java EE specification or by a subscription. The matching rules could define correspondence between the selected container and software modules having class files with specific names or extensions or having predefined software types. Based on the matching rules at block a set of software modules from the received archive is determined.

At block a check is performed on whether the selected container has a module detecting mechanism. In this document module detecting mechanism is also called module detector . If the selected container has implemented a module detector at block Deploy Service invokes module detector to perform its detecting logic for each determined software module. The operations of blocks through are executed repeatedly for all registered containers until at block it is confirmed that all registered containers are processed.

Other containers may require more elaborate dynamic checks over archive contents and would examine the archive based on predefined logic implemented in such containers as a mechanism for detecting software modules. For example a non Java EE container may deploy music files. Existing matching rules may define correspondence between the container and files with extension .jar . However the container is not interested in every file with extension .jar in the received archive but only in those that contain an mp3 directory. This additional check could be performed by the logic of a module detector implemented in the container.

In another example to two different Java EE containers correspond to software modules both with extension .jar according to the specified matching rules. The first Java EE container deploys EJB Java EE modules. The second Java EE container deploys java Java EE modules. Therefore a second dynamic check over the contents of the received archive is necessary in order to detect when a software module with a file entry with extension .jar have to be deployed on the first or on the second container. A module detector implemented in either of the two containers may check for a presence of a specific deployment descriptor for the module e.g. check for META INF EJB jar.xml for EJB module and META INF application client.xml for the java module respectively. Furthermore in case a deployment descriptor for a .jar module does not exist the module detector mechanism of one of the containers may check for specific annotations if present to decide about the correspondence between the software module and the container.

According to the example embodiment of the invention in AS Java detailed implementation of a module detector can be found in a container interface class as shown in table 4 

Table 5 illustrates a simple implementation of a module detector for a Java EE container that deploy Web Java EE modules 

The Web Java EE modules reside in JAR compatible archives in file entries with .war extension. Hence the Java EE container that is interested in such software modules should set corresponding matching rule by subscribing for software modules with .war file extension. In its module detector implementation container may incorporate logic for defining a default context root for a Web module. Integrating the module detector of the container could be done by setting it to the ContainerInfo as shown in table 6 

An example of a module detector that utilizes annotations is illustrated with snippets of pseudo code in table 7. The module detector provides an implementation of a AnnotationsSupportingModuleDetector class 

A module detector as the one illustrated with Table 7 could be used when simple checks over the content of the received deployable archive are not sufficient to determine a correspondence between a container and a software module. For example when deploying EJB modules a module detector of a Java EE container would check if META INF EJB jar.xml module deployment descriptor is present in a JAR file of a module. If the deployment descriptor is present then the module is regarded as EJB . However if such deployment descriptor does not exist the software module with file with extension jar could be either EJB or Java module or just a class library which is not an application software module. To determine if there is a correspondence between the software module and the Java EE container the module detect mechanism may check the parsed annotations for specific entries as illustrated in table 8 

For the Java EE container implementing the module detector shown in Table 8 the class ContainerInfo may contain definitions illustrated with the code snippets in the following Table 9 

In addition to module detectors some of the registered containers may implement mechanisms for generating new modules during the deployment process according to one embodiment of the invention. In this document a mechanism for generating new software modules is called module generator . In addition to generating modules a module generator implemented in a container may remove some of the modules delivered with the received archive.

For example according to Java EE Specification Web services container deploy software modules containing Web services. Web services could be provided with EJB software modules and with Web software modules. Therefore the module detector of the Web services container would detect correspondence between the container and modules with files with extensions .war and jar containing Web services. A servlet should be available for the Web services included in the detected WAR and JAR files to be accessible. Each WAR file containing Web software module provides such a servlet originally. However JAR files that contain EJB modules do not contain servlets. Therefore for each EJB software module a new WAR file is generated containing Web module with the necessary servlet in it to provide access to the Web service in the EJB module.

For the selected module Deploy Service utilizes the module generator to check if generation of a new software module is necessary. This check is illustrated with block of . If the deployment of the selected software module requires one or more new software modules the new software modules are generated at block . At block Deploy Service utilizes module generator to check whether the selected module still have to be deployed or needs to be removed from the deployment process. If the selected module should not be deployed it is removed at block . According to one embodiment of the invention the class file specifying the module is removed from the temporary folder where it was previously extracted. The module is not removed from the original archive file.

For example a vendor specific Web services container has deployed a different e.g. old versioned type of files before a certain change in the software versions of Java EE Specification. The old versioned files may be provided with files with extensions .wsar . With the adoption of a newer version of Java EE Specification the vendor specific container have to deploy Web services delivered in files with different format e.g. WAR files and JAR files. However it would be desirable if the container continues to be able to deploy Web services delivered with old versioned files. For this reason according to one embodiment of the invention container has to detect the software modules in such old versioned files generate new software modules in new format files from them and remove the original files. This process is similar to a migration that is implemented in the very beginning of the deployment. Thus the rest of the deployment logic is cleared from additional checks and different treatments for the different file versions.

Table 10 provides technical details of how modules generator mechanism is implemented in a container in AS Java according to one embodiment of the invention. In the provided example the main interface of the module generator is in container interface 

In example code snippets provided in Table 10 the generator mechanism of a container utilizes a function to check whether a file is supported by the container. It can be a file name or an extension check in the simplest case. However more specific checks could be added if the container requires it. The example implementation in Table 10 above shows a case of a container that supports all files with extensions .bot .bot1 .bot2 .

The logic of the implemented generate mechanism in a container determines whether to perform wither generate or remove scenarios or both. Table 11 below illustrates an example where generate scenario is supported for files with extensions .bot and .bot1 . If such files exist in the deployable archive Deploy Service utilized the module generator mechanism of the container to physically create new files and to return modules for them. These new modules are then added to the list of modules designated for the container 

In one embodiment of the invention when a container expects annotations to be present in its corresponding modules the implemented module generator mechanism may use an abstract class to provide annotations sensitive generate method as illustrated with the sample code snippets in Table 12 below. Via this method during generate phase parsed annotations are available to the container and it may decide what modules to generate on this basis 

The implementation of a remove scenario in an exemplar module generator is illustrated below with the code snippets in Table 13. The remove mechanism of module generator does not remove the files of the selected modules physically from the archive but just ignores them for the particular container. The example logic would remove .wsar file of a software module containing Web services 

Having providing detailed examples for the different cases of module generate mechanism implementation Table 14 illustrates an assembled example of a module generator 

Once a container has implemented a module generator mechanism as shown in Table 14 the ContainerInfo class of the container could be set. The code snippets of Table 15 below illustrate an example of such definition of ContainerInfo. Thus the module generation mechanism of the container is available to the deploy process through Deploy Service 

Referring back to the operations of the deployment process illustrated with blocks through are executed repeatedly for all detected software modules that correspond to the selected container until at block it is confirmed that all such modules are processed. Respectively the operations of the deployment process illustrated with blocks through of flowchart are executed repeatedly for all registered containers until at block it is confirmed that all such containers are processed.

The deploy process continues at block with validation of the software modules of the received archives According to one embodiment of the invention after all deployable software modules are determined and the correspondence between the software modules and the containers is detected the software modules have to be validated by a validation framework. The validation framework could be a library developed in accordance with the requirements of Java EE Specification. In the example implementation of the invention in AS Java the validation framework is provided by JLinEE class library. JLinEE is a framework for performing validation tests over software modules. The goal is to check their correctness and report problems if there are any. Tests are specific for the different containers and are usually provided by container developers. JLinEE tests are executed before the deployable modules have been distributed to containers for actual deployment. This way errors and warnings are issued earlier and without redundant data flow and transactions roll backs.

Deploy Service gathers all data required for the validation and passes it to the validation framework at block . The gathered data may include descriptive information about the software modules or about the application itself parsed annotations the software modules of the application the version of Java EE Specification of the application the resources rendered from the application e.g. outside classpath etc. Furthermore each container registered with Deploy Service may provide tests for validation of deployment descriptors parsed annotations and merged model. Through the validation framework some of the registered containers will have to perform tests over descriptors and annotations then merge the metadata coming from both validate it and check it for correspondence with class files from the archive.

The output form software modules validation is a report with all warnings and errors that have been encountered during the tests. A result info contains errors and warnings if there any. In case of no errors a validated model is returned for each deployable software module. The validated models are cached and available to Deploy Service to obtain them according to one embodiment of the invention. If there are errors deployment process could be aborted.

After the deployable software modules delivered with the received archive have been validated their real deployment in the corresponding containers is processed. At block Deploy Service distributes the software modules files together with the validated models and the metadata for the software modules to the corresponding containers.

Systems and methods consistent with the present invention also include computer readable media that include program instruction or code for performing various computer implemented operations based on the methods and processes of the invention. The media and program instructions may be those specially designed and constructed for the purposes of the invention or they may be of the kind well known and available to those having skill in the computer software arts. Examples of program instructions include for example machine code such as produced by a compiler and files containing a high level code that can be executed by the computer using an interpreter. In this document the meaning of the term computer readable media is limited to an article of manufacture for tangibly storing computer readable instructions.

According to one embodiment of the invention computer system further includes display to provide visual information to users input device to provide a user with means for entering data and interfere with computer system one or more additional peripherals to further expand the capabilities of computer system and network communicator to connect computer system to network . The modules of computer system are interconnected via a bus .

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least embodiment of the invention. Thus the appearance of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

