---

title: Method and system for signing JavaScript object notation (JSON) messages
abstract: A machine-implemented method for signing a JSON message begins by constructing a reference element for each data object in the JSON message. The data object is identified by a reference identifier that includes a pointer to a digest method, and a digest generated by applying the digest method to the data object. Then, a signature information element is constructed for reference elements corresponding to data objects in the message. The signature information element includes a pointer to a signature method, as well as one or more reference elements, or a canonical form of the one or more reference elements. Then, a signature element is constructed that includes the signature information element, and a signature value generated by applying the signature method to the signature information element. The signature enables a sending entity to generate a digest on a JSON message and to secure the digests using a signing key.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291230&OS=08291230&RS=08291230
owner: International Business Machines Corporation
number: 08291230
owner_city: Armonk
owner_country: US
publication_date: 20090120
---
This application is related to Ser. No. 12 356 305 filed Jan. 12 2009 titled Method and system for encrypting JavaScript Object Notation JSON Messages .

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction of the patent document as it appears in the Patent Trademark Office file or records but it otherwise reserves all copyright rights.

This disclosure relates generally to adding integrity to JavaScript Object Notation JSON messages to protect these messages over a communication link.

Asynchronous JavaScript and XML collectively referred to as AJAX are well known technologies that allow user interaction with Web pages to be decoupled from the Web browser s communications with a Web server. AJAX is built upon dynamic HTML DHTML technologies including JavaScript a scripting language commonly used in client side Web applications the Document Object Model DOM a standard object model for representing HTML or XML documents and Cascading Style Sheets CSS a style sheet language used to describe the presentation of HTML documents. In AJAX client side JavaScript updates the presentation of a Web page by dynamically modifying a DOM tree and a style sheet. In addition asynchronous communication enabled by additional technologies allows dynamic updates of data without the need to reload the entire Web page. These additional technologies include XMLHttpRequest an application programming interface API that allows client side JavaScript to make HTTP connections to a remote server and to exchange data and JavaScript Serialized Object Notation JSON a lightweight text based language independent data interchange format.

JSON is based on a subset of the JavaScript Programming Language Standard ECMA 262 3Edition dated Dec. 1999. It is also described in Request for Comment RFC 4627. JSON syntax is a text format defined with a collection of name value pairs and an ordered list of values. JSON is very useful for sending structured data over the wire e.g. the Internet that is lightweight and easy to parse. It is language independent but uses conventions that are familiar to C family programming conventions. Further information about JSON can be found as json.org.

Currently JSON messages are secured over the wire using mere transport security such as SSL which only provides point to point message security. The data in the message however can still be compromised through malicious altering by an attacker or accidental altering through transmission errors.

JSON message integrity is provided using a digital signature scheme. The digital signature scheme implements a JSON signature syntax together with a set of processing rules for creating and representing digital signatures.

The JSON signature syntax preferably comprises a set of named elements including a reference element a signature information element and a signature element. In one embodiment a machine implemented method for signing a JavaScript Object Notation JSON message begins by constructing a reference element for each data object in the JSON message to be signed. The data object is identified by a reference identifier. The reference element includes the reference identifier a pointer such as a URI to a digest method and a digest generated by applying the digest method to the data object or a given function of the data object. Then a signature information element is constructed for one or more of the reference elements corresponding to the one or more data objects in the message that are being signed. The signature information element includes a pointer to a signature method as well as one or more reference elements or a canonical form of the one or more reference elements. Then a signature element is constructed. The signature element includes the signature information element a key information element that includes a key value and a signature value generated by applying the signature method identified in the signature information element to the signature information element. The key value is useful to verify the signature value. The signature element is the JSON message signature and it provides message integrity through the digest method and authentication through the signature method .

According to another aspect a machine implemented method is executed at a first processing device where the first processing device is adapted to exchange data with a second processing device over a communications network using structured data messages. A structured data message comprises a collection of name value pairs and an ordered list of values. A representative type of data message having this syntax is a JSON request message being transmitted from a Web browser on the first processing device to a Web server on the second processing device. According to the method a digest is generated on all or parts of the request message and the digests are secured using a signing key. In particular for each data object in the message to be signed a reference element is constructed where the reference element includes a reference identifier a pointer to a digest method and a digest generated by applying the digest method to the data object or a given function of the data object. A signature element is constructed from the one or more reference elements. In particular the signature element includes a signature information element associated with the one or more reference elements together with a signature value generated by applying a signature method to the signature information element. The signature information element includes a pointer to the signature method and a canonical form of one or more reference elements. The message and the signature element are output to the second processing device from the first processing device.

In one embodiment the signature element is detached from the message. In particular the signature is generated over data in the message that is external to the signature element. In another embodiment the signature element is enveloped within the message. In this case the signature is generated over data in the message that includes the signature element.

The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.

In a typical scenario illustrated in JSON messages are sent from an initial sender to an ultimate receiver along a JSON message path comprising zero or more intermediaries . The devices and are computing entities such as data processing systems each comprising hardware and software which entities communicate with one another over a network such as the publicly routed Internet in this example an intranet an extranet a private network a wireless link or any other communications medium or link. As described below a data processing system typically comprises one or more processors an operating system one or more applications and one or more utilities. A given data processing system may be a sender or sending entity in which case the system is deemed to be on a sender side of the transmission or a receiver or receiving entity in which case the system is deemed to be on a receiver side. JSON messages such as message may flow in either direction. Typically the sender is a Web browser and the receiver is a Web server or vice versa. In AJAX client side JavaScript updates the presentation of a Web page displayed in the browser by using the XMLHttpRequest API or the like to communicate to server asynchronously with the resulting request response typically involving the exchange of one or more JSON or other structured data messages. In the prior art the JSON messages are delivered over the wire in the clear although point to point security typically is used between sender and receiver using transport layer security mechanisms such as HTTP over TLS Transport Layer Security . In a typical scenario the sending entity is a client machine executing an AJAX enabled Web browser and the receiving entity is a server machine executing an AJAX enabled Web server. By AJAX enabled a particular device has the capability of creating and processing messages using AJAX technologies. Of course these are merely representative data processing systems.

By way of additional background known JSON syntax is built on two structures a collection of name value pairs and an ordered list of values. The collection of name value pairs goes by different nomenclature depending on the language involved and this structure typically is realized as an object a record a struct a hash table a keyed list or an associative array. For discussion purposes the object nomenclature will be used. The ordered list of values also goes by different nomenclature depending on the language involved and this structure typically is realized as an array a vector a list or a sequence. For discussion purposes the array nomenclature will be used.

An object is an unordered set of name value pairs. An object begins with left brace and ends with right brace . Each name is followed by colon and the name value pairs are separated by comma 

RequestSecurityTokenCollection.RequestSecurityToken 0 which represents the first RequestSecurityToken in the array. Each element in the array in denoted by the brackets and comma separated as described above.

RequestSecurityTokenCollection.RequestSecurityToken 0 . Token 0 which represents the first Token in the first RequestSecurityToken.

RequestSecurityTokenCollection.RequestSecurityToken 0 .RequestType which represents a pointer to RequestType.

As will be seen all elements of a message can be identified by this notation. Duplicate keys at the same level are not allowed because the message comprises a collection of name value pairs so the ReferenceId notation is guaranteed to be unique.

According to this disclosure one or more data objects in a JSON message are signed as is now described in more detail.

The following Table 1 describes a JSON Signature syntax according this disclosure. The JSON signature comprises a set of properties that are described as follows 

The nomenclature set forth above should not be taken as limiting. Thus for example the reference element the signature information element and signature element may be generalized into first second and third elements without loss of generality.

The following description summarizes one technique according to this disclosure for signing and validating a JSON message. In one embodiment the signing process comprises two 2 distinct phases Reference Generation and Signature Generation. Reference Generation is carried out for each data object being signed in the JSON message. Each such data object to be signed is identified by its ReferenceId. That message may include one or more such data objects and it is not required that all of the data objects in a message be signed. The Reference Generation phase is iterated for each data object being signed as illustrated in the process flow diagram of . The routine begins at step by applying the one or more Transforms as determined by the URIs to the data object pointed to by the ReferenceId. One such Transform is a canonicalization method that as described in more detail below takes a data object and generates an ordered data object sometimes referred to herein as a canonical form of the data object . An ordered data object allows control of the serialization order of attributes when serializing out to a string. At step a Digest value is calculated over the data object that results from applying the one or more Transforms. This value is calculated by applying the DigestAlgorithm sometimes referred to herein as a digest method . At step a Reference element is constructed. The Reference element as noted above includes the identification of the data object namely the ReferenceId a pointer to the DigestAlgorithm and the Digest. It may also include any optional Transform elements. This completes the Reference Generation phase for the particular data object. As mentioned this process is repeated for each data object to be signed in the message.

The following illustrates an example of a request message that is digitally signed using a JSON signature scheme such as described above with respect to . In this example the signature is outside the message. In particular this is a detached signature over the data in the message that is external to the Signature element.

The following illustrates another example of a request message that is digitally signed using the JSON signature scheme. It uses a signature contained within the message. In this latter approach the signature is over the data in the message that includes the signature element. This approach is sometimes referred to as an enveloped signature. When this approach is used the CanonicalizationMethod in the transform excludes the signature from the message identified in the ReferenceId before canonicalization occurs.

The Signature preferably is validated before being sent on the wire. Preferably validation includes two aspects Reference Validation which verifies the Digest contained in each Reference in SignedInfo and cryptographic signature validation of the SignatureValue calculated over SignedInfo. These are conventional operations.

Although not meant to be limiting the signature methods may be any known algorithms such as a DSA with SHA 1 signature algorithm which uses the SHA 1 digest algorithm and DSA to create and verify DSA digital signatures as defined in FIPS Publication 186 or b the signature algorithm with SHA 1 and the RSA encryption algorithm as defined in the OSI Interoperability Workshop using the padding conventions described in PKCS 1. A representative message digest algorithm is the Secure Hash Algorithm as defined in Secure Hash Standard NIST FIPS Publication 180 1. An MD5 message digest algorithm may be used as well. These algorithms are merely representative however as any known or later developed digest and or signature algorithms may be used.

A preferred canonicalization method is now described with respect to the process flow diagram of . The method begins at step by creating an Ordered JSON Object. At step all the keys from the JSON Object get passed in to the Ordered JSON Object . At step the method sorts the keys which are strings. The method then iterates as follows for each key. In particular at step the method gets the value from the JSON Object passed in by looking it up from the key. A test is then performed at step to determine if the value is a JSON Object. This is step . If so the method puts the key and canonicalized value into the Ordered JSON Object. To canonicalize the value the method calls step passing in the value this is recursion . If the outcome of the test at step is negative a test is performed at step to determine if the value is a JSON Array. If so the method continues at step and creates a JSON Array to store the contents of the value. The method then continues at step to get each object in the value array. It then performs the following sub loop. In particular a test is performed at step to determine if the object is a JSON Object. If the outcome of the test at step is yes the method continues at step to add the canonicalized object to the JSON Array. To canonicalize the object the method calls step passing in the object this is recursion . If however the outcome of the test at step is negative because the object is not a JSON Object and if the object is a string the string is added to the JSON Array at step . After each object in the value array is processed the method continues at step to canonicalize the JSON array e.g. by sorting the contents of the array. For items that are JSON objects during the sort the method serializes them to a string before comparing. At step the method puts the key and canonicalized JSON array in the Ordered JSON Object.

If the outcome of the test at step is negative because the value is not a JSON Object and is not a JSON Array and if the value is a string the method puts the key and value into the Ordered JSON Object. This is step . This completes the processing for each key in the loop defined by step . The method then completes at step . In this step the Ordered JSON Object is now serialized to a string and it is against this string that the digest or signature as the case may be is generated.

In particular when the canonicalization method of is used as a Transform the DigestAlgorithm is applied to the string output in step to generate the Digest. When the canonicalization method of is used as the CanonicalizationMethod the string output in step becomes part of the SignedInfo element which when processed by SignatureAlgorithm generates the SignatureValue. As noted above for the enveloped signature approach the signature element is excluded before canonicalization.

As can be seen a canonicalization algorithm such as described above orders the JSON message Reference elements. This operation generates a canonical form of these elements for use for example as part of the SignedInfo element . The canonical form of the data object may be generated using this approach as well. In particular the canonicalization method sorts the contents of the JSON message recursively and creates an Ordered JSON Object on which to generate the appropriate digest. An Ordered JSON Object allows control of the serialization order of attributes. The order in which items are put into the instance controls the order in which they are serialized out. For canonicalization to work no spaces are allowed in the JSON syntax for the message. As can be seen from the JSON syntax the canonicalization method recursively calls itself sorting the contents of the message which includes the keys and values. A value can obtain another object and an array and this is where the recursion is performed. When serializing out to a string i.e. to turn into bytes for digesting the Ordered JSON Object allows control of the serialization order of attributes.

This canonicalization operation generates a canonical form of the Reference elements for use for example as part of the SignedInfo element . The canonical form of the data object may be generated using this approach as well.

The techniques described herein are advantageous. The disclosed subject matter solves the problem of JSON message integrity. Using the signature syntax as described a sending entity can provide message integrity and authentication through message digests and signatures. The JSON signature allows the sender to generate a digest on all or parts of a JSON request message and then to secure the digests using a signing key. The JSON signature scheme provides a convenient way of identifying the data object in the message and canonicalizing the data for generating the digest. The signature technique is lightweight and fast to parse resulting in increased performance and smaller disk and memory footprint. By implementing JSON message integrity in this manner an additional layer of security over and above any transport layer security is applied to the message. Thus the data in the message is further secured against malicious altering by an attacker who can compromise the transport security or against accidental altering through transmission errors. Using this approach the sending entity need not even use transport security.

The disclosed subject matter can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In one embodiment the JSON signature syntax and associated routines including the canonicalization method are implemented in software which includes but is not limited to firmware resident software microcode and the like. Furthermore as noted above the disclosed subject matter can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD. The transform and related functions may also be implemented as a managed or hosted service.

In one embodiment the program instructions are stored in a computer readable storage medium in a data processing system and these instructions are downloaded over a network from a remote data processing system. In an alternative embodiment the instructions are stored in a computer readable storage medium in a server data processing system and the instructions are downloaded over a network to a remote e.g. a client data processing system for use in a computer readable storage medium with the remote system.

While the above describes a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

Finally while given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

The subject matter herein is not limited to signing JSON messages. The techniques may be applied to any text based data interchange message format that is used to create a portable representation of structured data. Thus the techniques described herein apply to signing structured data messages where a structured data message comprises a collection of name value pairs and an ordered list of values. Thus the techniques described herein may be generalized for use with respect to any structured data interchange format. Examples of such alternative formats include those where the collection of name value pairs is a record a struct a hash table a keyed list or an associative array or where the ordered list of values is realized as a vector a list or a sequence.

As used herein a given function of a data object may be the data object itself the ordered data object that results from applying a canonicalization method such as described in to the data object or the data object resulting from applying other such transforms. Likewise a canonical form of an object such as a set of reference elements may be the reference elements or the result of applying the canonicalization method such as described in to those elements.

The following is a representative Java implementation of the canonicalization method shown in 2009 IBM Corporation 

