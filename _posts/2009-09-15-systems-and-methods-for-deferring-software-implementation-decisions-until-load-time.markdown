---

title: Systems and methods for deferring software implementation decisions until load time
abstract: A software development method defers certain implementation details until load time. A programmer first annotates, in source code, a selected set of software components using metadata (such as Java-style annotations) that define one or more criteriaâ€”e.g., criteria relating to the state of the target hardware platform, the capabilities of the platform, or arbitrary user input. The annotated source code files are then compiled to create one or more intermediate code files (e.g., Java bytecode files). During load time of the resulting intermediate code files, one or more of the selected set of software components are loaded from the intermediate code files based on the criteria.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843920&OS=08843920&RS=08843920
owner: Advanced Micro Devices, Inc.
number: 08843920
owner_city: Sunnyvale
owner_country: US
publication_date: 20090915
---
Embodiments of subject matter described herein generally relate to software optimization techniques and more particularly relate to systems and methods for deferring certain software implementation decisions until program load time.

Programming languages are often roughly categorized as compiled languages i.e. languages that are converted from source code directly to native machine code such as C C Fortran and Pascal and interpreted languages i.e. languages whose source code is interpreted line by line such as Perl Ruby and Smalltalk . In reality however this taxonomy is an oversimplification since many traditionally interpreted languages may be compiled and many traditionally compiled languages may also be run by special interpreters.

Furthermore many modern languages JAVA Python Lua C and the like are first compiled to an intermediate representation e.g. bytecode in JAVA which is then interpreted by a virtual machine e.g. The JAVA Virtual Machine JVM tailored to a specific operating systems and or hardware. This is advantageous in that generally the use of such virtual machines facilitates the write once run anywhere WORA model of software development. Namely the bytecode and source code are portable and may be used on a variety of hardware and software platforms including various personal computers smart phones personal data assistants netbooks and the like generically referred to as computers or computing devices. While traditional compiled languages are generally considered to be faster than interpreted languages to improve performance JAVA and other similar environments often perform just in time JIT compilation or dynamic translation by converting classes and other code at runtime prior to executing it natively on the computer.

Even such cross platform programming languages are limited however in that nearly all implementation choices are fixed at compile time. That is at load time when the software code is loaded prior to or more or less simultaneous with running the program the developer cannot normally choose which variables parameters methods and or classes are to be included in the program.

Furthermore while modern virtual machines such as the JVM are proficient in applying classical compiler optimization techniques to software code and JIT compilers have similarly improved the performance of software to a large extent it would nevertheless be desirable to fine tune such choices based on user interaction and or other information about the platform or environment that is known to the system at load time.

A method in accordance with one embodiment generally includes annotating in source code a selected set of software components using metadata defining one or more criteria compiling the annotated source code files to create one or more intermediate code files then loading one or more of the selected set of software components from the intermediate code files based on the criteria during load time.

A computer program product in accordance with one embodiment includes a computer usable medium having computer readable program code embodied therein the computer readable program code adapted to be executed to implement a class loading method including the steps of receiving a class request retrieving a class file associated with the class request examining the class file for metadata defining criteria associated with one or more software components provided within the class file evaluating the criteria and loading a selected set of the software components based on the criteria.

A computing device in accordance with another embodiment of the present invention includes a processor a mass storage component a virtual machine stored on the mass storage component and intermediate code stored on the mass storage component. The processor is configured to execute the virtual machine such that it generates a class request and the computer instructions are configured to receive the class request retrieve a class file associated with the class request examine the class file for metadata defining criteria associated with one or more software components provided within the class file evaluate the criteria and load a selected set of the software components based on the criteria to form an implemented class.

This summary is provided to introduce a selection of concepts in a simplified form that are further described in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In accordance with various embodiments of the present invention metadata is inserted within software source code during design time and this metadata is then used later at load time to specify which software components will be implemented when the program runs based on one or more criteria. In this way the same software code may be loaded in an optimized manner on a variety of platforms or computing devices ranging for example from general purpose computers to cellular phones depending upon the resources available on the target platform and other such factors. In the context of a JAVA development environment for example JAVA s annotation metadata feature is used in conjunction with custom class loaders to defer the selection of particular JAVA classes fields methods and other components until such time as the bytecode is actually loaded.

As a preliminary matter the following detailed description is merely illustrative in nature and is not intended to limit the embodiments of the subject matter or the application and uses of such embodiments. As used herein the word exemplary means serving as an example instance or illustration. Any implementation described herein as exemplary is not necessarily to be construed as preferred or advantageous over other implementations. Furthermore there is no intention to be bound by any expressed or implied theory presented in the preceding technical field background brief summary or the following detailed description.

For the sake of brevity conventional techniques related to general purpose computers software development programming languages virtual machines object oriented design and the JAVA programming language may not be described in detail herein. Moreover the various tasks and process steps described herein may be incorporated into a more comprehensive procedure or process having additional steps or functionality not described in detail herein. In particular various steps related to the creation compilation interpretation and execution of software code are well known and so in the interest of brevity need not be described in detail herein.

Referring now to a typical software development cycle applicable to JAVA and related languages generally includes the compilation of source code or source code files into an intermediate representation or intermediate code via a compiler followed by the execution or running of the intermediate code using a virtual machine VM thus producing the program s runtime behavior. In JAVA for example source code will typically include a large number of text files .java files which are then compiled to a set of intermediate bytecode files .class files . The VM that is a JAVA Virtual Machine JVM then interprets the resulting intermediate code loading the required classes from files as they are needed.

The term load time as used herein means any time interval or collection of time intervals where classes are loaded for implementation. As much of the class loading often occurs during runtime it will be appreciated that the phrases runtime and load time are not mutually exclusive load time will generally overlap with and take place during runtime since many classes are loaded only when they are needed by the running program.

JAVA and other similar environments often perform just in time JIT compilation or dynamic translation by converting frequently executed intermediate code bytecode to native code at runtime. As mentioned above traditionally the bytecode is determined at source code compilation time and cannot be modified thereafter.

Since each source code file simply consists of lines of text these files may be produced in a number of ways. For short programming tasks for example a conventional text editor EMACS Notepad etc. may be employed. In most modern software development contexts however an integrated development environment IDE is used. An IDE is itself a software package that simplifies the creation and organization of code and is particularly useful in managing large projects requiring re use of an existing code base. Popular JAVA IDEs include for example Eclipse Netbeans and JCreator. A typical IDE will include one or more application programming interfaces APIs a software development kit SDK and a variety of developer tools. One such SDK is the JAVA 2 Platform Standard Edition 5.0 Development Kit JDK 5.0 whose annotation feature will be described in further detail below.

As mentioned above classes are loaded by the VM as they are needed. More particularly referring to during runtime VM requests certain software classes from a hierarchical system of class loaders as illustrated. In this example requests are handled by a bootstrap loader an extension class loader and an application custom class loader . Each loader except the bootstrap loader has a parent to which it delegates the loading of classes etc. in the event that it does not know the location of the particular class requested.

In accordance with embodiments of the present invention an application class loader or the like is able to read and parse metadata that has been inserted within the source code for the purpose of annotating certain classes variables methods and other such software components. The metadata defines criteria that are evaluated to determine whether each annotated software component should be loaded during load time.

More particularly referring to the exemplary method depicted in the flow chart of the process starts with the generation of source code step and the insertion of metadata within that source code step . Typically these steps would be performed more or less contemporaneously by a programmer using an IDE or other code authoring software. In other embodiments these steps may be automated via one or more code generation systems.

Next the source code is compiled to an intermediate representation step . In JAVA for example this intermediate representation will correspond to JAVA bytecode. In other languages the term bytecode may not be used however embodiments of the present invention may be used in connection with any software development environment now known or later developed that compiles to an intermediate representation including without limitation JAVA Lua .Net C Visual Basic .NET and Python.

Next during load time of the intermediate code which may occur for example when classes are needed during runtime the metadata is read step . In the illustrated embodiments a custom class loader or agent understands this metadata and can act accordingly. In other embodiments however the virtual machine and its class loaders may not understand the particular metadata used. Even though a given class loader agent might not understand the metadata it would still be able to load the classes without any errors because the metadata annotations do not affect the classes syntactically. In general it is the programmer s responsibility to ensure that if a class loader ignores metadata then the class still functions as expected.

As shown in step then if the metadata is understood Y branch from the classes and software components are loaded based on the metadata criteria step . Generally the code loaded during step will be a subset of the intermediate code generated in step . If not N branch from default classes are loaded i.e. all of the intermediate code generated in step will be loaded without any modifications. This will also mean that the loaded classes intermediate code could contain redundant code which will never be part of the program s control flow. The virtual machine will then execute the implemented class in the normal course.

The process illustrated above is depicted in conceptual block diagram form in . As shown class loader receives a request for a class at some point in the software execution process generally during load time. Class loader then reads the appropriate class files which include various software components classes variables methods etc. that have been annotated in some way by metadata . Conceptually for example metadata annotates software component metadata annotates software component and so on.

Class loader evaluates any criteria defined by metadata and decides whether to send the respective software component back to the virtual machine for execution. The criteria may relate to user input e.g. a command line parameter input provided during execution platform attributes of the target hardware and or software platform and any other platform state information that might prove useful in determining which software components should be loaded.

Platform attributes generally include characteristics of the target computing device itself that is the hardware upon which the software is ultimately implemented. Examples include memory capacity processor type single core or dual core processor speed user interface capabilities e.g. touch screen multi touch etc. display type and security requirements.

Platform state criteria might relate to a geographical position of the computing device the orientation of the device the temperature or other environmental condition of the device or the acceleration of the device.

After evaluating the received class files based on the criteria the resulting implemented class is then sent to the virtual machine. In an alternate embodiment however as shown in an agent communicates with class loader and is employed to read class files evaluate the criteria and transmit them to class loader before being sent to the virtual machine. Stated another way agent e.g. a JAVA agent effectively acts as a middle man to take care of reading and evaluating the metadata before class loader even sees it.

The various software and hardware components that compose modern microprocessor based computing devices such as general purpose computers smartphones and PDAs are generally well known in the art. However it is illustrative to review these components in the context of various embodiments of the present invention.

Referring to a microprocessor based device or simply device generally includes a display e.g. an LCD liquid ink or touch screen display one or more mass storage components e.g. solid state drives or disk drives one or more CPUs e.g. microprocessors cores microcontrollers one or more memory components RAM ROM etc. one or more network interfaces e.g. wireless 802.11 or wired Ethernet one or more pointing devices computer mice trackballs etc. and any number of other input output devices such as a keyboard . Mass storage will generally be used to store an operating system e.g. Windows MacOS Linux one or more files and one or more applications . Persons skilled in the art will recognize that device will typically include a large number of additional electronic components including buses interconnects printed circuit boards etc. which for the purposes of clarity have not been included in .

In the event a device is used for software development that is the creation of source code as depicted in files and applications will generally include the suite of software components related to the SDK and IDE being used as well as the source code files being developed.

When device is being used to execute the bytecode or other intermediate code a VM and other components of the runtime environment will exist within mass storage . That is CPU is configured to execute the virtual machine such that it generates a class request and the class loader and or agent when executed by virtual machine are configured to receive the class request retrieve a class file associated with the class request examine the class file for metadata defining criteria associated with one or more software components provided within the class file evaluate the criteria and load a selected set of the software components based on the criteria thereby forming an implemented class.

In a particular embodiment as mentioned briefly above the metadata corresponds to JAVA annotations. Annotations in the JAVA environment are a general purpose type of metadata that permits a coder to define and use custom annotation types. It consists of syntax for declaring annotation types a syntax for annotating declarations APIs for reading annotations a class file representation for annotations and an annotation processing tool. As metadata annotations do not directly affect program semantics and are not themselves part of the implemented program rather they affect the way programs are treated by tools and libraries which can in turn affect the semantics of the running program. Annotations can be read from source files class files or reflectively at run time. Note that while some software environments such as Python allow classes to be defined at runtime the criteria for doing so is embodied in the actual program code itself e.g. via if . . . then and case flow controls rather than metadata. As a result such schemes are undesirable in that they increase the size of the software while consuming extra processor cycles.

JAVA annotation types may be declared and are similar to conventional interface declarations. That is an at sign precedes an interface keyword. Each method declaration defines an element of the annotation type and return types are restricted to primitives String Class enums annotations and arrays of these types. Once an annotation type is defined it can then be used to annotate software components.

A JAVA annotation is a special type of modifier and can generally be used anywhere that other modifiers such as public static or final can be used. By convention annotations precede other modifiers. Annotations consist of an at sign followed by an annotation type and a parenthesized list of element value pairs wherein the values are compile time constants. For additional information regarding JAVA annotations a number of standard references may be consulted including for example Core JAVA Vol. 2 Advanced Features 8th Ed. 2008 . Having thus given an overview of JAVA annotations in accordance with one embodiment an example will now be described.

There are many cases where a tradeoff exists between memory footprint the amount of memory used by the program and application throughput the speed at which the program is executed . For example within JAVA s own library is a String class java.lang.String which includes a field called hash that is used to store the hash code of String objects. It was determined by the developers of JAVA that computing the hash code of a String object every time it is required could consume a significant number of processor cycles and thus a field was created and the hash value calculated once and cached. An alternate implementation however might prefer to suffer this computing overhead rather than the cost of adding a 32 bit field to every String object being allocated.

Thus to allow the JAVA runtime environment to choose between two implementations of this hash value calculation at load time annotations may be employed as shown in the following pseudocode fragment 

In this example the metadata when LARGEMEM annotates the next line i.e. the integer declaration private int hash . The same metadata is also used to annotate the public int hashcode method. Similarly the metadata When Not LARGEMEM is used to annotate the hashcode whenNot LARGEMEM method.

As will be apparent the metadata allows the system to choose between implementing two methods hashcode and hashcode whenNot LARGEMEM based on the when annotation. The parameter LARGEMEM may be user generated e.g. via a command line argument or may be determined at load time based on the hardware platform s memory and or processor capabilities.

In another example annotations are used to annotate synchronized code. For example if a user specifies that certain code is always called within a single thread the annotations may be used to eliminate the synchronization cost associated with the code.

In yet another example an alternate implementation of certain code can be used based on the hardware configuration of the platform being used to run the program. For example a search on a large array can be split among multiple threads where there are multiple cores available for the VM or traversed in one direction by a single thread if only one core is available to the VM.

In another example the location e.g. GPS coordinates of a mobile device is used to determine which classes should be loaded. For example if the system determines that it is located in Germany it may load classes that are specific to operation within a cellular grid or WiFi network in that geopolitical area.

In another embodiment alternate code is implemented based on whether the application is meant to run on a specific device for example an airport kiosk vs. an airline website. The look and feel and other aspects of the application may then be varied using a common code base.

In another embodiment alternate implementations are provided based on whether the application is a trial version or a licensed version. In yet another embodiment alternate implementations are provided based on the level of encryption required based on where the source and target of transferred data lie internal systems as source target do not bother encrypting data data crossing company intranet encrypt the data .

A variety of class loaders and or agents may be employed to evaluate the criteria and load the classes and software components accordingly. The following is an exemplary class loader in pseudocode for use with the example provided above.

In JAVA embodiments because the metadata conforms to the existing JAVA annotation standards it is not necessary to change the virtual machine to accommodate them. Any JAVA compiler will merely place the annotations in a class file. If the runtime does not have knowledge of the annotations then a default state of the class will be taken. This allows the method to be backward compatible with virtual machines that do not know how to conditionally replace code at runtime. The source code is therefore preferably written so that each class functions correctly even if no transformations take place

While at least one exemplary embodiment has been presented in the foregoing detailed description it should be appreciated that a vast number of variations exist. It should also be appreciated that the exemplary embodiment or embodiments described herein are not intended to limit the scope applicability or configuration of the claimed subject matter in any way. Rather the foregoing detailed description will provide those skilled in the art with a convenient road map for implementing the described embodiment or embodiments. It should be understood that various changes can be made in the function and arrangement of elements without departing from the scope defined by the claims which includes known equivalents and foreseeable equivalents at the time of filing this patent application.

