---

title: System and method for virtual folder sharing including utilization of static and dynamic lists
abstract: A system and method for virtual folder sharing, including utilization of static and dynamic lists. Static and dynamic lists may be created as types of virtual folders. Virtual folders expose regular files and folders to users in different views based on their metadata instead of the actual physical underlying file system structure on the disk. A static list consists of a folder of items that are in a specific order, while a dynamic list gathers a set of items based on a scope and a set of criteria. When a list is shared, the actual list is left in place on the sharer's machine or server, while permission is granted to the sharee to remotely access the list and the referenced items. If the list is changed by adding or removing items, these items are also automatically re-permissioned to allow or disallow the sharee to have access to the items.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117226&OS=08117226&RS=08117226
owner: Microsoft Corporation
number: 08117226
owner_city: Redmond
owner_country: US
publication_date: 20090306
---
This application is a continuation of and claims benefit of priority to U.S. application Ser. No. 10 691 841 filed Oct. 23 2003 now U.S. Pat. No. 7 526 483 which application is a continuation in part of U.S. patent application Ser. No. 10 403 174 filed Mar. 27 2003 now U.S. Pat. No. 7 925 682 priority from the filing date of which is hereby claimed. Both of which applications are herein incorporated by reference.

The present invention relates to file systems and more particularly to a system and method for sharing virtual folders.

The sharing of files and folders has always been a difficult task. In known systems users are often limited to just sharing out entire folders. Users typically do not have the ability to share out individual files or items. In order to share files a user has typically had to create a folder organize the desired files in the folder and then share the folder.

The sharing of files has further been complicated by the fact that users also have to deal with files being in different locations such as on different devices on other PCs or online. Files coming from different locations are often organized differently and not kept in the same fashion or place. As another example files stored on a corporate network may inherently be separated from files a user has on a current machine. Users also have to keep track not only of what file data is stored but where it is stored. For example for music files users are forced to keep copies on various systems and to try to track which music files are located where. This can make files difficult to locate even when they are locally stored.

The sharing of files is also complicated by the fact that it is also sometimes difficult to find and return to files that a user has. A user may find it difficult to recall where and how they stored certain files. Given a set of folders and even a group of similar files users often find it difficult to quickly find the one that they are looking for. For files stored in a difficult place to find it is that much more complex to locate. It is also sometimes difficult for users to find or return to files on a network. Users typically have to memorize or map the various sites and names that they need for finding and sharing files on a network.

Organizing and sharing files is also complicated by the fact that name spaces may vary which can cause confusion to the user as to what is correct. This is particularly true on a network where there are different naming conventions limitations and so on. For example certain operating systems may require short names with no spaces in order for them to be visible. Programs also often save files to their own directory or other name spaces which can make it difficult for users to find their way back to the files. Programs often have default directories and places they save documents. A user often has to search through their hard disk and make guesses about where a file is stored. Related items are also often stored in separate places. Related files that a user has may be stored on different parts of the hard disk etc. This problem becomes more common with the developments of digital media services that have multiple content types e.g. pictures music video .

The present invention is directed to providing a system and method that overcome the foregoing and other disadvantages. More specifically the present invention is directed to a system and method for virtual folder sharing.

A system and method for virtual folder sharing including utilization of static and dynamic lists is provided. The static and dynamic lists may be created as types of virtual folders. In accordance with one aspect of the present invention a user is able to construct a query find items and then share the items with other users. The user is provided with the option to share just the items that were located by the query a static list or else to share the located items plus other items that meet the criteria in the future a dynamic list . These types of lists utilize properties of virtual folders which expose items to users in different views based on their metadata instead of the actual physical underlying file system structure on the disk.

In accordance with another aspect of the invention a static list comprises a folder of items that are in a specific order and that can optionally have annotations placed on each item. These annotations are not part of the item but belong to the actual list. Some examples of a static list are a shopping list a music play list and a slide show of pictures. In accordance with the present invention a user is able to share the static list with other users. When the static list is shared the actual static list is left in place on the sharer s machine or server while permission is granted to the sharees to access the list and referenced items. The permissions that are granted are determined by what the sharer specifies at the sharing time. For example the sharer can decide to share out the list to the sharee with just read or read write access etc. In the case that the sharer cannot grant permission to the items since the sharer does not have permission themselves to do this operation then the sharer is notified at the sharing time that the sharee may not be able to access that item. At the conclusion of the process the sharee is able to remotely access the list and its referenced items from the sharer s computer. If the sharer later changes the list by adding or removing items these items are also automatically repermissioned to allow or disallow the sharee s access to the items. In one embodiment it is also possible to dynamically repermission items as they come and go from the static list since the actual definition of the static list lives in the database which can be monitored as it changes.

In accordance with another aspect of the invention a dynamic list comprises a set of items based on a scope plus a set of criteria. For example a user may create a query with a scope defined as all of the data storage on a local machine and a criteria of author X. Once the user has a dynamic list it can be shared out. When the user shares a dynamic list the following operations are carried out. An initial determination is made as to whether the user wants to share just the items that are currently in the dynamic list at that time or else any items that come and go from the dynamic list in the future. If the user wants to share just the items that currently exist in the dynamic list then a static list representing what is in the dynamic list is generated and that static list is shared. If the user instead wants to share out the true dynamic list then all of the items that meet the criteria of the dynamic list are shared. This means the items are left in place on the machine where the sharing is occurring and the items are permissioned to allow the sharee to have access to the items. In the case that the sharer cannot grant permission to the items e.g. the sharer does not have permission themselves to do this operation then the sharer is notified at the time of the sharing that the sharee may not be able to access the items. At the conclusion of the process the sharee is able to remotely access the list and its referenced items from the sharer s computer. If any items in the dynamic list have their properties changed such that they no longer meet the criteria of the dynamic list then these items are appropriately re permissioned. In the same way if any items that do not belong to the dynamic list change such that they fall into the scope and meet the criteria of the dynamic list they are also re permissioned to grant access to the users with which the dynamic list is shared.

A system and method for virtual folder sharing including utilization of static and dynamic lists is provided. The static and dynamic lists may be created as types of virtual folders. Virtual folders utilize the same or similar user interfaces that are currently used for file systems. Virtual folders expose regular files and folders also known as directories to users in different views based on their metadata instead of the actual physical underlying file system structure on the disk. Location independent views are created which allow users to manipulate their files and folders utilizing similar controls as those presently used for managing file systems. In general this means that users can organize and rearrange their files based on inherent properties in the files themselves instead of the managing and organization being done as a separate part of the system. Virtual folders may represent files or items from different physical locations such as from multiple disk drives within the same computer between multiple computers or different network locations such that one view of files or items can expose files or items sitting at different physical locations. In one embodiment the different items or files need only be connected via an IP network in order to be included.

The virtual folder modeling is also able to be used for traditionally non file entities. An application of this is to have a set of user interfaces similar to files and folders that is objects and containers to show traditionally non file entities. One example of such non file entities would be e mails while another would be contact information from a contact database. In this manner virtual folders provide for a location independent metadata based view system that works regardless of whether the data being shown is from files or non file entities. In general these aspects allow more flexibility in terms of letting users manipulate their files and data using both common user interface techniques drag and drop double click etc. as well as leveraging the rich integration of various data types.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer including a processing unit system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that helps to transfer information between elements within the personal computer such as during start up is stored in ROM . The personal computer further includes a hard disk drive for reading from or writing to a hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may also be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A display in the form of a monitor is also connected to the system bus via an interface such as a video card or adapter . One or more speakers may also be connected to the system bus via an interface such as an audio adapter . In addition to the display and speakers personal computers typically include other peripheral output devices not shown such as printers.

The personal computer may operate in a networked environment using logical connections to one or more personal computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the local area network through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As implemented on a system of the type illustrated in the present invention utilizes virtual folders which make it easier for users to share files and to perform basic tasks around file manipulation and folder navigation browsing and to provide higher level storage capabilities which can be leveraged in new features. The virtual folders expose files and items to users in different views based on their metadata instead of the actual physical underlying file system structure on the disk.

As illustrated in the virtual folder system includes a folder processor a relational database a virtual folder descriptions database an other shell folders component a folder handler s component and a shell browser and view component . The folder processor includes a native handling code component a handler factory component a property writer component a rowset parser component a query builder component an enumerator component and a property factory component .

The relational database stores properties about all files in the system. It also stores some items like contacts i.e. non file items entirely. In general it stores metadata about the types of files and items that it contains. The relational database receives SQL queries from the query builder . The relational database also sends SQL rowsets to the rowset parser component with one row per item column columns being the item properties.

The virtual folder descriptions database includes the virtual folder descriptions. The virtual folder descriptions database sends data to the query builder component including a list of types to display in the folder the initial filter and the physical locations to show results from the scopes .

With regard to the other shell folders component the folder processor delegates to existing shell folders from many types of items including all files for handlers or properties. The other shell folders component sends properties from other folders to the property factory . The other shell folders component also sends handlers to the handler factory .

The folder handlers component provides code behavior for the items that exist only in the database like contacts. This is what allows non file items to behave akin to files. The folder handlers component sends handlers to the handler factory .

For the native handling code component the folder processor directly implements certain handlers based on the properties of the items. The native handling code component sends handlers to the handler factory . For the native handling code component and the folder handlers component like all namespaces virtual folders have to provide a set of handlers context menu icon thumbnail infotip . . . for their items. For most of these infotip data object drag drop handler background context menu . . . the virtual folder provides a common native handler for all the types it holds. However there are others which the author of the type has to provide context menu on the item itself writable property store . . . . The default handler can also be overridden. Virtual folders reuse this for files and allow non file items do the same.

The handler factory takes ID lists and produces code behaviors that provide context menus icons etc. In general the folder processor may use native handlers external handlers or delegate to other shell folders to get handlers as described above with respect to the native handling code component the other shell folders component and the folder handlers component . The handler factory component sends handlers to the shell browser in view as requested by the view. The handler factory component sends a property handler to the property writer .

The property writer converts user intentions such as cut copy and paste into property rights to the file or item. A shell browser and view component sends data to the property writer including direct manipulation cut copy paste or editing of metadata. In general since virtual folders present an organization based on the properties of an item operations such as move and copy drag drop become an edit on those properties. For example moving a document in a view stacked by author from Author 1 to Author 2 means changing the author. The property writer component implements this function.

The rowset parser takes database rowsets and stores all item properties into a shell ID list structure. A rowset takes the piecewise definition of the virtual folder and builds a SQL string which can then be issued to the database. The rowset parser component sends ID lists to the enumerator component . As described above the rowset parser component also receives data from the relational database including SQL rowsets with one row per item the columns being item properties.

The query builder component builds SQL queries. The query builder component receives data from the enumerator component including new filters from the navigation. The query builder component also receives data from the virtual folder descriptions database including a list of the types to display in the folder the initial filter and the physical location to show results from the scopes . The query builder component sends the SQL queries to the relational database .

In general the query builder component includes a set of rows in other words a table . This is what running the query yields. The rowset parser component takes each row and using the column names transforms the row into an ID list. An ID list is a well known shell structure which is used to reference items in a namespace. Doing this allows virtual folders to be just like any other namespace to the rest of the shell. Also caching this data helps keep database access which can be costly to a minimum.

The enumerator component operates in response to a navigation to a virtual folder. As described above the enumerator component receives ID lists from the rowset parser component and sends new filters from the navigation to the query builder component . The enumerator also sends data to the shell browser and view component including ID lists that are returned to be inserted into the view after a navigation.

The property factory component takes ID lists and property identifiers and returns values for those properties. The property factory component receives data from the handler factory component including the property handler. As described above the property factory component also receives data from the other shell folders component including properties from other folders. The property factory component also sends data to the shell browser and view component including item properties as requested by the view.

The shell browser and view component displays the contents of a folder in a window and handles all the user interaction with the displayed files or items such as clicking dragging and navigating. Thus the shell browser and view component receives the user actions. The shell browser and view component also gets the data regarding the code behaviors that it needs from the folder in this case the folder processor .

As described above the virtual folders expose regular files and folders also known as directories to users in different views based on their metadata instead of the actual physical underlying file system structure on the disk. Thus the system is able to take a property that is stored in the database and represent it as a container that is like a folder. Since users are already familiar with working with folders by presenting the virtual folders in a similar manner users can adapt to the new system more quickly.

At a block the folder processor takes these results and converts them from the rows and columns of data into an enumerator structure which is used by the folder view to populate the screen with the resulting virtual folders and items for the user to interact upon. At a decision block a user decides whether to change the view by issuing a different query or pivot . For example a user could issue a show all artists pivot. If the user does want to change the view then the routine returns to block where the folder processor passes this new query to the relational database and receives back new rows and columns of results and constructs a new enumerator structure. The process then continues as described above as the folder view clears and updates using the enumerator to draw the artist objects to the screen.

In one example album objects are provided that represent containers that users can navigate into. For example double clicking the Beatles albums will navigate the view to see all of the Beatles songs. The folder processor issues the show all Beatles songs query to the relational database which hands back the rows and columns of data for those songs. The folder processor creates an enumerator of all these songs which then get drawn to the screen.

The user can also choose the view at any point while browsing virtual folders. From the above example after narrowing down to just show Beatles songs a user can change the view to only show the songs as albums. The process of changing the view of items into another representation is called stacking . This is because the items are conceptually arranged into stacks based on that representation. In this case the songs are rearranged into stacks for each of the various albums. Users can then navigate into one of these stacks only seeing the songs from that particular album. Again the user can rearrange the view of these remaining songs into stacks based on a property e.g. a rating for example . If the rating property were selected the songs from that Beatles album would be shown in stacks for a one two or a three star rating.

The results of each query depend on which physical locations are included in the scope. For example the scope may be made to include only the folders in the user s my documents folder. Alternatively the scope could include all folders on the computer or even all folders on multiple network connected computers. The user is able to view and change the scope through a scope property sheet. In one example the scope property sheet could be exposed by right clicking on the virtual folder and choosing properties. The user could add new folders to the scope or remove folders that were previously added.

One group of users for which virtual folders will provide particular utility is knowledge workers. Virtual folders allow knowledge workers to easily switch between viewing documents by file type project case number author etc. Since knowledge workers each tend to have a different method for organizing documents virtual folders can be used to accommodate these different preferences.

As illustrated in a folder is a my documents folder. At a first level the folder includes folders and corresponding to Clients and respectively. At a second level each of the folders and contain a folder and respectively which each correspond to the contracts for the selected client. At a third level each of the folders and contains a folder and respectively each corresponding to the year 2001. At the third level each of the folders and also contains a folder and respectively each corresponding to the year 2002.

It will be appreciated that a number of obstacles are presented to a user who wishes to navigate a physical folder file structure such as that illustrated in . For example if the user wishes to work with all of the contracts that the user has produced the user will first need to navigate to the folder to work with the contracts for Client 1 and then will have to renavigate to the folder to reach the contracts for Client 2 and will again have to renavigate to the folder for the contracts for Client 3. This arrangement makes it difficult for the user to access all of the contracts and in general prevents simultaneous viewing and manipulation of all of the contracts. Similarly if the user wishes to view all of the contracts produced in the year 2001 the user will have to navigate and renavigate to the folders and respectively. As will be described in more detail below the virtual folders of the present invention provide an improved file system structure.

The quick link elements include an all categories quick link on all authors quick link a January work quick link and a selection for displaying additional quick links . As will be described in more detail below quick links can be selected by a user to perform desired navigations of the virtual folders. Quick links may be provided by the system and some quick links may be created and saved by a user.

The filter elements include a filter by indicator an entry blank a by date indicator a year selector a pick an author selector a pick a category selector and a more filters selector . The filter by indicator directs a user to the fact that the items below can be used to filter the virtual folders or items. The entry blank provides an area in which a user can type a desired new filter term. The by date indicator directs a user to the fact that by selecting a date from the year selector the virtual folders or items can be filtered by the selected year. The pick an author selector allows a user to filter according to a specific author. The pick a category selector allows a user to filter according to a selected category. The more filters selector allows a user to pull up additional filters on the display.

The activity selectors include a create a new category selector activity selectors and and a more activities selector . As will be described in more detail below the activities that are presented may be for generally desirable functions or may more specifically be directed to activities useful for the type of virtual folders that are currently being displayed. For example the create a new category selector can be selected by the user to create a new category which will be represented by a new stack.

As noted above the activity selectors and may be more specifically directed to the type of folders or items that are being displayed. For example the present display is of a document library for which the activity selectors and may be directed to activities specifically tailored for documents such as editing or creating attachments. If the present library had been a photo library the activity selector and could be for activities specifically directed to photos such as forming photo albums or sharing photos with other users.

The information and control elements include information lines and a control line a backspace control and information lines and . The information lines and provide information as to the current navigation of the virtual folders or items. In the present example the information line indicates that the current navigation is to a document library while the information line indicates the more complete navigation showing that the document library is within the storage area. The control line provides a number of standard controls and the backspace button allows a user to back up through a navigation. The information line provides numerical information about the contents of the present navigation. In the present example the information line indicates that there are 41 items which take up 100 MB in the stacks of the document library. The information line is available to provide additional information such as additional information about a file that is selected.

The stacks of the document library include an ABC Corp. stack a backups stack a business plans stack an XYZ Corp. stack and a marketing reports stack . The numbers on top of each of the stacks indicate how many items are in each stack. For example the ABC Corp. stack is shown to include 8 items. The total number of items of the stacks adds up to the number of items indicated in the information line which as described above is 41 in the present example. A selection box SB is provided which can be utilized by a user to select a desired item. The selection of the ABC Corp. stack yields a view of the items of that stack as will be described below with respect to .

As shown in a user is able to switch from the virtual files representation of to the physical file representation of . This allows a user to toggle between virtual file representations and physical file representations depending on which is desired for a current task. The different locations of the physical folders also illustrate that the scope of the virtual file system may be relatively broad as will be described in more detail below.

Another example of direct manipulation is right clicking an item and selecting delete. In one embodiment when a deleting function is selected by a user the user is queried whether the item should be deleted all together or simply removed from the present virtual folder. If the item is just to be removed from a present virtual folder category stack as noted above this can be accomplished by removing the desired category from the metadata for the item. In other words if one of the items that had been copied from the ABC Corp. stack to the West Coast stack was then to be removed from the West Coast stack this could be accomplished by modifying the category data for the particular file to no longer include the West Coast category.

As shown in at a block a user makes a selection on the display to indicate that a new quick link should be formed from the present filter term or navigation. At a block the user provides a new name for the new quick link. At a block the new quick link is saved and the new quick link name is provided in the quick link section on the display.

As shown in at a block a scope is defined for the physical locations from which items are to be drawn. At a block in response to a query the items are drawn from the physical locations as defined in the scope. At a block all of the items drawn by the query are presented on a single display.

As will be discussed in more detail below the present invention provides the ability to share out virtual folders which may be static or dynamic. The sharing of static and dynamic lists allows a user to share selected items. A sharee is granted permission to the items in the list and as the list is changed the permissions are updated so that the sharee continues to have access to the current items of the list.

In the process of determining whether the sharer has permission to share each item in one embodiment the list itself is the first item that the permission is determined for. In other words the first step is to determine whether the sharer has permission to share the list itself. If the sharer does not have permission to share the list then the sharer is notified that they do not have permission to share the list and the routine ends. If the sharer does have permission to share the list then a determination is made for each of the items that are referenced by the list as to whether the sharer has permission to share each of the items. If the sharer does not have permission to share a particular item then the sharer is notified that that item can not be shared. At the end of the process for the set of items that the sharer does have permission to share the routine continues to block .

At decision block a determination is made as to whether the sharer has indicated that the sharee should be provided with read and write access as opposed to just read access. If the sharer indicated that read and write access should not be provided then the routine continues to a block where the sharee is provided with read permission only. If the sharer indicated that the sharee should have read and write access then the routine continues to a block where the sharee is provided with read and write permission. At block the designated access is granted to the sharee to the static list itself as well as any items that are referenced in the static list. The sharee is then able to remotely access the static list and its referenced items from the sharer s computer.

As described in more detail above with respect to certain virtual folders such as libraries rely on dynamic lists for their creation. For example a user would typically go to their document library to find their documents. The document library is a type of dynamic list. The scope for the list may be set to be the data storage that is available on a local machine or as another example may include data stored on all of the machines on a network.

In the process of determining whether the sharer has permission to share each item in one embodiment the list itself is the first item that the permission is determined for. In other words the first step is to determine whether the sharer has permission to share the list itself. If the sharer does not have permission to share the list then the sharer is notified that they do not have permission to share the list and the routine ends. If the sharer does have permission to share the list then a determination is made for each of the items that are referenced by the list as to whether the sharer has permission to share each of the items. If the sharer does not have permission to share a particular item then the sharer is notified that that item can not be shared. At the end of the process for the set of items that the sharer does have permission to share the routine continues to decision block .

At decision block a determination is made as to whether the sharer wants to share the items only in the static list format. In other words a determination is made as to whether the sharer wants to share the current items in the form of a static list rather than a dynamic list. If a static list is to be shared then the routine continues to a block where a static list that represents what is currently in the dynamic list is generated and that static list is shared as described above with respect to . If the sharer does not want to only share in static list form then the routine continues to a block .

At block all of the items that meet the criteria of the dynamic list are shared. This means that the items are left at their respective storage places on the machine where the sharing is occurring and the items are permissioned to allow the sharee to have access to the items. At the conclusion of this process the sharee is able to remotely access the list and its referenced items from the sharer s computer.

A programming interface may be utilized as part of the list sharing process. As will be described in more detail below with respect to a programming interface or more simply interface such as that used in the list sharing process may be viewed as any mechanism process protocol for enabling one or more segment s of code to communicate with or access the functionality provided by one or more other segment s of code. Alternatively a programming interface may be viewed as one or more mechanism s method s function call s module s object s etc. of a component of a system capable of communicative coupling to one or more mechanism s method s function call s module s etc. of other component s . The term segment of code in the preceding sentence is intended to include one or more instructions or lines of code and includes e.g. code modules objects subroutines functions and so on regardless of the terminology applied or whether the code segments are separately compiled or whether the code segments are provided as source intermediate or object code whether the code segments are utilized in a runtime system or process or whether they are located on the same or different machines or distributed across multiple machines or whether the functionality represented by the segments of code are implemented wholly in software wholly in hardware or a combination of hardware and software.

Notionally a programming interface may be viewed generically as shown in or . illustrates an interface Interface1 as a conduit through which first and second code segments communicate. illustrates an interface as comprising interface objects I1 and I2 which may or may not be part of the first and second code segments which enable first and second code segments of a system to communicate via medium M. In the view of one may consider interface objects I1 and I2 as separate interfaces of the same system and one may also consider that objects I1 and I2 plus medium M comprise the interface. Although show bi directional flow and interfaces on each side of the flow certain implementations may only have information flow in one direction or no information flow as described below or may only have an interface object on one side. By way of example and not limitation terms such as application programming interface API entry point method function subroutine remote procedure call and component object model COM interface are encompassed within the definition of programming interface.

Aspects of such a programming interface may include the method whereby the first code segment transmits information where information is used in its broadest sense and includes data commands requests etc. to the second code segment the method whereby the second code segment receives the information and the structure sequence syntax organization schema timing and content of the information. In this regard the underlying transport medium itself may be unimportant to the operation of the interface whether the medium be wired or wireless or a combination of both as long as the information is transported in the manner defined by the interface. In certain situations information may not be passed in one or both directions in the conventional sense as the information transfer may be either via another mechanism e.g. information placed in a buffer file etc. separate from information flow between the code segments or non existent as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation e.g. depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration and so this list should be considered illustrative and non limiting.

This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are however other ways to implement a programming interface and unless expressly excluded these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.

It is also noted that the above described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways serially and or in parallel or with other intervening code. Thus the alternative embodiments presented above are not mutually exclusive and may be mixed matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that as with most programming constructs there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein but nonetheless are represented by the spirit and scope of the invention i.e. it is noted that it is at least partly the functionality represented by and the advantageous results enabled by an interface that underlie the value of an interface.

While the preferred embodiment of the invention has been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

