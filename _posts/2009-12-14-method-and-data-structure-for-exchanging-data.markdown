---

title: Method and data structure for exchanging data
abstract: A method and system for exchanging at least one data value between a first device and at least one second device, including providing at least one data structure at the first device, the data structure including at least one descriptive field and an associated at least one data value field, the at least one data value field including the least one data value, the at least one descriptive field including a usage type field having usage type data to associate the at least one data value field with a data type, transmitting the at least one data structure from the first device to the at least one second device, and, based on at least the usage type data, at the at least one second device, extracting the at least one data value from the at least one data value field.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484156&OS=08484156&RS=08484156
owner: Invensys Systems, Inc.
number: 08484156
owner_city: Foxboro
owner_country: US
publication_date: 20091214
---
This application is a continuation of U.S. application Ser. No. 10 403 687 filed Mar. 31 2003 hereby incorporated herein by reference.

The disclosed methods and data structures relate to data transfer and more particularly to data transmission between processors that may use separate address space.

In efforts to increase efficiencies commercial and industrial process control may have become increasingly automated. A wide variety of sensors actuators and other process monitoring and or control devices may monitor and adjust the commercial and or industrial process through one or more processors of the process system. For example the sensors may monitor operating parameters for the process or may evaluate process flow and may provide feedback data regarding the monitored parameters or process status. The feedback data may be provided to one or more of the processors which may then store and use the data to generate system control signals that one or more actuators may use to adjust the process. To communicate with the process control devices the processors may typically operate by an operating system such as Windows NT Solaris OSE or other known operating system which enables the processor to communicate with the process control devices.

Commercially available software may also be employed to interface the process control devices with the operating system of the processors of the process control system. Such software may not directly integrate with some of the processor operating systems and thus may have to be customized for operation with the processor operating system by an experienced programmer. As an example customization of process control device software designed to operate in a Windows NT environment which can employ a machine architecture that orders bytes of data values in memory from least to most significant may be required such that the process control device may communicate with the process control system that may be operating in a Solaris or OSE environment where the bytes of data values can be ordered from most to least significant. Additionally system upgrades maintenance and or process control device changes may require reprogramming. Thus the added costs associated with providing compatible processors and process control devices may substantially increase installation operation maintenance and upgrade costs for the automated process control system.

Data values may be sent between the processors and the applications and or between the processors themselves. Thus it may be necessary to ensure that data structures are compatible among the processors and or process control devices. A mechanism to provide flexibility for applications to build and interpret data structures such that the data values that may be contained within the data structures may be exchanged between processors and or process control devices may reduce the costs for providing compatibility between processors and or process control devices.

The disclosed methods and systems include a method of exchanging at least one data value between a first device and at least one second device which include providing at least one data structure at the first device the data structure including at least one descriptive field and an associated at least one data value field the at least one data value field including the least one data value the at least one descriptive field including a usage type field having usage type data to associate the at least one data value field with a data type transmitting the at least one data structure from the first device to the at least one second device and based on at least the usage type data at the at least one second device extracting the at least one data value from the at least one data value field. The at least one data structure can include at least one header data structure and at least one non header data structure the at least one header data structure specifying a machine architecture associated with the first device.

The data structure s can include a value record the at least one header data structure can be a header container and the at least one non header data structure can be at least one of a single container a double container a bytegroup container a string container an array container and a structured data container.

The data structure s can include a data structure version type field a template field and or a template identification field where such fields can be part of the descriptive fields. The descriptive field s can include a pointer to at least one second data structure the at least one second data structure including a descriptive field s and an associated data value field s . Accordingly extracting the data value s from the data structure s can include identifying a pointer to a second data structure s and based on the pointer and a descriptive field s in the data structure s extracting the data value s from the data value field s . Extracting can thus include iteratively identifying a pointer until the pointer value is NULL.

The disclosed methods and systems thus allow for an exchange of data values when the first device and at least one of the at least one second device have a different architecture. Different architecture can include processor architecture. Accordingly as provided herein fields can include a memory element or part thereof and a data structure can be comprised of one or more memory elements and or fields. As provided herein a data structure can include one or more data fields that include data to be transmitted and one or more descriptive fields to describe or otherwise be associated with the data to be transmitted. The disclosed methods and systems can accordingly allow for a data structure that includes at least two data structure s that can have different usage type data where usage type data can be a signed short integer type a signed long integer type a character type a signed real number type an unsigned short integer type an unsigned long integer type a boolean type an unsigned character type a 64 bit real number type a string type and or an undetermined type.

In one embodiment the methods and systems include determining from the descriptive field s that the data structure s is a template and based on whether the data structure s is a template identifying a template identifier from the descriptive field s and storing the template with the template identifier. The methods and system also include determining from the descriptive field s that the data structure s includes a data only data structure s and based on the determination identifying a template identifier from the at least one descriptive field retrieving a template associated with the template identifier and extracting the data value s from the data structure s based at least on the template. The methods and systems can allow the template to be stored retrieved and or accessed via a wired and or wireless network and or the template can reside locally. When a data value s is extracted based on a template the data value s can be extracted based on at least one descriptive field of the retrieved template.

The methods and systems can facilitate methods and systems where the first device may use a first address space and the second device s may use a second address space s .

The disclosed methods and systems also include a method of exchanging data between a first device and at least one second device including defining a data structure having at least one descriptive field and the data where at least one descriptive field indicates the data structure is at least one of a template structure a data only structure and a complete structure based on whether the data structure is a template structure and a data only structure providing at least one descriptive field to identify a template identification providing at least one descriptive field to identify a data structure type based on at least one of the template identification and the data structure type assembling the at least one data structure transmitting the at least one assembled data structure between the first device and the at least one second device and at the at least one second device extracting the data based on at least one of whether the data structure is a template structure a data only structure and a complete structure and the data structure type.

The method and systems include extracting the template identification as the data when the data structure is a template structure and or a data only structure. In an embodiment based on the data structure being a template structure extracting the data can include storing the template and a template identification associated with the template structure. Accordingly based on the data structure being a data only structure extracting can include retrieving a template based on a template identification and based on the retrieved template and the descriptive fields in the retrieved template extracting the data from the data only structure.

In the disclosed methods and systems extracting the data from the data structure s can include extracting based on a descriptive field associated with an architecture of the first device. Extracting can also be based on a descriptive field associated with a data type of the data structure s .

To provide an overall understanding certain illustrative embodiments will now be described however it will be understood by one of ordinary skill in the art that the systems and methods described herein can be adapted and modified to provide systems and methods for other suitable applications and that other additions and modifications can be made without departing from the scope of the systems and methods described herein.

Unless otherwise specified the illustrated embodiments can be understood as providing exemplary features of varying detail of certain embodiments and therefore features components modules and or aspects of the illustrations can be otherwise combined separated interchanged and or rearranged without departing from the disclosed systems or methods. Additionally the shapes and sizes of components are also exemplary unless otherwise provided and can be altered without affecting the disclosed systems or methods.

With reference to the embodiment the second device can be a process control device that can monitor or adjust the process controlled by first device . The second device can also include a processor that may control a part of the process controlled by the first device or a related or separate process. Generally data signals between the first and second devices may affect the control of the process. It can be understood that the first and second devices may also be connected to other devices shown generally as devices A with which they may exchange data signals over the network N.

With continued reference to the network N can be one or more networks and or network connections that can include one or more wired and or wireless networks intranets the internet and others. Accordingly the network can include for example a network that can be implemented using Fieldbus Nodebus and or Ethernet communications protocols although other wired and or wireless communications protocols and or standards can be implemented without departing from the scope of the disclosed methods and systems.

With reference to the first device and or second device can include for example one or more of the workstations control processor s and or I O modules . As provided previously herein for example the illustrated control processor s may communicate one or more VRs to for example the I O module s and or one or more of the workstations in such a way as to allow the transfer of data to be irrespective of the application running on the receiving device and or the processor machine type of the receiving device. For a network such as provided in accordingly one or more of the workstations can be replaced with a different machine type etc. and the disclosed methods and systems can facilitate or otherwise allow the illustrated control processor to continue communications with such replacement without otherwise requiring the control processor to reformat the VR data structure.

The system can be representative of an I A Series system from Invensys Systems Inc. The I A Series system can includes the illustrated I O Modules such as FBM44 modules wherein the I O Modules can interface to a Fieldbus and hence to a Control Processor such as the I A Series CP40B. Data from sensors can be transferred to the I O modules using a transmitter wherein the I O Modules can convert the sensor data to the Control Processor . In one embodiment of the system the Control Processor can include at least one processor that includes instructions for causing the processor to implement control algorithms. The Control Processor can interface to Workstations through an I A Series Nodebus that can be compatible with Ethernet. The Workstations can be for example the VA Series system AW51E that or another system. The Workstations can have access to one or more internal or external databases and can allow for the display of data to allow a processor engineer manufacturing personnel etc. to monitor and or affect the controlled systems. The illustrated Workstations can further interface to another Ethernet that provides an interface to for example a corporate network that can be equipped with other Workstations Personal Computers PCs etc. that can also have instructions for causing the display control to management or other entities.

Returning to the Control Processor the Control Processor can be equipped to transfer control data to for example the valves or sensors via the I O Modules to achieve specified control objectives. In one embodiment the control objectives can be pre programmed using a multivariable control system such as the Connisseur system provided by Invensys Systems Inc. however in other embodiments manufacturing or other process system adjustments can be made manually or through the I A Series Workstations . Accordingly as indicated herein the disclosed methods and systems can be applied to a system such as systems according to where the various system elements may use different processors different operating systems different architectures etc. and further can be individually updated without respect for other system components.

As previously noted the operating systems and or data structures of first and second devices may not be compatible. To provide a common format for the exchange of data between first and second devices an Application Programming Interface API may be provided to build and interpret data structures known herein as Value Records VR s . For the illustrative diagram of first device can initiate API to build a VR for the data it wishes to exchange with second device . The second device can then optionally use the API to interpret the VR . Those of ordinary skill will understand that some embodiments may not employ the API but may otherwise be configured with instructions for building and or interpreting a VR.

A VR can thus include one or more data elements with information and or other data that can be used to identify describe and or otherwise organize the data element s . As will provided herein in some embodiments the data used to identify describe etc. may be provided by another VR e.g. template .

A VR as described herein can include one or more data structures known herein as containers that can be associated with data values or groups of values. A VR can include data of various types that may be exchanged between devices such as the first and second devices for various device architectures. A VR can include status and other information that can describe the data value or group of values. A VR may be constructed to be self describing in that it can include the information needed by a receiving device e.g. to unpack and understand and or otherwise interpret the VR contents using the API . The VR may be constructed by associating one or more data containers.

For the disclosed methods and systems the first and second devices e.g. between which VRs are transmitted may use separate address spaces. Accordingly the VR can include a self referencing scheme that can employ an offset and a size for pieces of data within the VR. Unlike other data structures a VR may not include an address pointer that could be invalid when copied to a different address space.

A VR can include a header container. A header container can include data to identify the VR to a receiving device. One or more additional containers can be appended to the header container for the data signals that can include data values or additional data such as structured data array data and or strings. The header container may thus include data and or information that can describe general characteristics of VR such as its overall size the source e.g. processor architecture used while constructing the VR etc. A VR size may not exceed a maximum integer value for the device architecture where the VR and API may be implemented. As an illustration for the exemplary 32 bit implementation described herein the size limit may be the maximum value that can be held in a 32 bit unsigned integer or about 4.29 gigabytes. It will be understood that other implementations for other device architectures may have other size limits.

Table 1 shows one example of a header container with illustrative data format sizes although those of ordinary skill will recognize such sizes and data items to be illustrative of one embodiment and other embodiments can use other formats and fewer and or more data items and or with different data item names.

Other containers can be appended to the header container including generic containers string containers array containers and structured data containers. A generic container can include data of some number of contiguous bytes and can be a parent container type to create container sub types. Some illustrative sub types can include single containers e.g. four bytes double containers e.g. eight bytes and bytegroup containers e.g. length in bytes as specified when the bytegroup container may be created . While single and double containers can be of fixed size a bytegroup container may be limited by the parent VR size. Table 2 includes one illustration of a generic container. Table 2 like Table 1 and other Tables herein is illustrative to show one container for one embodiment and fewer container elements can be used and or more container elements e.g. data items can be used with the data item formats being provided for illustration and not limitation.

The value field can have an associated usage type field that can be used to identify the data type of the value data item. For instance a single character placed into the value field of a VR as a 32 bit unsigned integer may be given a corresponding usage type or data type e.g. a 32 bit signed integer a 32 bit unsigned integer a 32 bit real value a 64 bit real etc. that can indicate a 32 bit unsigned integer. Accordingly when building a VR the data type and or usage type can be implicit and the user can be responsible for ensuring that the data value entered into the VR corresponds to the data type that maps to the usage type.

A string container can include one NULL terminated character string. The string container size given by the number of characters in the string can be specified at the time the container is added to the VR . The structure of the string container can be similar to that of the generic bytegroup container where the length varies per container based on the string contained in the Value data item. A string container size generally cannot exceed its parent VR size. Table 3 shows one illustrative structure for a string container 

An array container can include an indexed group or array of one or more data items with members of the array being of the same usage type. The size of the items in a group can be for example 32 or 64 bits except for a group of strings which can be of varying lengths. The array container structure can be similar to that of the generic container except that an unsigned integer data item count may be added to indicate how many data members may be in the array. An array container size may not exceed that of its parent VR. Table 4 shows one illustrative structure for an array container 

A structured data container can provide a means of packaging non homogeneous data containers of varying types and in varying orders including generic string and array container types and other structured data containers. Structured data containers may thus be nested e.g. one structured data container may be placed within e.g. referenced by another. The levels of nesting and or number of data containers added to a structured data container may not exceed the size of the parent VR. Table 5 shows one illustrative structure for a structured data container.

When adding a container to a structured data container the description information of the container may be added to the structured data container s description area and or the descriptive fields while the data fields of the added container may be added to the structured data container s data value area and or data value field. The structured data container may include tables of offsets for the added container name description and data. Structured data containers may thus include description information and data information and or may include description information only or data information only. When the same data types and organization of data may be repeatedly communicated between first and second devices the structured data container can be used to transmit the description information to the destination once or another limited number of times while the data portion can be transmitted repeatedly.

To build and interpret the VR containers described above the first and second devices may use external module function calls of API . The name of the module the argument list data type of respective arguments and the return type for the module may be representative of an exemplary C language implementation of the API though it can be understood that implementations in other programming languages compatible with the first and second devices may be contemplated.

VR creation can include a specifying for example through the API a memory allocation style a size parameter corresponding with the memory allocation style and a pointer to the returned VR container. In some embodiments memory space can be allocated by choosing from among memory allocation styles including auto manual and reuse. In one embodiment the chosen memory allocation style can be used throughout the life of the VR so as reduce errors that can result from mixing memory allocation styles. In an embodiment bytes of space used to construct a VR can be initialized to NULL before being used.

For the exemplary embodiment when the auto memory allocation style is selected the API can allocate memory to build a VR and the resultant VR may be typically a right sized VR since API may allocate enough memory to fulfill the request. In auto mode the user can specify a size for the VR to be built. If the VR exceeds this size an error can be returned and additional memory may not be automatically allocated. A size of zero in auto mode can indicate no limit is specified for automatic memory allocation. For API auto may be the default memory allocation style.

When the manual memory allocation style is selected the user can specify an amount of memory to be allocated. The size parameter can allocate the specified amount of space for the VR rounded up to the nearest block boundary . If this size is exceeded while building VR containers into this VR space an error can be returned. In some embodiments after such an error call the user may use an enlarge module function call to specify an increase of the overall size of the VR by some desired and or specified amount.

When the reuse memory allocation style is selected the user can allocate and free memory to build the VR with the use of API memory management calls as may be standard for the programming language being used and as provided in the device. The size argument can include the size of the memory block previously allocated by the user. If this space is exceeded an error can be returned and the user can be responsible for determining how whether additional space should be allocated. For the reuse memory allocation style the pointer may be a pointer to the block of memory allocated by the user for reuse. In reuse a previously allocated memory area can be reformatted and used to build the VR .

When it may be time to discard a VR built with auto or manual memory allocation the user may use a delete API module function to free space. Parameters may include a pointer to an existing VR .

For one exemplary embodiment the space and or memory provided for data in a VR can be 34 bits e.g. a 20 bit header and one 14 bit generic single container . Use of a container of that size for transmitting a data item may be inefficient in cases when data items may be smaller than the exemplary 34 bits. For example a group of data that includes 15 status bits and two characters may employ 17 discrete single containers where one container may be provided for a data item. Considering that the single container can be 14 bytes in size a total of 17 14 20 or 258 bytes can be employed. In such cases the user can provide subroutines that can write read these data items to from just a single 32 bit container. These routines may assign a unique data range for the data items within one 32 bit data space fitting the data into the single container with one unused bit. This method may consume a total of 14 bytes for the one single container.

While a VR that may include data along with a description of itself can be a reliable mechanism it may be inefficient in cases where the same data types are sent between the same source and destination. In such cases if the description information is known at both the source and destination then only the data portion of the VR can be transmitted. In these embodiments the data portion of a VR may be separated from the description portion into an independent container. A complete VR may still be sent if desired or the data only version of the VR may be sent. Sending a data only VR can reduce the size of the VR . Additionally once the data only VR is received at its destination the description information can be determined more readily since a single description can apply to the containers in the data only VR rather than individual containers having their own descriptions.

The ability to send a data only VR can indicate that the description information for the data only VR be available to and or at the devices A on the network N either directly or indirectly e.g. via a wired or wireless network . The devices A may maintain and or have access to descriptions of the data only VR s. The data only VR may include a template ID such that the description information or template to which the data in the data only VR may be formatted can be retrieved when a data only VR may be received. It can be seen however that the devices A may have their own listings. On large networks N with large numbers of devices the size of the listings can exceed the available memory space in the device.

In one embodiment a DataType server may be connected to the network N. The DataType server may include one or more processors accessible to the devices A via the network N. Server can be responsible for providing to a requesting device the description template for the data only VR . The description template can include some number of bytes a numeric ID that can be unique and an optional name associated with it. Predefined description templates may be loaded into server at initial startup and additional templates may be created and added by the devices A . When a data only VR is received at a device the device can query server to obtain the description template.

A template may include of a copy of a VR with description information and the size and byte order. Data fields and or areas may also be placed and sized within the template however the data value areas may not include valid data values. Instead an indicator e.g. is template flag see Table 1 can be set to indicate that the VR is a template. The data value area field for a container can store a pointer that can point to the data in the corresponding data only version of VR . For example the first 4 bytes of the data value area field can be overloaded to include an unsigned long offset that can be used as the pointer. Other e.g. unused bytes of data value area field can be initialized to NULL. When a VR exists with no corresponding template the two fields template ID and data only size in the header container can include a value of zero. At the time a template is created for VR the appropriate values can be written into these fields in both the original VR and the corresponding template VR.

Once the user builds a VR from one or more containers the user may use the VR as a template for future data only transmissions. The template VR can reside on a server accessible on the network or may be propagated to devices A on the network that may have interest in receiving the data. API calls for operating with template and data only VR s can include calls to create a template to create a data only VR and to restore a data only VR to an original VR .

In creating a template the input and return parameters can include a pointer to a VR that the template can be created from a value for template ID and a pointer to the created template. Once a template exists the original VR and its template can be supplied as an input argument to create a data only VR from a complete VR . The data only VR version can be sent across the network N. At the destination at least some of the contents of the data only VR may not be accessed directly as the data only VR can be queried for its template ID. If a copy of a template VR containing the template ID can be found at the destination or at a server on the network N the template VR and data only VR can be supplied as to produce a copy of the original VR at the destination. A data only VR can thus be restored to a complete VR based on the template ID.

As noted previously a VR may begin with a header container to which one or more containers may be added or appended. In the illustrative auto mode of memory allocation a new pointer can be provided when a container is added to a VR .

A bytegroup may be some number of contiguous bytes. A bytegroup can be placed into and retrieved from a VR but the VR may have no internal knowledge of this group of bytes. VR may treat a bytegroup the same as another data value. In this case VR may not be completely self describing i.e. VR may not have a query routine to examine the internal contents of a bytegroup. Accordingly the user can provide routines to use or otherwise operate on the group of bytes. A bytegroup may be used to implement nested VR s. Typically VR may keep header information in a first container that can describe the internal construction of the VR with respect to a first container. When nested confusion may occur as more than one first container can be discovered. By treating the nested VR s as a simple bytegroup the VR s can be nested to a desired level. Unused trailing bytes in the data can be nulled.

A structured data container or struct can be added or appended to an existing VR via the API. Once the struct exists the contents of the struct containers or discrete values within the containers can be filled before other containers are added to the VR . When the struct being added is not be the last container appended to the VR an error can be generated. As previously described the VR may be a chain of containers where the containers have offset values pointing to the next container in the VR . A container with a NULL value for next can indicate the last container in the VR . A struct with its non homogeneous members may be constructed much the same way.

Once the struct is complete another container can be appended to the VR following the struct. When a member container is added to a struct the struct s total size may change whereas most other containers when created can be fixed in size. The above error can occur when an attempt may be made to add another container and therefore more space to an existing struct that may be in the middle of the VR i.e. with other containers having been appended after that struct. The error can thus prevent new space from being added to a VR except at the end of the VR.

The API can provide calls to retrieve the data within a VR . The input parameter for the retrieval or get calls may include a pointer to the existing VR another container within the VR a string or a member of a struct container. The output may correspond to the data item name in the call as shown in Table 2. For example the output of a call to get the allocated size of the VR can be the data item in the VR corresponding to the allocated size. Such get calls can include calls to retrieve allocated size required size memory style container type usage type data type data values string length bytegroup array elements and member names struct members and member names index values member types and VR type e.g. template data only or complete.

API utility and access calls can allow a user to obtain a pointer to the next container within a VR given a pointer to the previous container. Additional calls include obtaining the number of containers in a VR and or a number of containers remaining between a specified container and the end of the VR . In some embodiments containers at one level may be counted e.g. struct containers at the current level but containers within struct containers may not be counted.

An exemplary API can allow a user to obtain a count of elements in a VR . If the input pointer is to a struct within a VR the user can be provided with a number of members in that struct. If the input is a pointer to an array within a VR the user can be provided with a number of elements in that array. If the input is a pointer to a string container within a VR the user can be provided with a size of the largest string this container can hold. Other utilities may provide a structured text of information extracted from a VR including data types sizes and current values of the containers within the VR that can be used as a debugging tool.

One or more additional containers can be appended to the header and populated to complete the VR . The VR may then be sent and or transmitted from one device to another at . Upon receiving the VR the API of the receiving device may query the header container to interpret the container information therein. Using the container information in the header the data values in the appended containers can be extracted .

In interpreting a received VR at the receiving device can determine whether the VR is a complete template or data only container. For a complete VR the receiving device can proceed to extract the data values therein as at . For a template VR the template may be stored with the associated template ID at the receiving device. For a data only VR the associated template can be retrieved and applied to the data only VR to obtain the complete VR from which the data values can be extracted as at . If the templates are stored at a device other than the receiving device such as the server the retrieval can include a call to that device for the template.

The implementation of the API and VR methods and systems may not be limited to particular hardware or software configurations and may find applicability in many environments wherein data may be exchanged between devices. The methods can be implemented in one or more computer programs executing on one or more programmable computers that include a processor such as first device second device and or other devices A a storage medium readable by the processor one or more input devices and one or more output devices. In some embodiments such as that shown in the methods and systems may be configured and implemented for use in a network. User control for the systems and methods may be provided through known user interfaces.

The methods and systems described herein are not limited to a particular hardware or software configuration and may find applicability in many computing or processing environments. The methods and systems can be implemented in hardware or software or a combination of hardware and software. The methods and systems can be implemented in one or more computer programs where a computer program can be understood to include one or more processor executable instructions. The computer program s can execute on one or more programmable processors and can be stored on one or more storage medium readable by the processor including volatile and non volatile memory and or storage elements one or more input devices and or one or more output devices. The processor thus can access one or more input devices to obtain input data and can access one or more output devices to communicate output data. The input and or output devices can include one or more of the following Random Access Memory RAM Redundant Array of Independent Disks RAID floppy drive CD DVD magnetic disk internal hard drive external hard drive memory stick or other storage device capable of being accessed by a processor as provided herein where such aforementioned examples are not exhaustive and are for illustration and not limitation.

The computer program s can be implemented using one or more high level procedural or object oriented programming languages to communicate with a computer system however the program s can be implemented in assembly or machine language if desired. The language can be compiled or interpreted.

As provided herein the processor s can thus be embedded in one or more devices that can be operated independently or together in a networked environment where the network can include for example a Local Area Network LAN wide area network WAN and or can include an intranet and or the internet and or another network. The network s can be wired or wireless or a combination thereof and can use one or more communications protocols to facilitate communications between the different processors. The processors can be configured for distributed processing and can utilize in some embodiments a client server model as needed. Accordingly the methods and systems can utilize multiple processors and or processor devices and the processor instructions can be divided amongst such single or multiple processor devices.

The device s or computer systems that integrate with the processor s can include for example a personal computer s workstation e.g. Sun HP personal digital assistant PDA handheld device such as cellular telephone laptop handheld or another device capable of being integrated with a processor s that can operate as provided herein. Accordingly the devices provided herein are not exhaustive and are provided for illustration and not limitation.

References to a microprocessor and a processor or the microprocessor and the processor can be understood to include one or more microprocessors that can communicate in a stand alone and or a distributed environment s and can thus can be configured to communicate via wired or wireless communications with other processors where such one or more processor can be configured to operate on one or more processor controlled devices that can be similar or different devices. Furthermore references to memory unless otherwise specified can include one or more processor readable and accessible memory elements and or components that can be internal to the processor controlled device external to the processor controlled device and can be accessed via a wired or wireless network using a variety of communications protocols and unless otherwise specified can be arranged to include a combination of external and internal memory devices where such memory can be contiguous and or partitioned based on the application. Accordingly references to a database can be understood to include one or more memory associations where such references can include commercially available database products e.g. SQL Informix Oracle and also proprietary databases and may also include other structures for associating memory such as links queues graphs trees with such structures provided for illustration and not limitation.

References to a network unless provided otherwise can include one or more intranets and or the internet. References herein to microprocessor instructions or microprocessor executable instructions in accordance with the above can be understood to include programmable hardware.

While the method and systems have been disclosed in connection with the illustrated embodiments various modifications and improvements thereon will become readily apparent to those skilled in the art. For example the module function calls container configurations data memory and or other components as may be described herein may be merely exemplary of the VR and API and can include one or more modules. Those with ordinary skill in the art will recognize that such functions configurations and or structures may be merely for illustrative purposes and can be varied in an internally consistent manner without departing from the scope of the disclosed methods and systems.

The aforementioned changes are also merely illustrative and not exhaustive and other changes can be implemented without affecting the ability of the API and VR to facilitate communication among first device second device and or other devices A. Accordingly many additional changes in the details and arrangement of parts herein described and illustrated can be made by those skilled in the art. It will thus be understood that the following claims are not to be limited to the embodiments disclosed herein can include practices otherwise than specifically described and are to be interpreted as broadly as allowed under the law.

