---

title: Method for creating a native application for mobile communications device in real-time
abstract: A software client () for executing an application on a mobile communications device, the software client () comprising: a receiver module () to receive a file containing mark up language to define the application; a parser () to parse the file in order to generate the application during run time to create a native application for the mobile communications device; a screen builder () to generate UI components for the native application by mapping procedures defined by the mark-up Language to native application programming interface (API) calls of the operating platform of the mobile communications device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08365203&OS=08365203&RS=08365203
owner: Willflow Limited
number: 08365203
owner_city: Shatin
owner_country: HK
publication_date: 20090320
---
The present application claims priority to U.S. Provisional Patent No. 61 038 241 filed Mar. 20 2008 the disclosure of which is incorporated herein by reference.

The invention concerns a method and system for creating a native application for a mobile communications device in real time.

It is difficult for most people to create cross platform mobile applications. Mobile communications devices operate on different platforms such as the Apple iPhone OS Window Mobile Symbian Palm S60 and Google Android. Each platform has its own programming language and requirements.

Traditionally creating a native application on a specific platform requires learning and writing a computer language specific to that platform. Consequently cross platform applications requires re writing the application for each platform and programmers with expertise in multiple programming languages. This is time consuming and expensive. Also as new platforms emerge authors of applications must familiarize themselves with the programming language of the new platform in addition to their knowledge of existing platforms.

Technologies such as Java create a platform independent virtual machine to assist with the deployment of applications to multiple platforms. However the user interface UI generated by Java applications are distinctively different from the native UI of the original platform. Firstly the Java UI is not aesthetically pleasing. Secondly the Java UI is slower than the native UI because the Java virtual machine acts as an additional layer between the Java program and the underlying native API operating system.

In a first preferred aspect there is provided a method for executing an application on a mobile communications device. The method includes parsing a file containing mark up language to define the application. The method also includes generating the application during run time to create a native application for the mobile communications device. The method also includes generating user interface UI components for the native application by mapping procedures defined by the mark up language to native application programming interface API calls of the operating platform of the mobile communications device.

The mark up language may be hypertext markup language HTML with extensions to the tag tag tag tag tag and tag.

The method may further include loading a start page by inserting a root universal resource locator URL link into the operation queue. The method may also include storing a subset of elements in the node structure. The method may also include traversing the elements in the node structure building a UI screen from the node structure using native UI components.

Data transfer between the software client and an external server may be mediated by an internal web server.

The internal web server may transfer the data communication between the software client and the external server without making any changes.

The internal server may be a fully functional backend that handles all the client requests such that the software client is able to function without being connected to the external server by allowing the internal web server to return cached files instead of fetching them from the external server.

An image node element may insert a load image operation into the operation queue such that the image is post loaded as the image is loaded only after other UIs have been constructed

An outward link node element may insert a load page operation into the operation queue such that the page is pre loaded as the page is loaded before the user sees it.

The method may further include handling navigation from a current screen to a next screen by inserting the link of the next screen into the operation queue and assigning it with the highest priority. The method may also include handling map and GPS interaction by inserting native controls above a map web view. The method may also include handling camera and file dialog by triggering a local camera and file dialog. If a user clicks on a link that leads away from the current page the operation queue is emptied and the current screen is loaded to the view stack.

In a second aspect there is provided a system for executing an application on a mobile communications device. The system includes a data source to supply a file containing mark up language to define the application. The system also includes a software client provided on a mobile communications device to receive and parse the file in order to generate the application during run time to create a native application for the mobile communications device and to generate user interface UI components for the native application by mapping procedures defined by the mark up language to native application programming interface API calls of the operating platform of the mobile communications device.

The system may further comprise a map to define relationships between the procedures and native API calls for a plurality of operating platforms for mobile communications devices the map being read by the software client when generating the application.

The system may further comprise a visual graphical user interface authoring tool to generate the file by visual manipulation of graphical components on a grid and to provide templates for common operations.

In a third aspect there is provided a software client for executing an application on a mobile communications device. The software client includes a receiver module to receive a file containing mark up language to define the application. The software client also includes a parser to parse the file in order to generate the application during run time to create a native application for the mobile communications device. The software client also includes a screen builder to generate UI components for the native application by mapping procedures defined by the mark up language to native application programming interface API calls of the operating platform of the mobile communications device.

Referring to the drawings a system for executing an application on a mobile communications device is provided. The system has a data source to supply a file containing mark up language to define the application. The system also has a software client provided on a mobile communications device to receive and parse the file in order to generate the application during run time to create a native application for the mobile communications device. Preferably the mobile communications device is a mobile phone using at least 2G for voice communication and with Internet access. The software client also generates user interface UI components for the native application by mapping procedures defined by the mark up language to native application programming interface API calls of the operating platform of the mobile communications device.

The system is an enabler which means that developers and authors can construct applications for mobile communications devices without requiring specific knowledge about each platform for every mobile communications device. Consequently authors can focus their effort on the application itself such as its functionality presentation and interaction with mobile phone users. It is hoped that better applications are developed because no time needs to be spent on learning and programming for every mobile platform. An author with some basic hypertext markup language HTML programming knowledge simply needs to build a website using HTML tags with some intuitive extensions. This leverages the author s familiarity with HTML tags to enable fast development of an application. Afterwards the author provides the URL of their website to a service provider. The service provider creates the application for the mobile platforms requested by the author.

The application for the mobile communications device is generated in real time rather than traditionally in compile time. Real time means if the server changes the HTML for example adding a search bar the change is reflected immediately in the application. This concept similar to a web browser but differs in that it is for an application which uses native user interface UI components instead of rendering standard HTML components in a web browser.

The software client called a Rosetta client is created for each mobile platform. A cross platform UI specification called the Rosetta HTML specification is provided that is used by all Rosetta clients and a Rosetta HTML file is received by a receiver and parsed by a parser . The Rosetta client generates the application using a screen builder . Based on the UI specification the Rosetta client generates the UI using the dynamic properties of the platform specific UI libraries and the native application programming interface API of the mobile platform. The UI components that can be built that are as simple as a button or as complex as a map camera or image editor.

Turning to the Rosetta client maintains the following data structures operation queue node structure database and view stack . All operations are performed by inserting themselves into the operation queue . The items in the operation queue can be prioritized change priority or removed at any time. After parsing a Rosetta HTML file the result is stored in the node structure which preferably is a tree. Each node of the node structure is mapped to a corresponding function of a platform specific software development kit SDK . Mapping may be performed by reading a map between the procedures of the Rosetta HTML specification and the native API of a specific mobile platform. The database is used for caching and accessing structural information. The current screen is always placed on the top of the view stack . The previous screen is hidden but not removed. Returning to the previous screen is done by popping the view stack . Progressing to the next screen is done by placing the screen on the top of the stack .

To execute the application on the mobile communications device the Rosetta client is started . Every application has a root URL. The root URL is inserted into the operation queue using a Load Root URL operation. depicts the operation of Load URL A into the operation queue . The operation queue maintains the sequence of operation for the Rosetta client . Next the UI generation process is started . The Rosetta client downloads retrieves the content from the root URL which is a Rosetta HTML file from an internal server or via the Internet. An example Rosetta HTML file is depicted in . Next the Rosetta client parses the HTML document to generate a HTML node tree as depicted in . shows an example of the node structure for the example Rosetta HTML file of . After obtaining the HTML node tree the Rosetta client starts to build the screen user interface using the native API provided by the platform specific SDK. An example of the building process is illustrated in where the procedures in the Rosetta HTML file are mapped to the native API of the Android platform. The operation queue is read when the screen is loaded. After building the screen post loading operations are added to the operation queue if they exist such as loading images. For example an image node inserts the Load Image operation into the operation queue . This means the image is post loaded because the image is only loaded after the UI has been constructed. This is depicted in . Another example is an outward link node which inserts the Load page operation into the operation queue. This means that the page is pre loaded because the page is loaded before the user sees it. The flow is modified such that after a1.html is pre fetched the user clicks on hello 1 and in this case a1.html does not need to load as it can be directly loaded from the cache in the database . depicts what occurs when a user clicks on the link hello 2 . The operation queue is cleared and Load URL a2.htmL is inserted in the operation queue . Also preloading operations such as loading HTML documents for a next screen are added to the operation queue . Next the operations of the operation queue are executed and the screen is created. Other pending operations in the operation queue are executed accordingly.

The operation queue can be preempted if the user interacts with the application and triggers another page such as clicking on a button. The current screen is pushed to the top of the view stack . The view stack maintains the navigation sequence so that users can easily and quickly go back to the previous screen. The operation queue of the current screen is cleared because of the loading of a new screen and the URL of the new screen is added to the operation queue . The UI generation is started again .

The data transfer between the Rosetta client and the external server is mediated by an internal web server . On the one hand the internal web server can be simple and it passes the communication between the client and external server without any changes. On the other hand the internal web server can be a fully functional backend that handles all the requests of the client . In such a case the Rosetta client can function without being connected to the external server and without Internet access availability . Caching is done by letting the internal web server return the cached files instead of fetching them from the external server .

The native API examples depicted in use the Android platform native API. The Rosetta client traverses the HTML node tree depicted in to construct the user interface screen. Firstly it obtains the title from the title node in the HTML node tree and sets the title to native program . For example the native API in Android platform for setting up the title is by calling the Activity typed instance with method setTitle i and pass the title to the activity.setTitle title method .

The body node is used to build the body part of the screen. For building the table node the Rosetta client builds the table UI component by using the native API such as LinearLayout class . tr node and td nodes are used to control the orientation of the LinearLayout . The a node is processed which has a URL of a1.html . The Rosetta client marks the row as focusable using native API View.setFocusable true and handles the click event action using native API by overriding the onClick method in View.OnClickListener interface .

The img node is processed which adds the loading image operation to the operation queue by using internal queue API in the native platform that is queue.add . The postloading image is displayed by using ImageView. Next the a1.html URL is added to the operation queue for prefetching operation. For processing a text node with text hello 1 the Rosetta client uses TextView native class to construct the text label with hello 1 text . The subtree of the second tr node is operated on similarly as the first tr node .

The system extends existing HTML language to facilitate easier and quicker understanding of how to develop applications using the system. The extended HTML attributes for presenting UI components on the mobile communications device are described in the tables below 

A native User Interface widget is used for rendering HTML on the mobile communications device. The User Interface widget is a special graphical user interface element to present data and interact with users. Different platforms call it different names for example control and view.

The tab will look different on different platforms because it depends on how a tab is typically constructed for a particular platform.

The toolbar will look different on different platforms because it depends on how a toolbar is typically constructed for a particular platform.

The native hardware software functionality is exposed by using pre defined phrase on hyperlink or HTML form input. The hyperlink and HTML form input are the methods to interact with servers in HTML.

A first example of native hardware software functionality is GPS. GPS is defined as wf gps . In this example the GPS location is submitted to a server 

To use GPS the author needs to define it by obtaining the GPS coordinate using the mobile communications device by writing wf gps in the Rosetta HTML file. The Rosetta client replaces wf gps with the GPS location for example 37.0625 95.677068.

A second example of native hardware software functionality is map parameters. Map parameters are defined as wf map center wf map zoom . In this example the map parameters are submitted to a server 

The Rosetta client replaces wf map center and wf map zoom with the center location and the zoom of the showing map respectively for example 37.0625 95.677068 is a screenshot of a map application together with it associated Rosetta HTML file.

Referring to the native hardware software functionality is exposed by using a special widget definition. A first example of native hardware software functionality is camera input. In HTML camera input is defined as 

To use the camera input the photo button is clicked. The camera screen is displayed. A photo is taken from the UI. The HTML form is submitted as a normal file input.

User may build their own online store and sell digital items such as ringtones and wallpapers. Combining with the native client it gives a seamless shopping experience. Another example is a contact application. Application may be created by integrating existing applications together. New applications can be created by customizing existing ones. For example another user can just download a contact application created earlier enrich it with a Date of birth and Address field and publish it as a new application. This may further speed up development time and reduce programming costs.

To help people without any programming knowledge create their own applications a visual graphical user interface GUI may be provided. Internet users can create applications that run on the web and natively on mobile communications devices. The user can create a model and view visually in one unified step. A What You See Is What You Get WYSIWYG interface creates the view and the model is generated automatically. Common operations as are generalized as templates. Common operations are generalized and presented as templates. When users choose different templates using the WYSIWYG interface they are actually choosing different controllers for their applications. All the views screens of an application are laid out on one consistent 2D grid. Typically it is difficult for a user to conceptualize an application in pure source code. All the views or screens of the application including the search screen and the form screens are placed on a 2D grid. The grid provides a single place to hold all the screens and it is also a map to allow the user to navigate through different screens when using the application.

To create an application using the visual authoring tool involves three main steps creating a form specifying the layout of the form s and specify the index of the application for searching purposes. The user creates the form to store his data. In database terminology a form corresponds to a record. The user specifies the layout of the forms which determines how should people browse through them. The user can pick different templates for the layout by answering how they will group the forms into columns and how the forms in a column should be sorted. The grouping and sorting are based on picking the fields created earlier. The last step in creating the application is to specify the index of the application that allows people to search the forms.

It will be appreciated by persons skilled in the art that numerous variations and or modifications may be made to the invention as shown in the specific embodiments without departing from the scope or spirit of the invention as broadly described. The present embodiments are therefore to be considered in all respects illustrative and not restrictive.

