---

title: Compositional modeling of integrated systems using event-based legacy applications
abstract: The compositional event based modeling of integrated applications (CINEMA) tool provides a way to extend a modeling environment using legacy event based applications, such as Graphical User Interface (GUI) APplications (GAPs). CINEMA allows modelers to extend the toolbox of the modeling environment by creating modeling elements that represent GUI objects of GAPs. CINEMA generates source code that allows an integrated system to control and manipulate the GUI objects of GAPs represented by the modeling elements used to create a model of the integrated system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08479150&OS=08479150&RS=08479150
owner: Accenture Global Services Limited
number: 08479150
owner_city: Dublin
owner_country: IE
publication_date: 20090813
---
This disclosure relates to a tool for extending a modeling environment using legacy event based applications. In particular this disclosure relates to a tool that allows modelers to create modeling elements for a modeling environment toolbox from Graphical User Interface GUI APplications GAPs and generate source code to control and manipulate GUI objects of the GAPs represented by the modeling elements.

Integrated systems are composed of components that exchange information also referred to as interoperating components. Components of integrated systems may include different legacy event based applications such as Graphical User Interface GUI APplications GAPs . Organizations use legacy GAPs to assist business operations to automate business processes for example increasing the speed and effectiveness of information exchange.

Organizations find reengineering GAPs into programming components difficult because of brittle legacy architectures poor documentation significant programming effort and subsequently the large cost of these projects. Because businesses use successful GAPs for decades managers are reluctant to authorize changes to source code that may break GAPs and disrupt well established business services. Many organizations explore how to include legacy GAPs in new integrated systems in order to improve business processes by increasing interoperability of GAPs with new components such as web services.

Organizations often rely on modelers to develop models of new integrated systems. Modelers may use a unified modeling language UML diagramming application e.g. the ArgoUML application that provides a set of graphical notation techniques to create models that describe a new integrated system. However modelers find modeling new integrated systems that include GAPs difficult because many GAPs are closed and monolithic and do not expose any programming interfaces or data in known formats. Although modelers desire to use GAPs as components in integrated systems modelers find capturing the functionality and interfaces of GAPs as elements of UML based models e.g. classes and interfaces difficult. Modelers find capturing properties of and dependencies between GUI objects a difficult exercise because GUI models are often unavailable for legacy applications.

Currently modelers use a manual laborious and error prone process to study GAPs and translate GUI objects into elements of UML as abstractions of the functionalities of these GAPs. Modelers find using GAPs in modeling environments difficult since many legacy GAPs do not expose any programming interfaces. Modelers find capturing properties of and dependencies between GUI objects a difficult exercise because GUI models are often not available for legacy applications.

Theoretically GUI models can be extracted from the source code of GAPs however two fundamental limitations exist. First the source code of GAPs often may be unavailable. For example modeling may be outsourced to external organizations to who the source code of legacy applications may not be shared. Thus the external organizations do not have the ability to derive precise GUI models from source code. Second even if the external organization possesses or has access to the source code limitations that render approaches of deriving GUI models from source code ineffective exist. For example the Microsoft Windows Application Programming Interface API call CreateWindow used in a large number of GAPs takes a number of parameter variables including a string variable that holds the value of the type of a GUI object which often may be known only at runtime.

In addition deriving models from the source code of GAPs depends on knowing the precise semantics of API calls that create and manipulate GUI objects e.g. CreateWindow building appropriate parsers and analyzers for languages used to create GUI applications and developing Integration Development Environment IDE specific tools that extract GUI models from IDE GUI resource repositories. The number of tuples measures in terms of tens of thousands in the Cartesian product of API calls programming languages IDEs increasing the difficulty of identifying an approach that would work with source codebases of different GUI applications.

A fundamental limitation of using GUI objects in UML models is that GUI objects are not programming objects that can be modeled using standard elements of UML. GUI objects are created within corresponding GAPs using the underlying GUI frameworks and the GUI objects are not part of any modeling environment. Some GUI objects require users to perform multiple actions on GAPs before the GUI objects are instantiated. Without embedding these actions in UML elements modelers find creating UML models that can be transformed into source code that uses these GUI objects difficult.

GAPs are written in many different languages and run on many different platforms. Many platform and language specific techniques for extracting data from GAPs exist. However implementing these specific techniques in tools for different modeling platforms and languages results in multiple versions of the source code for the respective tools increased costs to maintain the tools and difficulties in maintaining and evolving different codebases.

Finally modelers find generating source code from UML models that include elements describing GUI objects difficult. Classes that represent GUI objects should contain code that accesses and manipulates these GUI objects since these GUI objects are created dynamically in the GAPs processes and the contexts of the underlying GUI frameworks e.g. MS Windows or Java SWT standard widget tool kit . Since models do not reflect the contexts in which GUI objects exist modelers find maintaining and evolving these models with respective GAPs difficult.

None of the techniques noted about are sufficiently uniform non invasive and efficient. Therefore a need exists to address the problems noted above and other problems previously experienced.

ComposItioNal Event based Modeling of integrated Applications CINEMA efficiently and non invasively extends a UML modeling environment by defining modeling elements for the functionalities of GAPs and GUI objects of GAPs. CINEMA allows a user to model integrated systems that include legacy GAPs by navigating to GUI objects selecting the GUI objects and dragging and dropping the GUI objects onto a modeling canvas in order to create models. Because of the wide applicability of CINEMA CINEMA uses a language neutral underlying technology common to major computing platforms for controlling and manipulating GAPs. CINEMA disentangles UML modeling environments from GUI structures and hides connections between models and GAPs within CINEMA. CINEMA 1 facilitates users to create models of integrated systems using GAPs 2 captures the structures and states during user s interactions with the GAP and 3 specifies the type and the name of GUI objects used in models and subsequently deployed in a resulting integrated system.

CINEMA may be used for data integration GAP reuse collaborative computing and application migration to new platforms. Using CINEMA modelers expend minimal development efforts to model integrated systems. CINEMA offers for example an attractive alternative to rewriting legacy applications by simply reusing the legacy applications in integrated systems. CINEMA provides an efficient and non invasive way to allow engineers to use existing GAPs to create composite models that CINEMA uses to extend the modeling environment. CINEMA combines a nonstandard use of accessibility technologies for accessing and controlling GAPs. CINEMA extends a UML modeling environment and allows modelers to create models of integrated systems using the features of GAPs. CINEMA reverses standard modeling direction from requirements to applications e.g. GAPs to requirements by allowing engineers to use existing GAPs from which to create composite models.

CINEMA allows a user e.g. modeler to model GAPs as programming objects and GUI objects of these GAPs as fields of these programming objects and perform actions on these programming objects by invoking methods on the programming objects. Unfortunately integrated systems and modeling environments IS MEs may not access and manipulate GUI objects as pure programming objects because GUI objects only support user level interactions. Accessibility technologies expose a special interface whose methods can be invoked and the values of whose fields can be set and retrieved to control the GUI objects.

CINEMA combines a nonstandard use of accessibility technologies in order to access and control GAPs in a uniform way. CINEMA uses a visualization mechanism that enables users to create models of integrated systems composing GUI objects of GAPs by performing point and click and drag and drop operations on GAPs. CINEMA uses an accessibility layer and hooks to inject event listeners into GAPs. The event listeners respond to events that CINEMA records in order to create modeling elements that extend a UML modeling environment e.g. Eclipse software released under the Eclipse Public License EPL 1.0 open source license .

Accessibility technologies provide different aids to disabled computer users. Some of the aids provided by accessibility technologies include screen readers for the visually impaired visual indicators or captions for users with hearing loss and software to compensate for motion disabilities. Most computing platforms include accessibility technologies since electronic and information technology products and services are required to meet the Electronic and Information Accessibility Standards. For example Microsoft Active Accessibility MSAA technology is designed to improve the way accessibility aids work with applications running on MS Windows and Sun Microsystems Accessibility technology assists disabled users who run software on top of the Java Virtual Machine JVM . Accessibility technologies are incorporated into computing platforms as well as libraries and applications in order to expose information about user interface elements. Accessibility technologies provide a wealth of sophisticated services required to retrieve attributes of GUI objects set and retrieve values for the GUI objects and generate and intercept different events. For example MSAA for Windows may be used although using a different accessibility technology will yield similar results. Although no standard for accessibility Application Programming Interface API calls exists different technologies offer similar API calls suggesting a slow convergence towards a common programming standard for accessibility technologies. Accessibility technologies exploit the fact that GUI objects expose a well known interface that exports methods for accessing and manipulating the properties and the behavior of these objects. For example a MS Windows GUI object that implements the IAccessible interface allows the GUI object to be accessed and controlled using MSAA API calls. Accessibility technologies allow programmers to write code to access and control GUI objects as standard programming objects. Using accessibility technologies programmers can also register callback functions for different events produced by GUI objects thereby obtaining timely information about states of the GUI objects. For example if a GUI object receives an incorrect input and the GAP shows an error message dialog informing the user about the mistake then a previously registered callback can intercept the event that signals the creation of the error message dialog dismiss the event and send an illegal input message to the tool and or programming instructions that control the GAP.

Hooks are user defined libraries that contain callback functions or simply callbacks which are written in accordance with certain rules dictated by accessibility technologies. When a target GAP is started the accessibility layer loads predefined hook libraries in the process space of the GAP and registers addresses of callbacks that may be invoked in response to specified events. Since hooks live in the process spaces of GAPs the hooks callbacks can affect every aspect of execution of these GAPs. Hooks enable users to extend the functionality of GAPs specifically to integrate hooks with GAPs without changing the source code of the GAP. Writing hooks does not require any knowledge about the source code of GAPs. A hook library may be generic for all GAPs. A hook is injected into a GAP listens to events generated by the GAP and executes instructions received from integrated systems. As an example instruction a hook may disable a button until a certain event occurs. Hook libraries allow programmers to change the functionalities of existing GAPs without modifying the source code of the GAPs. The functions of a generic hook include receiving commands to perform actions on GUI objects reporting events that occur within GAPs and invoking predefined functions in response to certain commands and events.

Some of the concepts presented above may be described in more detail in the following U.S. patent applications including Ser. No. 11 710 681 Publication Number 2008 0209356 entitled Graphical Unit Interface Based Application to Web Services Conversion System to Mark Grechanik et al. filed on Feb. 23 2007 Ser. No. 11 710 233 Publication Number 2008 0209348 entitled Composing Integrated Systems Using GUI Based Applications and Web Services to Mark Grechanik et al. filed on Feb. 23 2007 Ser. No. 11 710 680 Publication Number 2008 0209446 entitled Design Tool for Converting Legacy Applications to Web Services to Mark Grechanik et al. filed on Feb. 23 2007 Ser. No. 11 888 970 Publication Number 2009 0037896 entitled Legacy Application Decommissioning Framework to Mark Grechanik et al. filed on Aug. 2 2007 Ser. No. 11 824 373 Publication Number 2009 0007066 entitled Refactoring Monolithic Applications into Dynamically Reconfigurable Applications to Mark Grechanik et al. filed on Jun. 29 2007 the entire disclosure of each of these U.S. patent applications of which are hereby incorporated by reference.

CINEMA enables modelers to create models of integrated systems that employ legacy GAPs using a high degree of automation. Models created using CINEMA may represent integrated systems capable of providing functionality in large scale distributed enterprise environments that orchestrate different GAPs located on different computers and running on different platforms e.g. operating systems and system configurations . CINEMA provides a non invasive way to create models and generate source code to control GAPS. CINEMA allows modelers to create models using GUI objects with only a basic knowledge of how to interact with GAPs in order to accomplish business tasks. CINEMA allows modelers to create models using GUI objects without writing code for the models knowledge of the source code of components parsing any source code and without writing complicated code to change program executables.

Other systems methods features and advantages will be or will become apparent to one with skill in the art upon examination of the figures and detailed description. All such additional systems methods features and advantages are included within this description are within the scope of the claimed subject matter and are protected by the following claims.

The memory stores compositional event based modeling CINEMA instructions that when executed by the processor cause the processor to receive through the user interface a graphical user interface GUI object definition of a GUI object of an external GUI application GAP . The user selects the GUI object from the external GAP . The GUI object definition includes a GUI object properties set .

In one implementation CINEMA may invoke the external GAPs . The external GAPs are separate from CINEMA . In other words the external GAPs may run without CINEMA running and or without CINEMA invoking the external GAPs . In one implementation external GAPs run in a separate process space and shares no variables with CINEMA . In another implementation external GAPs run in the process space of CINEMA when CINEMA invokes the external GAPs . In still another implementation the user may configure CINEMA to operate with external GAPs running in one of three isolation modes including a low isolation medium isolation and high isolation mode. In the low isolation mode an external GAP runs in the same process space as CINEMA when CINEMA invokes the external GAPs . In the medium mode multiple GAPs run in one process space while CINEMA runs in a separate process space. In the high isolation mode each of the multiple GAPs run in separate process spaces and CINEMA runs in still another separate process space. The user may select the isolation mode based on the system computing resources available to the CINEMA system configuration and or the particular GAPs the user desires to use for modeling.

CINEMA includes a modeling element palette that includes an existing modeling element and a modeling canvas . CINEMA allows the user to create in the modeling element palette a new modeling element from the GUI object definition by generating a modeling element class for the GUI object to obtain the new modeling element . CINEMA generates the modeling element class by defining an action performed by the GUI object a modeling element type a data type and a function performed by a method of the GUI object . In one implementation the user defines the action element type data type and function for the modeling element class for the new modeling element . In one implementation CINEMA generates the new modeling element by transcoding the GUI object definition to obtain a modeling element representation for the GUI modeling element.

CINEMA generates code that mimics a human driven procedure of interacting with the GAPs referred to as transcoding. CINEMA transcodes the GUI object properties set into transcoded GUI object instructions e.g. programming instructions that a resulting integrated system and or composite integrated system e.g. and may execute to control and manipulate GUI objects of GAPs . In one implementation the compositional event based modeling instructions cause the processor to transcode the GUI object properties set to obtain transcoded GUI object instructions configured to locate manipulate and control the GUI object . CINEMA may also generate exception handling code that handles exceptions that may be thrown while controlling GAPs e.g. showing a message box informing users about incorrectly formatted input . The compositional event based modeling instructions may further cause the processor to bind the transcoded GUI object instructions to obtain processor executable model instructions that cause the processor to manipulate the GUI object according to a model created using the new modeling element .

Referring briefly to the GUI object properties set includes a GUI object access method that determines how to access the GUI object and GUI object navigation information that captures how to navigate to the GUI object in the GAP . The GUI object properties set further includes GUI object identifier information geometry information access rights read and write constraints input parameters transient values and return parameters . In one implementation CINEMA transcodes the GUI object properties set in order to create the new modeling element and generates programming instructions e.g. transcoded GUI object instructions for an integrated system and or composite integrated system e.g. and to use to control and manipulate GAPs and other components e.g. web services and other GAPs discussed in detail below.

Returning to the GUI object properties set provides CINEMA information about the structure of the GAP and the GUI object using accessibility enabled interfaces e.g. accessibility API calls that CINEMA records while the user interacts e.g. user interactions with the GAP GUI object and the sequence of GUI screens of the GAP . In one implementation CINEMA uses the accessibility API calls and hooks e.g. event listeners in GAPs to receive the GUI object properties set . The hooks respond to events that CINEMA captures as the GUI object properties set . Discussed in further detail below CINEMA may use the GUI object properties set to generate source code e.g. model instructions of a chosen programming language e.g. language selection from the model and compile and execute the source code e.g. model instructions . CINEMA may generate exception handling code that handles exceptions that may be thrown while controlling GAPs e.g. showing a message box informing users about incorrectly formatted input using the model instructions .

Table 1 shows how CINEMA in one implementation creates a GUI object class e.g. new modeling element for a GUI object .

Table 2 shows an example of how CINEMA in one implementation captures operations e.g. functions and or methods for a new modeling element for a GUI object . CINEMA identifies the GAP e.g. state machine and GUI object from which the user captures operations for a new modeling element e.g. referred to as className in Table 2 and Table 3 below . The user performs actions on the GUI object in order to capture the operations e.g. functions and or methods for the new modeling element . The user drags and drops the GUI object onto the modeling canvas and CINEMA creates the new modeling element in the modeling palette .

Under the GUI object state activated the GUI object may be visible and available for user interactions. The GUI object may transition e.g. and between the GUI object states deactivated and activated an indefinite number of times during the lifetime of the GUI object . For example going back and forth between multiple screens e.g. in a GAP hides deactivates one screen containing GUI objects and activates another screen. Switching between the GUI object states deactivated and activated may not change the values that the GUI object holds. Even so a user may not act on the GUI object in the GUI object state deactivated . The GUI object state may transition e.g. and to destroyed for example when the GAP stops. CINEMA receives and or captures actions e.g. the operations and transition states that describe the states of the GAP in order to determine how the new modeling element may be used in a model .

Referring briefly to the user may model a particular screen for the model by selecting a corresponding screen tab in the CINEMA UI . CINEMA UI displays the modeling canvas that corresponds to the screen the user desires to design for the model . The user may specify the functions that each GUI object performs in the model . For example the user may specify which GUI objects e.g. and receive values and or serve as inputs and which GUI objects produce output results e.g. and . Using CINEMA a user creates a model using the modeling elements e.g. and by dragging and dropping the modeling elements e.g. and onto the modeling canvas . shows a diagrammatic representation of the new modeling elements e.g. and as object classes e.g. and respectively . The user connects the modeling elements e.g. object classes and using connectors e.g. that specify dependencies between the modeling elements e.g. object classes . When the user completes the model the user may generate model instructions that cause the processor to manipulate the GUI object according to a model created using the new modeling element .

CINEMA generates code that mimics a human driven procedure of interacting with the GAPs referred to as transcoding. In one implementation compositional event based modeling instructions use the GUI object properties set the modeling element class and modeling dependencies to transcode the new modeling element into programming instructions e.g. transcoded GUI object instructions . An integrated system and or composite integrated system e.g. and may execute the transcoded GUI object instructions to locate control and manipulate GUI objects of GAPs .

CINEMA records the states of a GAP using the hook listener e.g. proxy and dispatcher . GAPs may be represented by a tree structure that includes GUI screens and GUI objects within each GUI screen along with the attributes of each GUI screen and GUI object and GUI object functions e.g. methods . CINEMA traverses the GUI tree of the GAP post order using accessibility technology in order to capture the GUI object properties set . For each node of the GUI tree of the GAP CINEMA emits code for a GUI object class e.g. and for a GUI object . A user may retrieve data from and enter data into the GUI objects of the GAP . The user may initiate transitions e.g. GUI object state changes by causing some actions e.g. select a menu item or click on a button . A GAP may perform some computations based on the user s actions and present different GUI screens . The user may continue the cycle until the user has allowed CINEMA to capture all the desired actions of the GAP .

Table 3 shows a declaration of a transcoded GUI object class e.g. and for a GUI object . CINEMA links generated GUI object classes e.g. and to GUI objects . The transcoded GUI object instructions may include a GUI object class declaration as shown in Table 3. The GUI object class declaration includes methods for locating the given GUI object in the GAP setting and getting the values for the GUI object and performing an action on the GUI object . GUI objects include semantically meaningful types of the data that users use to model the GUI objects as new modeling elements e.g. and . CINEMA allows users to type GUI objects and bind names to the GUI objects . Using CINEMA a user captures the properties of GUI objects and assigns names and types to the GUI objects . For example a user may assign different names but the same type to different GUI objects that hold values of the same semantic concept e.g. addresses or credit card numbers even though the GUI objects may be hosted by different GAPs .

When a GAP starts the operating system assigns a positive integer number to each window e.g. a particular GUI object that identifies the order number in which a GUI object takes focus when navigating through GUI screens . The GUI order number is represented by the private variable ElementId which is initialized with a negative number shown in line 2 of Table 3 . The private method Locate takes the process identifier of the GAP as a parameter and retrieves the ElementId for a given GUI object for the GAP shown in line 3 of Table 3 . When CINEMA emits the code for the Locate method CINEMA uses the accessibility API functions to obtain information e.g. the GUI object properties set about GUI objects in the GUI tree that lie in the path to the given GUI object . When CINEMA executes the method Locate in the constructor shown in lines 4 5 of Table 3 the method Locate uses the location information e.g. the GUI object properties set to navigate to the GUI object and obtain the GUI object s identifier which CINEMA uses in methods setValue getValue and Dolt shown in lines 6 7 and 8 of Table 3 to access the GUI object .

Methods setValue and getValue shown in lines 6 and 7 of Table 3 set and retrieve values of GUI objects . By default the type of the data is string unless the user specifies the type as integer or float. The code for setValue and getValue methods uses the accessibility API functions with the ElementId to locate the GUI object in the GUI screen and set or retrieve the value of the GUI object . The method Dolt shown in line 8 of Table 3 takes an argument that specifies an action taken relating to the GUI object and where the argument for the method Dolt is null a default action provided by the accessibility API function is executed. CINEMA generates exception handling code that handles exceptions that may be thrown while controlling GAPs e.g. showing a message box informing users about incorrectly formatted input using the methods.

In one implementation when the user completes the design of the model the user generates the model instructions by selecting the generate model source selection on the CINEMA UI . CINEMA may prompt the user to select a source code language to use in order to generate source code of a chosen language from the model and compile and execute the source code .

CINEMA binds the transcoded GUI object instructions to obtain the processor executable model instructions that an integrated system e.g. and and or composite integrated system may execute to locate control and manipulate the GUI objects . Binding GUI object classes e.g. transcoded GUI object instructions to instances of the GUI objects using the operator new is a straightforward procedure in modern Object Oriented languages such as Java . However the semantics of the new operation is complicated when the operation involves GUI objects created by GAPs. From the modeler s e.g. user perspective GUI objects appear asynchronously and GAPs change the states of the GUI objects as a result of internal computations. Although a user may not specify how to manage the lifecycle of GUI objects using an integrated system a user may use CINEMA to deploy GUI objects as programming objects e.g. transcoded GUI object instructions in the source code of integrated systems and or composite integration systems e.g. and .

CINEMA defines bindings between programming objects e.g. transcoded GUI object instructions in models and GUI objects . Recall that GUI objects exist within the contexts of corresponding GAPs and programming objects e.g. a modeling element GUI object class and in models represent corresponding GUI objects . CINEMA serves as a connector between models and GAPs that enables the programming objects to bind to respective GUI objects . Using CINEMA the lifecycle of a programming object may be tightly linked to the lifecycle of a GUI object to which the programming object represents. However some operations do not make sense when performed on programming objects e.g. using the operator new to create objects. Thus bindings between programming objects e.g. transcoded GUI object instructions and GUI objects determine what operations may be performed on programming objects so that the programming objects do not throw runtime exceptions.

The GUI Object Instantiation Time indicates at what point in the execution of a GAP the GAP instantiates a GUI object hosted by the GAP . The GUI Object Instantiation Time identifies three time frames including past current and future . A GUI object may be instantiated in the past which indicates that the GUI object was previously available to users to perform actions on the GUI object up to some point during the execution of the GAP . A currently available e.g. current GUI object allows users to perform different actions and some GUI object may be instantiated at some point in the future . A user may find predicting the values held by a GUI object instantiated in future difficult. CINEMA allows the user to set the values of a GUI object using programming object counterparts so that when the GAP instantiates the GUI object the values of the GUI object may be set.

Three types of bindings may be used including active passive and static . The active binding between a GUI object and programming object indicates the GUI object is activated e.g. on a GUI screen . In contrast the passive binding indicates the GUI object is in a deactivated state e.g. . The static binding indicates the GUI object may be considered a static variable such as in Java . A static variable is activated when the variable s scope is reentered. In some situations a GUI object exists on a screen that is overshadowed by another screen e.g. layers in web browsers and even though the GUI object is not accessible by a user operations may be performed on the GUI object . In such situations the binding for the GUI object may be considered static rather than passive.

Operations for three combinations of instantiation time and binding specifiers are prohibited including past and active current and passive and future and active . The symbol X e.g. and indicates prohibited operations for particular combinations of instantiation time and binding specifiers. A GUI object cannot have an active binding when the GUI object was instantiated in the past . Similarly a GUI object instantiated at some point in time in future may not have an active binding. A GUI object that is currently available e.g. cannot be considered passive .

Three types of operations may be performed on a GUI object including reading values from writing values into and invoking methods e.g. actions operations and or functions on the GUI object . For a GUI object instantiated in the past with the passive bindings only the operation of reading the values of the GUI object may be performed. When a GUI object is deactivated the values of the GUI object are retrieved and stored so that the values of the GUI object may be retrieved at a later time. For a GUI object instantiated in the future with the passive binding only the operation of writing values to the GUI object may be performed. In other words the values of the GUI object may be set even if the GUI object is not yet instantiated by a GAP . The set value for the GUI object may be stored so that when the GUI object is created and activated the GUI object s value will be set.

The measurements refer to one example implementation of CINEMA that included Windows XP Pro on a computer with Intel Pentium IV 3.2 GHz CPU and 2 GB of RAM. The GAP name state no. column lists the names of the GAPs e.g. and the comma separated GAP state identifier that is the sequence number of the GUI screens . The visible invisible and used columns e.g. and shown under the number of GUI elements indicate the number of visible and invisible GUI elements e.g. GUI objects and the number of GUI elements including the parents of the GUI elements in the hierarchy that were used as parameters and or action targets in web services. The state XML bytes column illustrates the size of the XML generated by CINEMA to describe the given state of the GAP . The time sec column illustrates the amount of time taken to generate and parse the state XML.

The effort required to create web services using CINEMA was compared with the programming effort to create the same service by using the source code of GAPs . An application was built with accounting functionality. Using approximately nine hours to create and test the accounting GAP. Then a web service was created using Microsoft Visual Studio 2005 which has the state of the art support for automating tasks for building web services. Within approximately one hour the user extracted the code from the accounting GAP moved the code to the web service project and compiled and debugged the code using the Studio. In contrast to the above scenarios using CINEMA a user spent less than ten minutes to generate a web service.

Alternatives to CINEMA include the UniFrame framework is a framework for building integrated systems by assembling pre developed heterogeneous and distributed software components. The glue wrapper code that realizes the interoperation among distributed and heterogeneous software components can be generated from a descriptive model. However the UniFrame framework requires users to write code for models and possess the knowledge of the source code of components.

In another approach a web browser shell approach a modeler may use a web browser shell that integrates a command interpreter into the browser s location box to automate HTML interfaces. A browser shell wraps legacy CLPs with an HTML CGI graphical interface. The web browser shell approach depends heavily upon parsing HTML and extracting data from the command line input output.

Code patching and binary rewriting techniques modify the binary code of executable programs in order to control and manipulate them when integrating these programs into composite systems. However code patching and binary rewriting techniques are platform dependent and require programmers to write complicated code to change program executables. Programmers find using code patching and binary rewriting techniques difficult and error prone and often cause applications to become unstable and crash.

Extracting information from GAPs and GUI elements using the various other unworkable techniques may be referred to as screen scraping. Macro recorders use this technique by recording the user s mouse movements and keystrokes then playing them back by inserting simulated mouse and keyboard events in the system queue.

The logic circuitry and processing described above may be encoded or stored in a machine readable or computer readable medium such as a compact disc read only memory CDROM magnetic or optical disk flash memory random access memory RAM or read only memory ROM erasable programmable read only memory EPROM or other machine readable medium as for examples instructions for execution by a processor controller or other processing device. The medium may be implemented as any device that contains stores communicates propagates or transports executable instructions for use by or in connection with an instruction executable system apparatus or device. Alternatively or additionally the logic may be implemented as analog or digital logic using hardware such as one or more integrated circuits or one or more processors executing instructions or in software in an application programming interface API or in a Dynamic Link Library DLL functions available in a shared memory or defined as local or remote procedure calls or as a combination of hardware and software.

In other implementations the logic may be represented in a signal or a propagated signal medium. For example the instructions that implement the logic of any given program may take the form of an electronic magnetic optical electromagnetic infrared or other type of signal. The systems described above may receive such a signal at a communication interface such as an optical fiber interface antenna or other analog or digital signal interface recover the instructions from the signal store them in a machine readable memory and or execute them with a processor.

The systems may include additional or different logic and may be implemented in many different ways. A processor may be implemented as a controller microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other types of circuits or logic. Similarly memories may be DRAM SRAM Flash or other types of memory. Parameters e.g. conditions and thresholds and other data structures may be separately stored and managed may be incorporated into a single memory or database or may be logically and physically organized in many different ways. Programs and instructions may be parts of a single program separate programs or distributed across several memories and processors.

