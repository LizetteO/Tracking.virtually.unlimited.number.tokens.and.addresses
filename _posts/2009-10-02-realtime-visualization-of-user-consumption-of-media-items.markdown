---

title: Real-time visualization of user consumption of media items
abstract: A computer implemented method for displaying real-time computer mediated user consumption data, comprising: accessing consumption data corresponding to real-time computer mediated user consumption behavior; parsing the consumption data to identify one or more events comprising one or more instances of consumption data and wherein each event is associated with a user; adding the events to an event stack comprising a predetermined stack limit; and storing the consumption data for each event in a data structure configured to correlate related consumption data and provide a temporal context to the stored consumption data wherein addition of graphical symbols to a visualization display is responsive to the arrangement of the consumption data in the data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08332406&OS=08332406&RS=08332406
owner: Apple Inc.
number: 08332406
owner_city: Cupertino
owner_country: US
publication_date: 20091002
---
This application claims the benefit of U.S. Provisional Application Ser. No. 61 102 199 filed Oct. 2 2008 which is incorporated by reference in its entirety herein.

A portion of the present disclosure is contained in a computer program listing in Appendix A. The contents of the Appendix A are incorporated herein by reference.

The contents of this file are subject to copyright protection. The copyright owner has no objection to the reproduction by anyone of the patent document or the appendix as it appears in the Patent and Trademark Office patent files or records but does not waive any other copyrights by virtue of this patent application.

 2008 2009 Strands Inc. A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. 37 CFR 1.71 d .

The present disclosed technology relates to systems for tracking user consumption and more particularly to methods for tracking and visualizing real time computer mediated user consumption.

Computer mediated social networking systems provide users with access to network forums for sharing and accessing information about products and services used by others in the network. This information can be gathered and made accessible to users in the network in various ways.

Briefly disclosed herein is a system for visualizing in real time computer mediated user consumption of products and services. The system is configured to display information about products and services in such a way as to show connections between users and the products and services they consume. The system provides insight into how products and services are related while providing a temporal context for such information.

For clarity the embodiments described herein relate to a system for visualizing real time user access and consumption of media files containing music video and or other electronic media referred to hereinafter as media items. However the embodiments provided herein are for illustrative purposes only and claimed subject matter is not limited to the embodiments described. For instance the disclosed system and associated devices may also model and or display real time visualization of user consumption of other goods and or services. The consumable in such other embodiments may be participation in online games online purchases of consumer products social networking activities news feeds and or buying selling financial instruments online and claimed subject matter is not limited in this regard.

The embodiments described herein relate to a system comprising a computer display visualization tool hereinafter referred to as an applet. The applet implements real time consumption data management and real time visualization of user media item consumption activity. In one embodiment the system accesses user media item consumption data from one or more databases via an Application Programming Interface API parses and stores the consumption data in data structures. The consumption data management system and method of storing the consumption data in the data structures is configured to reveal associations between consumers consumed products and or services or combinations thereof. The applet displays a visualization of the media item consumption data by accessing the data structures and displaying the stored consumption data to show associations between media items users and or consumption events or combinations thereof.

In one embodiment the applet parses the media item consumption data extracts artist information and renders artists as nodes in the visualization display. The visualization of music media consumption appears as graphical representations of the music artists preferably using currently available album art. The nodes are rendered using a force directed placement algorithm which spreads them out to avoid overlapping. The nodes are also configured such that a user may click and drag the nodes to change their position in the applet window. In one embodiment information about the artist song and or the user who listened to the song is available by hovering a cursor over the artist node.

In addition to the spreading behavior of the artist nodes the nodes also attract one another if they are determined to be correlated such as when two artists tracks co occur in a given user s playstream. This attraction behavior may cluster associated nodes together in the display and make associations between nodes more clear. Additionally an association between nodes is indicated with a line connecting the two nodes. Thus attraction between associated nodes serves to minimize connector line overlap in the display.

These and other features and advantages will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

The disclosed technology in some embodiments may be implemented by a digital computing system. By the term digital computing system we mean any system that includes at least one digital processor and associated memory wherein the digital processor can execute instructions or code stored in that memory. The memory may store data as well. A digital processor includes but is not limited to a microprocessor multi core processor DSP digital signal processor vocoder processor array network processor etc. A digital processor may be part of a larger device such as a laptop or desktop computer a PDA cell phone iPhone PDA Blackberry PDA phone or indeed virtually any electronic device.

The associated memory further explained below may be integrated together with the processor for example RAM or FLASH memory disposed within an integrated circuit microprocessor or the like. In other examples the memory comprises an independent device such as an external disk drive storage array or portable FLASH key fob. In such cases the memory becomes associated with the digital processor when the two are operatively coupled together or in communication with each other for example by an I O port network connection etc. such that the processor can read a file stored on the memory. Associated memory may be read only by design ROM or by virtue of permission settings or not. Other examples include but are not limited to WORM EPROM EEPROM FLASH etc. Those technologies often are implemented in solid state semiconductor devices. Other memories may comprise moving parts such a conventional rotating disk drive. All such memories are machine readable in that they are readable by a suitable digital processor as further explained below for the benefit of the USPTO.

As explained above the present disclosed technology preferably is implemented or embodied in computer software also known as a computer program or code we use these terms interchangeably . Programs or code are most useful when stored in a digital memory that can be read by a digital processor. We use the term computer readable storage medium or alternatively machine readable storage medium to include all of the foregoing types of memory as well as new technologies that may arise in the future as long as they are capable of storing digital information in the nature of a computer program or other data at least temporarily in such a manner that the stored information can be read by an appropriate digital processor. By the term computer readable we do not intend to limit the phrase to the historical usage of computer to imply a complete mainframe mini computer desktop or even laptop computer. Rather we use the term to mean that the storage medium is readable by a digital processor or any digital computing system. Such media may be any available media that is locally and or remotely accessible by a computer or processor and it includes both volatile and non volatile media removable and non removable media.

Where a program has been stored in a computer readable storage medium we may refer to that storage medium as a computer program product. For example a portable digital storage medium may be used as a convenient means to store and transport deliver buy sell license a computer program. This was often done in the past for retail point of sale delivery of packaged shrink wrapped programs. Examples of such storage media include without limitation CD ROM and the like. Such a CD ROM containing a stored computer program is an example of a computer program product.

In one embodiment the real time user consumption network visualization may be implemented on a computer as a ShockWave Flash SWF applet using Javascript Personal Home Page PHP or other appropriate web technologies. In another embodiment it may be written in a language called haXe. HaXe is a web based language that can target a wide variety of web platforms including SWF Javascript PHP from a single syntax and compiler.

In one embodiment user terminals and are in communication with database server via network . Server may store media files that may be accessed by users via terminals and via network . Server may store events comprising computer mediated real time user consumption data. In one embodiment the consumption data is associated with users accessing media files.

For instance the media files may be music files and consumption data may be instances of user downloads or plays. Server additionally may record and or store the name of the artist album title album art track and or user ID each time a music track is accessed from server .

User terminal may access the data stored in a database server via network . The consumption data concerning the media files may be visualized in a display on user terminal . The real time consumption data may be updated periodically by accessing server and new consumption data may be parsed stored and arranged in a data structure and then added to the visualization in display according to the arrangement in the data structure.

User terminals and may comprise any of a variety of electronic communication devices including personal computers and or mobile telephones. Network may be any of a variety of networks including the Internet and or an Enterprise Network Intranet. Claimed subject matter is not limited in this regard.

At operation real time media item consumption data is accessed and parsed to select play events related to user s listening behavior. In the current embodiment the events are play events. However in certain embodiments the consumption data may be parsed to select events comprising data corresponding to a variety of other predetermined consumption behaviors.

In some embodiments consumption data comprises for each event an artist s name album name track title and or a media item consumption event such as whether the media item was purchased played replayed tagged and or skipped. Consumption data may be accessed at pre determined intervals or access may be triggered by another mechanism such as when a new real time media item consumption event occurs or if artist information is updated.

In one embodiment the play events are assigned an incremental ID and each event is associated with a user. Incremental IDs may be assigned by a server or may be assigned on the client side. At operation the play events are analyzed to determine whether they are new play events based on the incremental IDs. The highest IDs indicate the latest information accessed. The current play event IDs are compared to previously stored play event IDs and if a current play event ID is less than or equal to any of the previously stored play event IDs then the current play event is ignored. New play events are stored in an event stack having a predetermined stack limit and then arranged in a data structure wherein the data structure shows correlations between consumption data items and includes a temporal aspect. An embodiment of real time user consumption data analysis of play events is discussed in further detail below with respect to .

At operation if a new play event has been accessed media item consumption data corresponding to the new play event is analyzed to determine whether the media item consumption data e.g. artist name or track title is valid. Data validation may be done by comparing new media item consumption data with a database containing media item data and or by verifying that the entries themselves are valid. Media item validation is explained in further detail below.

At operation the media item data corresponding to the most recent play events are compared to the current media item data represented in visualization display . At operation if the most recently accessed media item data is not represented in the current visualization display then the new media item data is added to update the visualization display .

At operation the play events are analyzed to determine whether new relationships between represented media item data have formed. Referring back to briefly the consumption data corresponding to the play events may indicate that a particular user who previously played a song by INDRAS node played a song by Cascada node immediately after playing the song by INDRAS node .

At operation if display does not already show an edge between nodes and to represent this new relationship then a line or edge is generated to represent the correlation between play events for artists INDRAS and Cascada with respect to the particular user. However if the line or edge was already shown in display then a new line will not be generated. Rather user information would simply be updated without changing the display .

At operation old play event data is pruned. First an oldest event in the event stack it identified and then counters associated with the media item consumption data corresponding to the oldest event are decremented in the data structure. This pruning helps keep the visualization display uncluttered. Using this pruning method relevant data is updated and outdated or obsolete data is removed from the data stack and at a certain point the media item consumption data is removed from the data structure as well. The data pruning process is described in greater detail below.

Force directed placement involves specifying current vertex stress levels as a set of forces acting upon the vertex. These forces are generally attractive forces Hooke s Law generated from directly connected nodes and repellant forces Coulomb s Law generated from all other nodes.

In one embodiment when an edge connects two nodes a spring force algorithm directs the placement of the connected nodes with respect to each other in display . At an update interval the positions of the nodes changes depending on the cumulative force acting on each of nodes to account for new media consumption data accessed from server and newly generated edges appearing between some of nodes .

The positions of all nodes are continually updated until the overall level of stress plateaus or reaches a predetermined threshold. Additionally a given degree of damping is applied. This force is essentially a form of friction that helps to ensure that the network rapidly achieves a steady state.

Additionally hovering the cursor over node brings up an extended information pop up graphic that displays the user s name or ID to play a track by the artist corresponding to node . The last played track is also displayed in pop up graphic .

Additionally in one embodiment another pop up graphic appears next to icon in the lower left corner of the applet window when node is selected by clicking node with the cursor not shown . The pop up graphic displays additional information about the user s and artist corresponding to the artist node selected. Pop up graphic includes information about the recent users who have played the artist associated with the selected node and which songs by the artist have been recently played. Additional information on the users and artist may be accessed via hyper links provided in pop up graphic .

In nodes and are connected via edge because User A played a track by the artists represented by nodes and consecutively. Similarly nodes and are connected via edge because User B played a track by each represented artist associated with nodes and consecutively. Node is part of another small network of related artist nodes. Node indicates that User C played a track by Artist .

In depicts display with respect to after additional tracks are played. Nodes and are now connected because User A played a track by Artist node after playing a track by Artist node . Similarly nodes and are now connected because User C played a track by Artist node after playing a track by Artist node . All of the artist nodes in display change position according to the force directed algorithm described above with the addition of new edges and between nodes created in response to the various user s media consumption.

At operation a server stores media item consumption events such as a user s playlists or purchase history.

At operation an applet accesses information from the server on a continuous basis by polling at regular intervals and deciding which information to keep in the stack using predetermined stack parameters to control the amount of information used by the applet. Alternatively the server may push information to the applet device. In one embodiment using a stack of play events may minimize requests for too much information at once from the server and keeps the browser applet from using too much memory in a user s browser.

In one embodiment upon startup the applet retrieves a listening history XML document from the server e.g. requesting the last 20 play events . An example XML document is provided below in Table 1 showing two play events. In Table 1 the first play event starts at line and ends at line the second play event starts at line and ends at the next line . As can be seen in Table 1 entries within the play event boundaries comprise data corresponding to media item consumption.

The XML document is parsed and individual media item consumption events are retrieved. The media item consumption events in the current embodiment are listening or play events. However consumption events may be any recognizable computer mediated event wherein a user accesses a media item or other product or service and claimed subject matter is not limited in this regard.

The listening history document may provide one or more user s playlists or other media item consumption data segmented into play events. Each play event has a corresponding ID. This ID auto increments so the highest ID retrieved from a document indicates the latest information retrieved from the server. This number is then saved. If subsequent ID s retrieved from the server are less than or equal to this value they are ignored. The server may assign the IDs when storing the listening history or the applet may assign IDs based on information in the listening history.

In one embodiment the applet then checks each play event in the XML document. The applet determines whether the play event has valid information for the artist name and or other consumption data. In the event the artist name is invalid the applet skips the event.

For example if the artist name entries are n a various artists or various they are skipped. In one embodiment the artist name is trimmed to remove extra whitespace as well as removing any information contained in parentheses or brackets. This information typically gives track specific information on artist collaborators remixes etc. and may be added and stored in other embodiments. After validation the play event is then added to an event stack.

In one embodiment the event stack may be set or limited to a predetermined threshold number of play events e.g. 200 play events . If the stack goes over the threshold then the oldest events on the stack are removed.

At operation the media item consumption data associated with the play events is stored in a selected data structure operable to provide a temporal context for the media item consumption data and to indicate correlations between media item consumption data. In one embodiment the data structure may comprise hash tables which are a very efficient way to correlate events by various attribute. However other embodiments of data structures may be used and claimed subject matter is not limited in this regard.

In the current embodiment the applet maintains hash tables hereinafter hash or hashes for artists users and tracks that have been played. Anytime a new play event is created corresponding user and track ID hashes are created initialized or incremented. These hashes are essentially a tally of all the different events corresponding to a given user or track and is useful for debugging purposes as well as for handling data removal pruning events. The applet generates artist nodes in a display and determines relationships between artists by analyzing the play events. In one embodiment the play events contain the following media consumption data user information who played the track track information what track was played and artist information who recorded the track . Yet another user last artist hash table keeps track of the last artist played by a given user and is used to trigger the creation of an edge between two artists. In one embodiment edges are drawn according to known methods and edge data is maintained in a separate hash structure.

At operation artist nodes corresponding to play events are displayed. In one embodiment if a node contains a valid artist then the applet determines whether that artist has already been played. Each artist is essentially a movieclip object with the ID of the given artist. So the applet checks the artist hash e.g. a log of artists with play activity currently maintained by the applet to find an artist with the given ID. If the artist does not exist the applet creates a new artist movieclip object and adds it to the applet canvas applet window . It will update this object with the current album art if available as well as update information about the last played track for that artist.

In the current embodiment if user A plays Beat it by Michael Jackson and Michael Jackson is a new artist in the artist hash then the applet will display a new node representing Michael Jackson. In one embodiment the applet randomly positions the new node in the applet canvas.

At operation the applet periodically generates or updates artist information using the information stored in the selected data structure.

In one embodiment if the artist node already exists the applet increments a corresponding event count counter corresponding to that artist node updates the track information for the node and then updates the corresponding hashes for associated tracks and users by either incrementing the respective hash counters for the users and tracks and or by creating new hash entries for new users and tracks.

The user last artist hash is also checked for the current user. If the hash contains a different artist than the current artist and that artist is still on the display canvas then an edge is created between the two artists and the user last artist hash is updated to the current artist.

For instance in the current embodiment if there is already a Michael Jackson node displayed by the applet then when a new play event occurs additional information can be added to the existing node.

When a new play event occurs associated with an already existing Michael Jackson node the user ID associated with the recent play event the track played track meta data and a link to the an audio sample of the new track may be added or associated with the node. The new media play event may be user B played the track Thriller by Michael Jackson. Accordingly updating will result in the following new set of hashes 

At operation relationship information between artists may be periodically generated and or updated using information accessed and stored in the data structure. Such updates may be executed at predetermined intervals periodically and or in response to some triggering event such as recognition of a new play event.

Continuing with the example above an update may indicate user A played the track Jumping Jack Flash by the Rolling Stones. The updated hashes in this update are 

Here if the display canvas does not contain a Rolling Stones node a new artist node is created and displayed for the Rolling Stones. Additionally because user A played a Michael Jackson track and then the Rolling Stones track consecutively an edge is added in the display canvas connecting Michael Jackson and the Rolling Stones to show the correlation between them.

Using this last artist hash the applet links the two artists Michael Jackson and the Rolling Stones in the real time user consumption visualization display. Afterwards the hash for user A is updated to 

In one embodiment a graph edge canvas is created underneath the current node canvas. The current position of the corresponding node ID s are resolved and a line is drawn between them.

At operation the system prunes old or stale data and cycles back to operation . Accordingly the visualization display adds nodes until it reaches some limit e.g 100 nodes and then begins to remove old data.

The applet determines which hashes contain the oldest information by identifying the oldest event in the event stack and removing it from the event stack as well as decrementing counters in the hashes associated with consumption data corresponding to the oldest event. Identifying the oldest event can be done by a variety of methods such as for instance a first in first out FIFO method. In one embodiment the event stack is a simply a queue of events. New events get put on the top of the stack. If the stack gets too big then the event on the bottom of the stack is the oldest and in some embodiments is selected for removal.

The applet removes the oldest event and updates the hashes on the basis of the track artist user ID associated with the event. In one embodiment the applet decrements the counters by a predetermined amount for the stored data associated with the oldest event such as user track and artist hashes. If any of the counters for the decremented hashes goes to zero then it is inferred that the information related to that zero hash s user track artist is stale as well and the visualization no longer needs the related information. In this instance the applet deletes the old entry that decremented to zero as well as all the related information such as audio samples of tracks album art user profile web page links etc. .

When the oldest event is deleted from the event stack action may be taken by the applet to update the hashes and remove old data. For instance if when decrementing the track hash counter for the track ID corresponding to the oldest it goes to zero then the applet deletes the track ID from the hash. However if when decrementing the user hash counter for the user ID corresponding to the oldest event it goes to zero then the applet deletes it as well as the user last artist hash entry. If when decrementing the artist hash counter for the artist ID corresponding to the oldest event it goes to zero then the applet goes through and resolves its list of neighbors into a list of edge ID s by sorting them then looking them up in the edge hash . Then the applet removes each of the edge id s from the graph and then removes the artist node from the graph.

In one embodiment visualization of such data enables users to see emergent strongly related artists or in other embodiments related products or services . Sometimes the relationships are idiosyncratic such as a person who plays tracks by Metallica right after playing tracks by Brittney Spears. However usually the connections between media item consumption events or other computer mediated consumption items are meaningful and users can draw inferences about the media items products or services based on the determined connections between the products service media items.

The process begins at operation where the applet determines which event is the oldest event in an event stack.

At operation the applet decrements counter s in a data structure corresponding to information related to the oldest event by a predetermined amount e.g. 1 .

At operation the applet determines if any counter decrements to zero. At operation if a counter decrements to zero the applet removes the corresponding related information from the data structure and visualization. When a counter decrements to zero the applet may infer that the entry in the data structure and any related entry is stale and no longer needed for accurate real time visualization of user consumption behavior. This method of removing information allows the graph to be deleted fluidly in real time. However other methods of removing old or unwanted information may be employed and claimed subject matter is not limited in this regard. For instance in another embodiment a user may manually remove nodes from the visualization applet for instance by pressing a key to delete a currently selected node.

At operation the system accesses real time user consumption event data. In one embodiment the real time user consumption data may be retrieved from a server that stores data related to media item listening events. The real time user consumption data may be associated with user consumption behaviors such as purchase play skip artist track user send receive sign download and or trade. In other embodiments any product or service available via a network may be the subject of the real time user consumption data where accessing the product or service produces an event recognizable by a computer.

At operation the system adds real time user consumption event data to a selected data structure for storing and correlating subjects of the real time user consumption event data.

At operation the system determines the real time user consumption event data is new and creates a new node to display unrepresented subjects of the new real time user consumption event data or adds information to an existing node if the new real time user consumption event data does not define a new node. At operation the system determines if the new event data correlates two or more nodes. If there is a new correlation between two nodes a new edge is generated.

A correlation between nodes may be determined based on a variety of correlation techniques. For instance in the current embodiment each node keeps track of neighboring nodes directly through their own unique neighbor correlation data structure e.g. a neighbor hash . In one embodiment neighbors are nodes that are connected by one or more edges. The neighbor correlation data structure tracks consecutive plays of various artist tracks by various users. A correlation edge is generated when tracks by different artists are played consecutively.

At operation if the correlation between nodes exists then the system draws an edge graphic between correlated nodes. In one embodiment the edges are rendered as primitive lines using a Flash drawing API.

At operation the system assigns a new edge an ID number equal to respective concatenated node IDs. Since the network model is undirected the node ID s are sorted numerically first then concatenated and delimited and thus a unique edge ID can be assigned to each new edge. For example concatenated node IDs for node ID 1 ABC node ID 2 DEF would be unique edge ID ABC DEF. In one embodiment node IDs are sorted before concatenating to enable assignment of a unique ID per edge between two arbitrary nodes regardless of ordering.

At operation the system adds edges to the data structure for incrementing. In one embodiment the edge ID s are loaded into a hash which is also incremented and decremented like the user and track hashes described above with reference to .

In one embodiment a function iterates over all the edge ID s in the edge data structure e.g. an edge hash . At the start of a next render loop the graph edge canvas is cleared. Then the process repeats returning to operation .

It will be obvious to those having skill in the art that many changes may be made to the details of the above described embodiments without departing from the underlying principles of the disclosed technology. The scope of the present disclosed technology should therefore be determined only by the following claims.

