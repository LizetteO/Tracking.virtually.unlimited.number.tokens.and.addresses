---

title: Data parallel query analysis
abstract: A method of analyzing a data parallel query includes receiving a user-specified data parallel query that includes a plurality of query operators. An operator type for each of the query operators is identified based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs. It is determined whether the query is a prohibited query based on the identified operator types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266172&OS=08266172&RS=08266172
owner: Microsoft Corporation
number: 08266172
owner_city: Redmond
owner_country: US
publication_date: 20090403
---
Software programs have been written to run sequentially since the beginning days of software development. Steadily over time computers have become much more powerful with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever increasing single processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware software developers arrange for one or more tasks of a particular software program to be executed in parallel also referred to as concurrently so that for example the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Data parallelism is a programming pattern where an operation is applied to input data and the work is distributed across multiple computational cores by assigning different input elements to be processed by different cores. As a result of spreading the computation across multiple computational cores the time to complete the computation is reduced. Since a motivation for parallelism is improved performance one embodiment identifies queries that will not be executed efficiently in parallel and prevents them from being compiled.

One embodiment provides a method of analyzing a data parallel query which includes receiving a user specified data parallel query that includes a plurality of query operators. An operator type for each of the query operators is identified based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs. It is determined whether the query is a prohibited query based on the identified operator types.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

One embodiment provides a data parallel query analysis application but the technologies and techniques described herein also serve other purposes in addition to these. In one implementation one or more of the techniques described herein can be implemented as features within a framework program such as Microsoft .NET Framework or within any other type of program or service.

A query may be constructed by a developer using a predefined query language. The developer then typically uses a compiler tool to translate the query into code that calls appropriate library functions to execute the query. One type of query is a language integrated query. In one embodiment the queries analyzed by the data parallel query analysis application are language integrated queries. A language integrated query according to one embodiment is a query that is an integrated feature of a developer s primary programming language e.g. C Visual Basic . Language integrated queries according to one embodiment allow query expressions to benefit from rich metadata compile time syntax checking and static typing that was previously available only to program code written in a statically type checked language and specifically not queries that are customarily embedded into such programs as untyped strings. As an example Microsoft supports the LINQ Language Integrated Query programming model which is a set of patterns and technologies that allow the user to describe a query that will execute on a variety of different execution engines. LINQ provides .NET developers with the ability to query and transform data sequences using any of a variety of .NET programming languages.

In one embodiment a developer describes a query using a convenient query syntax that consists of a variety of query operators such as projections filters aggregations and so forth. The operators themselves may contain one or more expressions or expression parameters. For example a Where operator will contain a filter expression that will determine which elements should pass the filter. An expression according to one embodiment is a combination of letters numbers and symbols used to represent a computation that produces a value. The operators together with the expressions provide a complete description of the query.

In one embodiment the queries analyzed by the data parallel query analysis application are data parallel language integrated queries that are configured to be executed in a parallel manner. Data parallelism is a programming pattern where an operation is applied to input data and the work is distributed across multiple computational cores by assigning different input elements to be processed by different cores. As a result of spreading the computation across multiple computational cores the time to complete the computation is reduced.

Writing data parallel programs from scratch is a non trivial programming problem and can be simplified by building the solution on top of an existing data parallel library. The library will provide various operators e.g. projections filters joins reductions etc. that the developer can combine to build data parallel queries. Parallel LINQ PLINQ from Microsoft is one such library. PLINQ accepts language integrated queries and automatically uses multiple processors or cores for execution when they are available. The following Pseudo Code Example I gives an example of a PLINQ query that negates the elements from the array arr takes the first 1 000 of them keeps only those that are divisible by 3 and dumps the results into an array 

Since a motivation for parallelism is improved performance one embodiment identifies queries that will not be executed efficiently in parallel and prevents them from being compiled. Some operator sequences may be efficient but other sequences may not. One embodiment defines two kinds of parallel computations parallel arrays and parallel sequences. In one embodiment some operators can be applied to parallel arrays but not parallel sequences. That way more operators can be supported than a system based solely on parallel arrays or parallel sequences and queries are limited in one embodiment to those that can be executed efficiently. One embodiment provides data parallel array and data parallel sequence application programming interfaces APIs with static enforcement of usage patterns. In one embodiment the APIs use types e.g. query operator types to statically enforce efficient usage patterns. One embodiment provides a parallel query API based on a combination of parallel sequences and parallel arrays. In one embodiment the parallel query API allows queries that are determined to be efficient does not allow queries that are determined to be inefficient and supports a large number of operators.

Computing device may also have additional features functionality. For example computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any suitable method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media e.g. computer readable storage media storing computer executable instructions for performing a method . Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other tangible medium that can be used to store the desired information and that can be accessed by computing device . Any such computer storage media may be part of computing device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Computing device may also include input device s such as keyboard pointing device e.g. mouse pen voice input device touch input device etc. Computing device may also include output device s such as a display speakers printer etc.

In one embodiment computing device includes a data parallel query analysis application . Data parallel query analysis application is described in further detail below with reference to .

Data parallel query analysis application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for receiving a data parallel query that includes a plurality of operators logic for identifying an operator type for each of the query operators based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs logic for providing query verification data that indicates allowed operations on a parallel array type data structure and a parallel sequence type data structure logic for determining whether the query is a prohibited query based on the identified operator types and the query verification data logic for preventing the query from being compiled if it is determined that the query is a prohibited query and for compiling the query if it is determined that the query is not a prohibited query and other logic for operating the application.

Turning now to techniques for implementing one or more embodiments of data parallel query analysis application are described in further detail. In some implementations the techniques illustrated in are at least partially implemented in the operating logic of computing device .

In one embodiment transitions represent allowed transitions between nodes and the absence of a transition indicates that such a transition is not allowed. As indicated by transition a parallel array can be converted to an array by using a ToArray method. As indicated by transition an array can be converted to a parallel array by using an AsParallel method. As indicated by transition a parallel sequence can be converted to an array by using the ToArray method. As indicated by transition an enumerable can be converted to a parallel sequence by using the AsParallel method. As indicated by transition a parallel array can be converted to a parallel sequence by performing a partitioning operation. As indicated by transition an AA type operator receives a parallel array as an input and generates a parallel array as an output. As indicated by transition an AB type operator receives a parallel array as an input and generates a parallel sequence as an output. As indicated by transition a BB type operator receives a parallel sequence as an input and generates a parallel sequence as an output. In the illustrated embodiment the operator transitions correspond to the operator type data .

As shown in the state diagram includes two parallel data structures a parallel array and a parallel sequence . These data structures will now be described in further detail beginning with parallel sequences. One way to implement a parallel sequence is with a set of enumerators. An enumerator is used to sequentially walk through a sequence. In one embodiment each enumerator for a parallel sequence is an object that supports two methods GetCurrent and MoveNext . GetCurrent returns the element that the enumerator is currently positioned at and MoveNext moves the enumerator to the next element in the sequence returning false if the end of the sequence is reached. Advancing each enumerator computes one output element. Different enumerators for a given parallel sequence can be advanced by different computational threads thus distributing the work onto multiple computational cores.

In one embodiment a parallel sequence is implemented as a class that implements an IParallelSequence interface as shown in the following Pseudo Code Example II 

To execute a parallel computation on a parallel sequence the method GetPartitions in Example II is called to obtain a plurality of partitions and then each partition is processed by a separate enumerator on a separate thread. Additional operations can also be applied to the output of this data parallel computation. This can be done by wrapping each enumerator with another enumerator that applies some operation to the partition. In this manner another parallel sequence is generated to which further parallel operations can be applied.

The code in Example III according to one embodiment behaves as follows. AsParallel converts the source array src to a parallel sequence which includes a number of partitions e.g. equal to the number of computational cores available . The Where operator wraps each partition with an enumerator that filters out odd integers and returns a parallel sequence that contains the wrapped partitions. The Select operator wraps each partition returned by the Where operator with an enumerator that computes Foo x for each element and also returns a parallel sequence . The ToArray operator takes the parallel sequence returned by the Select operator and walks over each partition on a different thread. Walking each enumerator performs the computation so by walking over different partitions with different threads the computation is parallelized.

In contrast to the parallel sequence a parallel array according to one embodiment has two properties 1 it is known ahead of time how many elements the output will contain and 2 any particular output element can be computed without having to compute all elements that come before it. For example the fifth element of the output can be computed without computing the first four elements. These two properties may rule out some operations such as filtering using a user provided predicate. When filtering it may not be known how many elements there will be in the output until the predicate is applied to each of the input elements. Similarly before being able to compute the i th element of the output the first i elements that pass the filter will first be found.

In one embodiment a parallel array is implemented as a class that implements the IParallelArray interface as shown in the following Pseudo Code Example IV 

Calling GetResult i will trigger a computation to compute the i th element of the output. Thus by calling GetResult for different indices from different threads the computation can be distributed among multiple computational cores.

In one embodiment query operators such as query operators are classified into three types or categories e.g. AA AB and BB depending on whether they accept and return parallel sequences or parallel arrays . An operator of the AA type according to one embodiment accepts a parallel array as input and returns a parallel array as output an operator of the AB type according to one embodiment accepts a parallel array as input and returns a parallel sequence as output and an operator of the BB type according to one embodiment accepts a parallel sequence as input and also returns a parallel sequence as output.

It will be understood that additional or different operators than those listed in Tables I III may be used and that Tables I III are not meant to be limiting.

State diagram will now be described in further detail with reference to a couple of example queries. As a first example consider the PLINQ query given in the following Pseudo Code Example V 

The query given in Example V is allowed by the state diagram . This can be confirmed by tracing the query through the state diagram . On the first line of Example V an array arr is defined. On the second line AsParallel is applied to the array thereby converting the array to a parallel array which is allowed as indicated by transition . On the third and fourth lines AA type operators are used so the result will be a parallel array which is allowed as indicated by transition . On the fifth line a BB type operator is used so partitioning will happen transition to generate a parallel sequence and the output result will be a parallel sequence transition . On the sixth line ToArray is called to execute the query and generate a regular array as the output of the query.

The query given in Example VI is not allowed by the state diagram because the output of the BB type Where operator is a parallel sequence but the Take operator is an AA type operator which is applied to parallel arrays and there is no transition from a parallel sequence to a parallel array . In one embodiment the compiler would throw an error or generate a prohibited query indication if the user wrote this query. The indication according to one embodiment indicates that the query would not be efficiently executed in parallel.

At an operator type for each of the query operators is identified based on a type of parallel input data structure the operator operates on and a type of parallel output data structure the operator outputs. In one embodiment the type of parallel input data structure and the type of parallel output data structure for each operator are each one of a parallel array type of data structure and a parallel sequence type of data structure. In one embodiment the parallel array type of data structure comprises an interface including a first method for providing indexed access to elements in the data structure and a second method for obtaining a count value representing a total number of elements in the data structure. The parallel sequence type of data structure according to one embodiment comprises an interface including a method for partitioning the data structure into a plurality of partitions and enumerating through the plurality of partitions with a plurality of enumerators.

The parallel array type of data structure and the parallel sequence type of data structure according to one embodiment are each lazy data structures. A lazy data structure according to one embodiment is a structure in which the elements are computed on demand as opposed to eagerly . For example in one embodiment when an element of a lazy data structure is first accessed the element is computed at that time and if the element is accessed again later the element is recomputed at that time. In one embodiment elements that have already been computed may be stored in memory to avoid re computing these elements.

At in method it is determined whether the query is a prohibited query based on the identified operator types. In one embodiment the operator types include a first operator type configured to operate on the parallel array type of data structure and output the parallel array type of data structure. Operators of the first operator type according to one embodiment include at least one of a Select operator configured to perform a projection on array elements a Take operator configured to take a user specified number of array elements a Reverse operator configured to reverse positions of array elements and a Concatenate operator configured to concatenate two parallel arrays. In one embodiment the operator types further include a second operator type configured to operate on the parallel sequence type of data structure and output the parallel sequence type of data structure. Operators of the second operator type according to one embodiment include at least one of a Select operator configured to perform a projection on sequence elements a Where operator configured to keep sequence elements that match a user specified predicate and a SelectMany operator configured to perform a one to many projection on sequence elements. In one embodiment the operator types further include a third operator type configured to operate on the parallel array type of data structure and output the parallel sequence type of data structure. Operators of the third operator type according to one embodiment include a PositionalWhere operator configured to keep array elements whose position matches a user specified predicate.

At in method the query is prevented from being compiled if it is determined at that the query is a prohibited query and the query is compiled if it is determined at that the query is not a prohibited query .

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

