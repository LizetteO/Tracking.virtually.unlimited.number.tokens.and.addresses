---

title: Platform for data aggregation, communication, rule evaluation, and combinations thereof, using templated auto-generation
abstract: Embodiments of the present invention provide platforms for data aggregation, communication, rule evaluation, and combinations thereof. The platform may include three distinct functional layers; a core layer, an adaptive layer and an intelligence layer. Furthermore, the platform may include a data block, messaging block, rule block, or combinations thereof. Generally, the platform may facilitate data acquisition, storage, and manipulation between and among clients and data sources in a generic manner. That is, clients may communicate and make requests independent of a target system or database type. The platform may process the communications and requests in a manner suitable to the target system or database type. The platform may also evaluate rules received from the clients in a manner generic to the client application. Instances of the platform for a given application may be efficiently created using a template-based mechanism. In this manner, the platform may be used to support a variety of end user applications in a flexible, scalable manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08402081&OS=08402081&RS=08402081
owner: Atigeo, LLC
number: 08402081
owner_city: Bellevue
owner_country: US
publication_date: 20090225
---
This application claims the benefit of the filing date of U.S. Provisional Application Ser. No. 61 067 162 filed Feb. 25 2008 the entire disclosure of which is considered to be part of the disclosure of the instant application and is hereby incorporated by reference herein for any purpose.

Embodiments of the invention relate to methods and systems for robust data handling in particular generic formulations for dynamically communicating manipulating storing or taking a combination of those actions with a variety of data sources and client types.

Widespread use and acceptance of computer systems has resulted in a proliferation of data. A wide variety of enterprises and individuals generate and store large amounts of data. Data mining and analysis has therefore become increasingly important as people and enterprises try to glean intelligence from their data.

However data mining and analysis efforts have been hampered by the large and disparate formats in which data may be stored and manipulated. Custom software is typically required to build system wide solutions that combine data in a particular way or implement a specific analysis technique.

For example a retail store seeking to store mine and analyze their data in a meaningful way faces a variety of challenges. The store may want to collect data from a variety of locations. One source of data is the store itself inventory on hand and daily sales for example. Another source of data are the store s suppliers. The suppliers all may have their own data about inventory availability price and selection. The store s customers may also have their own data about their purchase history at that and other stores and demographic data for example.

Store personnel generally are required to make a variety of decisions such as which items to order and how much of each item to order and at what time. Knowledge and the ability to analyze data from all of the above mentioned sources may be able to aid in this decision but only if the data is readily available and can be analyzed in accordance with criteria that will be useful to the store personnel.

Creating a software solution that is able to aid the store personnel in a meaningful way may require the ability to interface with the disparate systems that hold the store data supplier data or data of other external entities and customer data. Moreover the software solution must be able to manipulate this information in accordance with the analytical criteria the store personnel would like evaluated.

Of course many existing software systems aimed to mitigate communication between specific disparate data types or conduct a specific type of analysis on a given set of data. However software developers routinely focus only on the problem at hand and build a specific software solution to connect the store s database with the database of the supplier for example. The software itself is likely to depend on the particular data attributes used by the store and the supplier. Similarly a software developer is likely to build an analytics solution that specifically answers the question posed by the store personnel. The analytics solution may be hardcoded to process the specific attribute types contained in the supplier and store databases and compute one or a series of specific calculations desired by store personnel.

Accordingly when the store or the supplier or a customer changes or adds a database type a data attribute or when store personnel would like data analyzed in a new manner the software developer is required to intervene and change the software code used to analyze the data. This process may be cumbersome and it may limit the store s ability to have rich interactions with its data and change the analytical techniques used or the type of data analyzed.

Furthermore due to the specific nature of the software involved the store s solution will be unsuitable for another entity trying to perform a completely different data analysis task. For example the store s inventory software solution would be completely unsuitable for analyzing traffic patterns on a nearby interstate. To handle traffic pattern analysis the software developer would need to develop a new software solution from the ground up.

A brief summary of challenges in three areas are described below 1 storing and sharing data amongst different database types 2 communicating between different and unknown system types and 3 acting on stored information.

A brief overview of database storage and interoperability challenges will be described with reference to . Electronic databases such as database in store data and are configured to access and manipulate the stored data according to various objects specified by the database such as ObjectA in . An object is generally a collection of data and methods for manipulating the data. The objects may specify a variety of methods for manipulating the data including methods for creating reading updating or deleting data entries in the database. MethodA and MethodB are shown in associated with ObjectA.

An application programming interface API provides access to the methods in the database . The API for example supports MethodA and MethodB used in the database . Clients access the database by communicating a message to the API . The message includes one of the functions supported by the API. So for example in Client passes a message that includes a request to execute MethodA and parameters for the execution of MethodA. Recall that MethodA is a specific method supported by the database .

Accordingly the API may achieve relatively high performance because little if any manipulation must be performed on the received message before passing a function call to the database to perform MethodA with the enclosed parameters. However the API is not very flexible.

For example if database stores customer information ObjectA may refer to a customer and MethodA may include a method entitled GetCustomer which operates to retrieve a customer number based on an order number and a purchase date. Code used to implement the API may then include the statement 

 int indicates the API is expecting an integer the customer number returned from this call. The API also expects an integer order number and a date time formatted purchase date to be transmitted along with the request. Message must then include GetCustomer OrderNumber PurchaseDate .

The API then passes the message as a function call to the database . Databases have various internal mechanisms for communication and formatting for function calls and parameters including any of a variety of querying languages specific to the database type such as SQL a relational database query language or the like. The API is specific to the database and formats the message into a proper function call for the database .

There are several drawbacks to this approach for database communication that become increasingly apparent as databases become increasingly complex and numerous.

A first drawback is that the API supports only the specific methods supported by the database . Once the source code for the API is compiled it becomes a static entity and cannot support any further methods. If the database is changed to a different database that supports say MethodC instead of MethodA the API will not be able to generate a function call for MethodC. The API will need to be rewritten and recompiled to support the new method. This requires that the API be taken off line stopped or taken out of service while a new API is written compiled and put back into service.

Another drawback is that the API supports only the specific communication language used by the database . The API only formats messages for a particular database language. Again if the database is changed to a different database utilizing some other internal language the API must be rewritten and recompiled requiring time and a suitably skilled operator to perform the update.

The above drawbacks to database communication apply generally to all available database types including relational databases and object oriented databases. Older database models such as hierarchical and network models also have the described drawbacks.

As data collection and mining become increasingly important and sophisticated communicating among complex systems for storing and manipulating data has become difficult. Separate applications or systems have their own internal methods of communicating and syntax and vocabulary for storing and manipulating data. A same or similar procedure may have different names in different databases or systems for example. One application may want to call that procedure in a variety of different databases.

Present systems handle this communication difficulty by calling the specific procedure name for each system of interest. For example a code fragment from a first system may call an IOrderFulfillment interface as part of the implementation of a call implementing an interface for accepting orders. An interface is generally a portion of code that receives calls from clients and mediates access to an underlying procedure or data store. The Accept Order class may be coded as follows 

This class needs to communicate with the IOrderfulfillment interface implemented by a second system. The Fulfillment interface may itself need to communicate with a further interface such as a shipment interface. The second system may encode an order fulfillment interface as follows 

The above examples contains two separate calls to an order shipment interface one to OrderShipment and one to OrderShipmentEx . These two consecutive calls are necessary to communicate with a third and fourth system each of which implement the order shipment interface. One implementation the third system codes the order shipment interface as 

The second system above was accordingly required to make two consecutive calls one to the order shipment interface as specifically implemented by the third system and the other to the order shipment interface as specifically implemented by the fourth system. A problem may arise if the third or fourth system or both are changed to different or new systems that no longer support the particular format of the calls made by the second system. If the implementation of the shipment interface changes the implementation of the fulfillment interface of system two must be correspondingly changed and recompiled which may be undesirable.

A variety of actions may be desirable using collected stored data. In particular an organization or entity may desire to evaluate a variety of conditions on stored data. However the conditions will vary according to the type of data and the purposes of the requestor. For example a thermostat application may desire to set a temperature to a warm setting if stored data indicates it is cold outside and it is the morning. This is a simple example of a type of rule that an application may desire to evaluate. The permutations of rules may vary widely according to the end use of an application and the types of data available.

The common approach to the execution of rules would be to hard code the rule into the software system. So for example a thermostat application may contain lines of code that are specific to the condition and action described above that is to temperature and temperature settings. The code would explicitly recite parameters such as temperature and set . Should the users of a temperature application want to implement a different rule for example if an occupant is detected in a room set the temperature to a certain level or if it is night then set temperature to cold a new code would be required to implement and evaluate the rule. This may require taking the system offline preparing code recompiling the code and restarting the system.

The above description identifies some of the challenges in supplying a robust scalable rule based expert system. While software may be prepared to interface specific disparate data systems and evaluate rules for a particular given end use the resultant software application may be no more flexible than before. That is the software is still confined to the particular use for which it was designed and the specific systems for which it was designed to integrate. The addition or subtraction of systems or the revision addition or subtraction of rules to be evaluated may require stopping the system commissioning the preparation of specific new software code re compiling the software and redeploying the software solution. This procedure may be cumbersome and limit the usefulness of any one particular software solution. Ultimately the time involved in a system shutdown code drafting re compiling and re deployment along with additional time for testing may be prohibitive in designing or deploying a system change.

Certain details are set forth below to provide a sufficient understanding of embodiments of the invention. However it will be clear to one skilled in the art that embodiments of the invention may be practiced without various of these particular details. In some instances well known computer systems and architecture software operations and protocols have not been shown in detail in order to avoid unnecessarily obscuring the described embodiments of the invention. Embodiments of the present invention may be implemented in all or in part as executable instructions encoded in a computer readable medium that when executed cause one or more processors to perform the functionalities described. In some embodiments hardware or firmware may be used in all or in part to perform the functionalities.

Section headings may be used in this document. The section headings are intended only as an explanatory guide to the document. The section headings are not meant to imply that all information related to the heading is found in that section or that no information related to that heading may be found in other sections. To the contrary embodiments of the present invention provide integrated systems whose individual components may be highly interrelated. Accordingly information about any one component may impact the functionality and workings of other components. Accordingly individual components should be interpreted in light of the entire description herein and their description is not isolated to any one section.

Generally then the layers represent a conceptual distance from a data source in that the components depicted in the core layer are process data that is closer to raw data stored in one or more data sources not shown . These components such as data messaging security and management in some embodiments manipulate raw data to abstract communicate apply security or manage the data. The adaptive layer may provide some context to the data providing and manipulating information concerning for example preferences context and rules and interaction. The intelligence layer may further add information to enrich the context of the data or transactions involving data. For example the intelligence layer may generate knowledge based on the data manipulated by the core layer and context enriched by the adaptive layer . The intelligence layer may uncover or recognize patterns or relationships in the data or infer additional information about the data based in some examples on both the data and the context or preferences provided by the adaptive layer . Any of a variety of intelligence modules may be used to impart a variety of different types of intelligence to the data gathered and processed by the core layer and context enriched by the adaptive layer . Finally any of a variety of applications may be written and implemented on any suitable computing device to put the functionality provided by the platform to one or more specific end uses. Donation functionality and point of service applications for example will be described further below. Other applications may be implemented in other embodiments.

As will be described further below the platform generally represents an architecture that can implement a rule based expert system. The platform communicates stores and manipulates data in a generic way such that any number of clients and data sources may be added deleted or changed. The platform may be implemented by one or more computing devices with sufficient memory and software to implement the functionalities described. The platform includes three components a data block a messaging block and a rule block . Although all three components are shown in the platform in some embodiments one or more of the blocks may not be implemented. Each of the blocks and generally include one or more processors and associated memory storing encoded software sufficient to perform the described functionalities. One or more of the blocks and may utilize a same processor and memory in some embodiments. Each of the three blocks and may be implemented by the same or by different processors. The three blocks and may be in communication with each other and communicate as generally described below.

The data block generally provides a set of functionality for bringing databases online in a dynamic manner after system initialization and interacting with those databases. The data block may utilize web services to interface with functionality encapsulated in stored procedures. is a schematic illustration of am example of the data block . A client data agent may communicate with the data block to generate one or more tables in one or more of the databases . The client data agent accordingly communicates an XML schema to the data block . The XML schema may be used to specify desired structure. As will be described further below the XML schema may describe desired data characteristics in a way that is generic to several database types. The data block may accordingly receive the XML schema and format the information from the XML schema in a manner particular to the type of database for which it is destined. For example the XML schema may be designed to represent an entity and the XML schema may contain information about attributes of the entity and instructions for and manipulating the entity . So for example the resultant table created in one of the databases by the data block may include create read update delete CRUD functionality for each of the entities such as the entity . The CRUD functionality may be created by the data block automatically generating a set of stored procedures for regulating interactions with the databases . A set of web services and are provided in the data block for interaction with the client data application the client data agent or both.

Accordingly the data block includes a database code generation facility at . The database code generation facility functions to generate the explicit database code for one or more of the databases corresponding to the desired database structures represented in the XML schema . Data store integration web services are provided to interface with the client data agent . Data block also includes the stored procedures that may be used to manipulate data in one or more of the databases . In particular the data block may maintain a variety of functions for adding additional data sources structures or both including but not limited to create database delete database delete table for entity create entity delete entity update entity and read entity. Data access web services are provided for communication with the client data application . In this manner a flexible web services interface for clients is provided to the data block . By generating database code and storing procedures within the data block the specifics of the databases may be transparent to the clients . Accordingly any of the individual databases and may be changed or new databases added or one or more databases removed without requiring any change to the clients . Communication between the data block and the databases may occur in any manner. In some embodiments a traditional configuration file is not used to store connection strings communicated from the clients such as the connection strings and . Instead the data block uses SOAP messages to interact with the databases . The connections may be specified in SOAP headers which may be secure SOAP headers in some embodiments.

A system implementing an example of a data block according to an embodiment of the present invention is shown in . A generic API creates an interface between a client and a data source such as a database . A data engine processes messages received by the generic API into function calls for the database . The generic API supports its own abstracted set of commands such as Execute as shown in as will be described in further detail below. A client sends a message containing a command supported by the API Execute as shown in and a payload. The payload will be described further below but generally contains an XML schema including one or more references to a specific method supported by the database . The data engine processes the message and generates function calls for the database . In this manner if the methods of database change or database itself is swapped out for a different database having different methods the generic API does not need to be altered or recompiled in any way. Instead the client may assemble a different payload for the message as appropriate.

When the database responds to the function call the data engine may format the response in a manner usable by any programming language able to receive a response from the data engine . When the data engine is implemented as a web service for example the data engine will be able to communicate a response to any client capable of receiving a web service response. For example the data engine may format a response as a serialized version of an XML schema that can be de serialized in any client and programming language that can manipulate XML. Information regarding exceptions and errors may also be included in the returned XML schema response.

An example of a code portion used to implement the generic API may include a generic statement such as 

This statement indicates the generic API expects an object returned and will perform an ExecuteMethod procedure using a passed in payload which will be of a string type and are described further below. The returned object may be a serialized form of an XML schema instance for example.

The generic API may support other methods that are generally variations of ExecuteMethod. Other methods may call into ExecuteMethod. The other methods may be specifically for different types of return data. Return data types may include those specified by ADO.NET a suite of data access technologies included in the Microsoft .NET Framework. ADO.NET specifies a variety of possible return types including DataSet Scalar XML DataReader and None. The generic API may support functions for each of these return types.

The generic API may be implemented as a web service such that the client or multiple clients not shown in can communicate with the generic API from a remote location using http and SOAP protocols. SOAP Simple Object Access Protocol is an XML based protocol for exchanging information and is generic and modular. Accordingly SOAP may be advantageous when the message communicated with the generic API includes XML as will be described further below.

The generic API as well as the data engine which will be described further below may be implemented using any programming language including any language that supports the implementation of web services including but not limited to C VB.NET C and Java.

Referring back to the client develops a payload for transmission to the generic API . The client may be a human operator in some embodiments while in other embodiments the client is another computer process which generates the message including the payload. While only one client is shown in any number may be passing messages to the generic API simultaneously or at different times. Since the generic API supports a generic execute command such as ExecuteMethod in the code portion above specific methods to be accessed within the database are provided in the payload. The payload should include the names of the methods to be called and any necessary parameters for calling the methods. The payload is formatted in a manner such that the data engine can process the payload and format the information contained in the payload into the function calls and for example for the database .

A schematic illustration of an embodiment of a payload is shown in . The schema payload includes a reference to MethodA at payload element and reference to MethodB at payload element . MethodA includes references to Parameter and Parameter at elements and . A trigger indicator referenced in element indicates an end of the parameters for MethodA. The Parameter and Parameter references have associated metadata including type attributes referenced in elements and values referenced in elements . Metadata is information about data and includes the type attributes described. Metadata may also include other information about data. Accordingly other metadata such as a direction attribute may be included in other embodiments and some attributes may not be included in other embodiments of schema payloads. For example one or more parameters may be associated with a method in a schema payload that indicates an anticipated return type of the method. The return type parameter will not have a value associated with it.

MethodB includes Parameter referenced in element having type and value referenced in elements and respectively. Trigger indicator referenced in elements indicates an end of the parameters for MethodB. Any number of methods may generally be referenced in a schema payload and multiple instances of a same method may be included as well. The payload may be implemented as an XML schema and coded accordingly. The trigger indicators and may be implemented by for example the end method tags of an XML schema where element a start of a method reference may be implemented by a tag and trigger indicator implemented as an tag.

An example of an XML schema that may be utilized as the payload to implement a GetCustomer method using an order number and a purchase date is as follows 

The above XML schema payload specifies a method GetCustomer containing parameters OrderNumber and PurchaseDate. The OrderNumber parameter in the schema above is of an integer type. The Direction parameter indicates the parameter passed in has meaning for the call into the API not the return . In the above example 123 is the order number being passed in. The PurchaseDate parameter in the schema above is of the type DateTime and the date 2005 Mar. 18 is being passed to the API. The parameter Return in the example schema above indicates that a return type of integer is expected. is a trigger indicator indicating an end of the information associated with that method.

Referring back again to once the payload is received by the generic API the data engine processes the payload to formulate specific function calls for the database .

An embodiment of a method for operation of the data engine to process the payload is shown in . The payload may be loaded into memory for faster access if desired. In some embodiments only a portion of the payload is loaded into memory accessible to the data engine and that portion is traversed. The data engine then traverses the payload by loading a portion of the payload into memory and processing the portion in memory. As the traversing proceeds a next portion of the payload may be loaded into memory for traversal and so on until the entire payload has been traversed. The data engine can implement a MemoryStream function to examine the payload from memory. The processed portion is then offloaded and the next portion of the payload may be loaded into memory and processed. In other embodiments the payload may be parsed by the data engine. The data engine parses the payload by validating the entire payload and loading it all into memory.

Traversing rather than parsing can increase the performance of the data engine . In one embodiment where the data engine is implemented in a Microsoft NET Framework the data engine uses an XMLTextReader to traverse the payload. The traversing operation may not perform data validation typically done when reading XML and does not parse the XML types as it goes they are simply read.

As the payload is traversed the data engine identifies the start of a method call such as MethodA in . In some embodiments the actual name of the method call is passed in such as MethodA and the data engine will utilize this name in the function call in for the database. However in other embodiments only a portion of a name of the method call is passed and the data engine may reformat the name contained in element of into an actual function call supported by the database by for example adding suffixes or other characters as will be described further below. Information regarding how to reformat the name in element into a function call name may be included in a data template described further below.

Once the start of the method call is identified the data engine assembles parameters associated with the method call. Referring back to for example Parameter along with its metadata is unpacked from the payload and stored as a properly formatted parameter for a function call. When traversing an XML schema for example a stored parameter may be generated for each portion of the XML schema following the method indication. The properly formatted parameter may be temporarily stored as objects. As described further below the stored parameters are communicated to the database and then they may be discarded. In some embodiments the data engine may check the stored parameters to determine if the parameters are complete and if a parameter is missing an element or if the method name is faulty the information related to the faulty method or parameter in the payload may be discarded or skipped.

As the data engine continues to process the payload a trigger indicator is then identified such as the indicator in . Once the trigger indicator is identified the data engine calls the identified method using the parameters assembled . The data engine then identifies a next method call in the payload and the process shown in may repeat.

Structurally embodiments of the data engine shown in may include a processor coupled to a computer readable medium containing executable code causing the processor to perform any or all of the actions shown in and described with reference to . The data engine may be implemented in software hardware or combinations thereof. Embodiments of the data engine may be implemented as a web service and accessed using http including the use of SOAP transport for communicating XML. The processor implementing the data engine may be the same as that implementing the generic API in some embodiments.

Accordingly the above description has provided an explanation of how a data engine may support a generic API to receive messages including a payload and process the payload into one or more specific function calls to a database. By providing a generic API the generic API need not be recompiled or rewritten when one or more client entities want to communicate new or different calls to the API. However as described above with reference to existing APIs are coded to format function calls in a particular language depending on the type of database for which the call is destined such as Oracle SQL or the like. The data engine may also provide functionality to flexibly format function calls for any of a variety of databases as will now be described. In this manner the generic API also need not be recompiled or rewritten if the type of target database changes.

When a data engine receives a payload destined to apply to a certain type of target database the data engine can formulate the method calls to the target database in a manner specific to the type of the target database. Database types may include for example Oracle SQL or any other database type or format. To do this the data engine should receive an indication of the target entity. With reference to an indication of a target database type may be communicated by the client to the data engine . The data engine may receive the target type indication in a variety of ways. In one embodiment the data engine identifies the type of database by reading a configuration file accessible to the data engine. For example when the data engine is implemented as a web service a connection string to any OLEDB Object Linking and Embedding Database including Oracle and SQL may be used as a web.config setting. The data engine web service could then read the web.config setting at each call or at other periods in some embodiments. In some embodiments the data engine determines the target database type by referencing the configuration file on a default basis. That is if no other target database indication is provided the data engine may use the target database type specified in a configuration file accessible to the data engine.

In other embodiments the indicator of the target database type is transmitted in parallel with the message . When the client communicates with the data engine over http a SOAP header may be used to pass the indicator . The SOAP header can be inspected on a call by call basis. The SOAP header may be prepared using a connection string in a configuration file residing with the client . The data engine may inspect the SOAP header to determine the type of the target database on every call in some embodiments or periodically according to the particular implementation and use of the data engine.

When the type of database to be involved changes the client can change the indicator or transmit a new indicator without changing the message or the process of communicating the payload. The SOAP header or configuration file is simply updated to indicate the new or different target database. The data engine uses the target type indicator to change the way data unpacked from the message is formatted into individual calls to the target database. Thus formulating a request to a new or different database type does not require recompilation of any code within the data engine. The type of target can thus be changed without changing the payload or re compiling the generic API executed by the data engine. A new template may simply be used as described further below that allows the data engine to format the call in a manner appropriate for the new target type.

To facilitate formatting function calls in accordance with any of a variety of possible database types as indicated by the target type templates are provided in a template memory in communication with the data engine . The template memory may be integral with a computing system used to implement the data engine or may be a separate data storage subsystem. The template memory contains templates describing how method calls are formatted for each of a variety of database types. In some embodiments the template further describes how data may be manipulated within each database for example create read update delete and other operations . The data template may describe how each operation maps into specific commands for the target database type. Data templates may be implemented as XML schemas. In some embodiments the data templates advantageously require a small amount of memory such that they are able to be stored in cache memory. Of course the size of the cache memory will be dependent on the availability and cost of the memory. As an example of the size of a data template in some embodiments a data template suitable to prepare messages for a SQL server is less than 4 kilobytes.

Any number of data templates may be provided with typically one data template per database type with which the data engine may have to access or communicate. In some embodiments where certain functions of different database types are identical the database types may share a single data template. Data templates may be deleted when a certain database type is no longer needed or desired. Data templates may be added when a database type is added or anticipated. Accordingly when a destination database type changes or a new database is added a new template may simply be added to the template memory without a need to recompile the generic API or change the operation of the data engine .

An embodiment of a method implemented by the data engine to generate a function call is schematically depicted in . The data engine receives an indicator of the target type as described above. The data engine may then load a data template corresponding to the target type into a cache or other accessible memory for faster access. If the data template has already been loaded due to a pre loading procedure or recent use for example the data template need not be reloaded. Alternatively the data engine could access the data template at a remote location without loading the template into the cache.

The data engine then traverses the data template to unpack the template and generate statements specialized to the database type. The statements are then used by the data engine in combination with data received in the payload described above to generate a method call for the database as generally described above with reference to . That is with reference to once the data engine has identified a method call and assembled parameters from a payload the data engine may utilize database specific statements generated from a data template to generate an appropriate method name for the target database and format parameters for the target database. So for a single input payload the data engine could generate any of a variety of statements based on the data template used to format the information extracted from the payload.

Accordingly embodiments of data engines and generic APIs have been described above that allow flexible communication with a variety of databases. Any method call may be handled by the generic API without recompilation at least in part because the data engine extracts specific method names from a payload. Additionally the payload may be formatted for any destination database type in accordance with data templates. Embodiments of data engines according to the present invention may provide functionality beyond the formatting of method calls however to include an auto generation functionality. The data engine itself may perform the auto generation functionality in some embodiments or a separate auto generation engine may be provided operating on a same or different processor than the data engine.

As known databases may contain various database specific objects that impart additional functionality to the database. An API specific to the database type has been traditionally required to access or utilize these database specific objects and a database administrator was typically required in prior systems to generate new objects in a target database. However an embodiment of an auto generation engine according to the present invention may generate data templates for any database object allowing their use by the data engine as described above. Additionally using embodiments of a data engine and auto generation engine such as the auto generation engine in objects may be automatically generated in a target database including tables procedures indices and triggers. In this manner new objects and entities can be supported without specific database administrator intervention.

To facilitate auto generation functionality one or more database templates for the implementation of commands in a target database are generated. These templates describing command implementations may be XML schemas and may be stored in the template memory in . Alternatively the templates may be stored in one or more target databases or other content management system. An embodiment of a method for creating a template for database commands is shown in . One or more commands are identified for implementation . Generally any command supported in an API may be manipulated according to the method of by analyzing the command identifying and retaining static content and replacing variables with placeholders. Accordingly to identify commands commands of interest are selected from a particular API. For example some database types such as Oracle support various APIs or versions of a database engine and some such as SQL support various language syntaxes. Generally any API and or syntax may be supported according to embodiments of the present invention. The particular commands identified may include for example create insert retrieve select update procedure trigger index function getmail sendmail and the like.

A template is then be generated . The template may be an XML schema including an element for each command identified. Any XML editor or other program may be used to generate the statement template such as Visual Studio XML Schema Editor or XMLSpy. Each command identified will be included as an element in the template. An example of a database template is shown in . A statement of the template includes a formatted command with placeholders for the variable information. The statement also includes a reference to one or more placeholder templates describing how to format information to replace the placeholder contained in the formatted command . The database template further includes a placeholder template . The placeholder template includes a format and a fieldmask which together will describe how to generate a string using input data to replace the placeholders in the formatted command . Although only one statement and placeholder template are shown in any number may be generated.

Once the template is generated including elements for each desired command and elements for each placeholder referring back to the template is included for placeholder formatting and then stored in a location accessible to the auto generation engine. The templates may be stored in the file system or in some embodiments in a database or a content management system. The templates will be used subsequently as described below to generate objects within various target databases.

Once templates are generated as described above and with reference to a processing engine such as the data engine may utilize the template to generate structures in a target database. By utilizing the templates a client or other transmitting entity can cause a structure or procedure to be stored in a database without requiring knowledge of the particular syntax necessary to create the structure or procedure in the database.

Operation of an auto generation engine is described with reference to and a detailed example of one embodiment is provided below. A payload is received . The payload is similar to data payloads described above and depicted in but contains different information. An example of a payload is shown in . The payload is an XML schema containing an entity name element and a plurality of attribute elements associated with the entity element . Each of the attribute elements may include one or more parameters. Although only one entity element is shown in the payload a number of elements may be included and each element may generally have any number of attributes.

Following a call into the generic API and the receipt of the payload an appropriate database template is loaded into memory. As described above with respect to the data engine and data templates an indication of the target database type may be received in a variety of ways for example by loading a web.config file or by inspecting SOAP headers. The template may be loaded from cache or if not in cache the template may be loaded from the file system or any other stored location including a statement template repository which may be the same or different than the template memory in . The auto generation engine prepares completed statements for execution by looping through the database template of . Placeholders in the formatted statement are replaced with information from the payload of as directed by the placeholder templates . Generally the format element of the placeholder template provides a format including any delimiting characters or other syntax. The fieldmask element specifies which parameters of the attributes from the payload of should be inserted into the format and in which order. Parameters from each of the attributes are formatted according to the placeholder template and replace the placeholder in the formatted statement . Once all placeholders are replaced and the statement is complete the statement is executed referring back to generating objects in the target database. The statement is executed in one embodiment by the processing capabilities of the target database. In another embodiment the auto generation engine executes the statements generating the objects in the target database. For example a table procedure email folder or PL SQL package may be stored in the target database in accordance with the executed statements. Once stored in the target database the objects may be populated called or otherwise used by any process including a data engine as described above.

A detailed example of operation of an embodiment of an auto generation engine is now described to aid understanding.

The above payload is designed to trigger the creation of a Provider entity in a target database. The attributes of the Provider entity are ProviderID ProviderName and ProviderDescription. Each attribute has a variety of associated parameters as listed in the payload.

The formatted statement is create table ut with various placeholders indicated between the brackets. The first 0 placeholder is replaced with the entity name Provider . The Attributes ID and TemplateID specifies how to process the attributes of the payload for insertion into the 1 placeholder. Here the TemplateID 0 will be used to process the attributes.

For each attribute this template will be used to format the attribute s parameters by replacing the placeholder in the format statement with the payload information corresponding to the fieldsmask indicator. In the example above for the ProviderID attribute this would result in ProviderID uniqueidentifier NOT NULL DEFAULT NEWID . A similar string is generated for each attribute and the collection of strings is used to replace the 1 value in the create table template statement above.

The placeholder 0 is replaced with the entity name from the payload Provider resulting in create procedure uspCreateProvider . Then the attributes ProviderID ProviderName ProviderDescription are processed according to TemplateID 1 as indicated by the Attributes ID line for insertion into the 1 placeholder. TemplateID 1 may include 

This results in a string being generated for each attribute in the payload as described above. For ProviderID the string would be ProviderID uniqueidentifier IN . The strings generated with each attribute are concatenated and inserted into the 1 placeholder. The next placeholder in the statement is processed according to Template ID 2 which may include 

The string generated for ProviderID would simply be ProviderID . The string generated for each attribute is concatenated and inserted into placeholder 2.

The string generated for the Provider attribute would be Provider . Again the strings for all the attributes are concatenated and inserted into the 3 placeholder. Ultimately after replacing all placeholders the overall statement created will be 

create procedure uspCreateProvider ProviderID unigueidenfifier IN ProviderName nvarchar 50 IN ProviderDescription nvarchar 255 IN AS INSERT INTO utProvider ProviderID ProviderName ProviderDescription VALUES Provider ProviderName ProviderDescription 

This statement can be executed to generate a procedure in a target database. This procedure may later be used by other engines or programs accessing the database. This alleviates the need for a database administrator to manually establish the procedure in the database. Once the information is passed to the API as a payload the auto generation engine automatically creates the appropriate procedure in an end database.

Embodiments of the present invention provide data handling platforms which may be included in system shown in including or running an embodiment of a data engine as described herein. The data engine may include one or more processors or other computational cores that process requests received from any type of client including clients and in . The clients may include for example a user through a user interface or some other process program or machine transmitting information to the data engine . Any of the requesting entities and may communicate with the data engine over any known means of communication wired or wireless electronic or optical. In some embodiments the sending entity may communicate with the data engine over http and utilize SOAP headers as described above. Embodiments of data engines described herein such as data engine may advantageously be implemented as a web service. Generally any programming language may be used including any language that supports the implementation of web services including but not limited to C VB.NET C and Java. Implementing the data engine as a web service allows any transmitting or receiving entity to communicate with the data engine easily in a well known scalable manner. The data engine is able to process incoming messages according to embodiments of methods described above with reference.

One instance of the data engine is sufficient in some embodiments to service any number of sending entity requests to any number of available databases. Three available databases and are shown in . Of course the number of clients databases and requests to be served is a function of the ultimate application of the system and speed of the processor s used by the data engine as well as the speed of the communication interfaces. Embodiments of the data engine may generally be implemented to interface with any system level software platforms including but not limited to Windows Linux and Java. Memory or other computer readable medium may be coupled to or form part of the data engine . The memory may contain the executable code causing the data engine to perform the various functions described herein. Further template memory stores data templates as described above. The template memory may be separate from the memory or they may be combined. A cache not shown may also be coupled to the data engine for storing loaded templates from the template memory although in some cases the cache may be included in the memory or the template memory itself.

As was described generally above with reference to the data engine may be part of a larger data handling platform in some embodiments with other portions of the data handling platform provided to communicate messages and take action on the data. To communicate with other components of the data handling platform the data block may be configured to publish messages to a shared message bus as will be described further below and may be subscribed to receive certain types of messages that may be published by other components or systems to a shared message bus. For example in some examples when the data block stores a new data item it may publish a message indicating that a new data item has been stored. Other systems or components that may need to take action based on that data item are subscribed to that type of message and may be so notified by a messaging block examples of which are described below.

Examples of a data block have been described above that may facilitate interaction with one or more database types in a generic manner. That is the data block provides the specific interaction with an end database. The client need not know or provide software code specific to the end database to be manipulated. Referring back to the data block may accordingly provide an interface between one or more of the clients for placing data into one or more of the data sources . One or more of the clients may want to communicate with one another such as by calling software procedures that one or more of the clients provides. As was generally described above a typical software approach to hard coding interactions between one or more of the clients may limit the ability of the system to change without requiring significant code rewrites. Accordingly a message broker capable of calling methods independent of the syntax of the end system called may be used. The messaging block may provide such a message broker functionality.

Event schemas are stored in a memory accessible to or part of the message bus . Each of the event schemas provides associated database infrastructure so messages received of the event type specified in the schema may be created and utilized by one or more publishers . Each of the event schemas may accordingly come to be associated with one or more of the publishers . The publishers are stored data structures representing a source of an event or message. So for example if the client will be sending messages to the message bus the client may establish one or more publishers . Publishers may be stored in the form of XML arrays to facilitate the use of SOAP in embodiments of the present invention. A publisher may be notified by the message bus of responses to the publishing of an event. Accordingly a uniform resource identifier URI or other mechanism for notifying a publisher may be stored.

Publishers may create a message by calling a publisher subscriber web service CreateEvent . The web service may be implemented by the messaging block . An entry may be made in a specific event table related to an event schema. A trigger on the event table inserts data into a notification table that may include a time dispatched. The message bus may include a router that polls for the notifications and ensures that messages are dispatched in a timely fashion.

Subscribers are data structures containing information about a destination of a message or event. Similarly to publishers each subscriber may include a uniform resource identifier URI or other mechanism for notifying a subscriber. For example the URI for a subscriber may be a web page where a subscriber manages a plurality of subscriptions. So for example a client interested in receiving messages from the message bus may establish one or more subscribers . Each of the subscribers may be subscribed to messages from one or more of the publishers . Subscribers may be stored in the form of XML arrays to facilitate the use of SOAP. Accordingly clients interested in passing messages to the message bus may establish one or more publishers capable of publishing events having a type corresponding to one or more of the event schemas . Clients interested in receiving messages from the message bus may establish one or more subscribers . A client may establish both publishers and subscribers to both send and receive messages.

To notify one or more subscribers a message bus router included in the message bus may call a notify function of an event notification web service. A notification URI may be overridden with a subscription URI for each event. In return subscribers may call an acknowledgement web service to acknowledge receiving the message.

A message received from a publisher may be stored at the message bus . The entire message may be stored or in some embodiments only events contained in the message are stored as will be described further below. The message bus determines where to send the message based on subscriptions . The subscriptions are data structures containing information about a subscription that may refer back to a subscriber and a type of message the subscriber is interested in receiving such as one or more of the event schemas . Other information such as a filtering mechanism may also be included in the subscriptions . The message bus may maintain the subscriptions . Individual subscriptions may be added or deleted without altering or interrupting the general functionality of the message bus . By adding a new subscription or altering a subscription stored in the subscriptions the message bus will begin to route messages differently without any of the code for the operation of the message bus having to be altered. By way of summary the message bus receives a messages stores at least part of the message consults the subscriptions to determine which subscribers are interested in messages of the type received and then generates notifications for the interested subscribers. Accordingly while clients may be affected by the content of messages they may pass messages only to and from the messaging block in embodiments of the invention and may not need to communicate with any other client directly. In some embodiments of the present invention clients may never communicate with other clients directly and all communication may be routed through the messaging block .

By storing messages or portions of messages at the message bus and verifying notifications the message bus may ensure that communication is accurate and continuous. Furthermore by storing the events scalability and fault tolerance of the system may be improved relative to a system where such information is not persisted. For example storing messages may prevent or reduce the incidence of lost messages due to a failure of communication with a particular client. Instead the message may be stored until it may be properly delivered. Publishers and subscribers may expose functionality corresponding to object methods as web services. Objects that access these methods may be shared across clients as similar objects expressed as serialized XML and translated to language specific objects as needed by clients.

Accordingly clients may communicate messages to the message bus . The messages may be SOAP messages in some embodiments. is a schematic illustration of a message according to an embodiment of the present invention. The message includes an event identifier . The event identifier specifies the type of event and may correspond to one of the event schemas of . The message further includes a decoder XML schema . The decoder XML schema indicates how to decode the message . That is when the message bus receives the message the message bus may decode the message in accordance with the decoder XML schema . The message further includes XML content . The XML content describes the event and may be wrapped in a CDATA section such that it may not be processed itself by the message bus . The generation and processing of messages includes the generation of XML schema content that may in some embodiments be analogous to the generation and processing of XML schema content described above with respect to the data block . The message further includes a publisher identifier that may include a URI corresponding to the publisher having posted the event. Messages and notifications sent by the message bus to client systems may have an analogous structure. In some embodiments messages may be encrypted so that only authorized subscribers or client may access messages. Generally any encryption methods may be used.

The messaging block may include an API that implements a variety of functionalities to maintain the publishers subscribers and subscriptions described above with reference to . For example an API implemented by the messaging block may include but is not limited to some or all of the following procedures CreatePublisher ReadPublisher DeletePublisher CreateSubscriber ReadSubscriber DeleteSubscriber CreateSubscription ReadSubscription DeleteSubscription and CreateEvent. In one example a user at a client may prepare an XML payload representing a publisher subscriber or subscription schema. The user then selects a function of the API such as CreatePublisher to operate on the XML payload. A simple user interface may be provided at the client system to facilitate this entry which may include a text box for entry of the XML payload and a plurality of buttons corresponding to each of the methods implemented by the API such as CreatePublisher. Once selected the API may de serialize the XML instance entered by the user into an appropriate object of a code type used by the messaging block such as but not limited to C . The API is again called using the generated object and appropriate objects for the messaging engine may be created. For example the API of the messaging block may then return an XML result of the call and update the XML payload with any specific object names and formatting used by the messaging block the message bus or both in processing the request represented by the XML payload. For example the XML payload may be processed by any of the methods implemented in the API to have the syntax usable by any type of messaging engine such as a BizTalk messaging engine. Because the API providing the object names and syntax is implemented by the messaging block the client system and need not be aware of the particular syntax or object names in order to establish a publisher subscriber or subscription. Detailed code examples of methods implemented by the API are provided below in the examples section. The examples are not intended to limit the use of the messaging engine to any particular software language database type or messaging system. Rather the examples illustrate how to implement the described functionality in one particular environment as an aid to understanding and appreciating how the methodology may also be extended to other environments software languages and messaging systems.

The messaging block may communicate with the data block for managing one or more data tables containing the notifications events publishers subscribers or subscriptions . That is in some examples the data block may be used to generate database tables for the events publishers subscribers subscriptions or combinations thereof. Recall as described generally above the data block may create and manipulate tables in an automatic manner based on stored templates. Accordingly templates may be stored particular to the storage use or both of the message block components shown in . In this manner stored software code used by the messaging block may be auto generated and stored by the data block using one or more stored templates. Similarly the data block may be used to generate or process messages published to or received on the messaging bus. For example with reference to the data engine may execute a message in an analogous manner to execution of a payload . That is in some examples all or a portion of the message may serve as a payload for the data block .

An example of a system utilizing an embodiment of the messaging block is shown in . An example of establishing an account will be described. In the system a variety of client systems make use of account information including an order management system that may record orders associated with an account a billing management system that may process billing and payment information associated with an account a customer management system that may process and record interactions associated with an account and a tracking management system that may track all messaging traffic for an entire enterprise. Each of the systems and may be co located or in disparate locations and may in some embodiments operate in part on a same computing device although different computing devices may be used. A user interacts with the system through a user interface . The user interface may be separate from the systems and as shown or may be an integral part of any or all of those systems. Further the user interface may indicate an interface with an actual user system administrator or with a computer process that serves as the user as described. The user interface as well as the systems and are in communication with the messaging block .

As another example referring to a method for adding the billing management system to the system will be described. A publisher is created in the messaging block for the billing management system using a publisher schema. An event schema is created for each of the events of interest that may occur inside of the billing management system such as but not limited to change billing address add billing address update balance owed. One or more subscribers may be created for each of the created events. For example if the administrator is aware that the customer management system would like to subscribe to one or more of the events a subscriber may accordingly be created. For each subscriber a subscription may be created for implementing the delivery of a notification in the subscribing system. In some examples the billing management system itself may be modified for use in the system coupled to the messaging block . For example a processor or computer system implementing the billing management system may execute additional software including instructions to call a method CreateEvent and post an XML payload describing a billing change or other event. Existing software executed by the billing management system may be modified for this purpose by for example identifying locations in the software code executed by the billing management system where events may be posted. These code locations may then be modified to post events using the CreateEvent method.

In some examples it may not be desirable or possible to alter software code being executed by a system such as the billing management system . Accordingly in some embodiments messages may be generated by the billing management system in a manner that does not require altering software code being executed by the billing management system . For example the billing management system may be prior to interfacing with the messaging block coupled to a database for storing billing information or other data maintained by the billing management system . In one embodiment for integration with the messaging block a trigger may be added to the database that would post a change to the database into a message queue. The posting may be accomplished through for example a C Assembly loaded in the database engine running on the database or through a stored procedure in the database . Accordingly the software code executed by the billing management system itself may not require alteration. In other examples changes to the database may be stored in another database not shown another table or another file system. In still another example a web service call may be made that would post database changes directly to the message bus of the messaging block . In these examples a Windows service web service or other process called by the message bus may access the changes and create an event to be persisted on the message bus of the messaging block .

That is a generic Assembly may be prepared having a method accepting XML as input and includes code that when executed maps the XML into an event payload and pushes the payload to either a message queue or the message bus. The Assembly is deployed in the database . An administrator of the billing management system may then post changes to certain or all entities to the method call of the Assembly deployed in the database . In this manner an intermediary system may be placed between the billing management system the database or both that generates events corresponding to changes of the database . In this manner software code executed by the billing management system may not require alteration or recompilation.

The examples described above may still require some cooperation on the part of a system administrator for the billing management system even if the code itself may not require alteration or recompilation. In some examples however systems may be integrated with the messaging block without such cooperation. In particular a trigger may be generated in each table in the database corresponding to an entity of interest to the system . A generic assembly may be written having a method that accepts XML and maps the XML to an event payload and pushes the event to either a message queue in the database or the message bus of the messaging block . The assembly is then deployed in the database . The trigger previously generated in each table calls the assembly and method to generate the events. Then as above an intermediary between the messaging block and the database pushes the events onto the message bus of the messaging block . By using triggers in tables of the database no identification of entities of interest may be required within the billing management system .

In still other examples access may not be feasible for changes to either the billing management system or the database . Rather the billing management system may provide only a procedure allowing changes to entities to be obtained. To capture messages generated by the billing management system in this example a different approach may be used. A polling event schema may be created in the messaging block . A publisher for the polling event schema may be created in the messaging block corresponding to the message bus. A subscriber may be created in the messaging block corresponding to the polling event schema. A subscription may be created in the messaging block for the subscriber. The subscription may be a recurring subscription with a periodic renewal time such as five minutes. A web service endpoint may be created in the messaging block itself specifying the location of the subscription as an endpoint. The messaging block may call the procedure provided by the billing management system to receive changes. The changes may be processed into an appropriate XML event and posted to the message bus.

In use a user may create an XML payload corresponding to account information. The XML payload may be created in any suitable manner such as by utilizing a web application containing all fields of an account or a wizard that may collect information for an account. Other methods may be used in other embodiments. The user s system may then pass a message including the XML payload and an indicator that the message corresponds to an account event to the messaging block . The messaging block may then query the subscriptions and identify subscribers to account events and generate notifications for the subscribers. Should a new system be added to the implementation of and the new system also function to utilize account information the new system may also receive notification of account events by creating a corresponding subscriber entity and subscription with the messaging block .

Accordingly embodiments of messaging blocks according to the present invention may provide a publish and subscribe engine that may allow systems to access information generated by other systems in a generic manner independent of system type. Indeed neither the system generating the message nor the systems receiving the message may need to know anything about the type or style of the originating or destination system. Instead the communication is facilitated by the messaging block allowing systems to be added removed or changed in a flexible manner that may not require altering or re compiling the software code that operates the messaging block itself. The messaging block may also facilitate communication within the platform . The data block and rule block may subscribe to and publish messages on the message bus. Referring back to any of the other components resident in the intelligence layer adaptive layer or core layer may also publish message on and receive notifications from the message bus. In this manner the messaging block serves as a mediator of communications for the platform .

Referring back to examples of the data block and the messaging block have been described above. Briefly the data block facilitates data storage and interaction with data sources in a generic manner. The messaging block facilitates message passing between one or more of the clients in a generic manner. Accordingly the platform provides a flexible system for managing interactions between and among the clients and the data sources . It may be desirable to act upon the data gathered and stored by the platform also in a generic manner. Accordingly the rule block may be provided to evaluate rules dynamically through message passing.

An example of operation of the rule block will be described with reference to . One or more rules such as the rule may be maintained by the client . An XML document describing the rules is communicated to the rule block . Rule schemas described by the XML document may be defined during run time or at start up. In some examples rules may be inferred. That is a rule may be generated in an automated fashion based on interactions or data available to the platform. For example rules may be inferred based on an entity s interaction with different computing devices. Rules may also be inferred based on contextual information about an interaction. For example if an entity sets a room temperature to seventy degrees at a certain time while the outside light was at a certain level a rule may be inferred and stored with the rule block that if it is a certain time and the outside light it at a certain level an action to set the inner temperature to seventy degrees should be taken. Other types of rules may be inferred using other information available to the platform.

As with other blocks described above communication with the rule block may occur through SOAP messaging to a Web service implemented by the rule block . The XML document generally will include an if then statement. The if statement may specify a condition while the then statement may specify an action to be taken on satisfaction of the condition. The statements may reference data stored in one or more locations accessible to the rule block . Accordingly the rule block may access one or more data stores to retrieve information used to evaluate the if and then statements contained in the XML document. Accordingly the rule block evaluates the condition contained in the XML document and executes the then clause if the condition is satisfied. Results of the rule evaluation may be returned to the client. In this manner rules may be independently maintained by the clients and changed at any time. A variety of functionalities may be provided by the rule block including but not limited to handling functions with an unknown number of parameters predefined trigonometric and logarithmic functions user defined custom functions variable values resolved using a callback delegate expressions which may contain string literals where variable values and function return values can be strings arithmetic operators such as Boolean operators such as 

In this manner the rule block may provide an engine for in memory evaluation of a rule. Software applications of any nature may post requests to the rule block to evaluate rules and return results of the evaluation. In this manner the requesting application may not need to hard code rules and structure inside of their own applications. Accordingly users may change the rules as needs and purposes change and the applications are decoupled from the rule changes.

The rule block may communicate with the messaging block and subscribe to or publish messages to the message bus. On receipt of messages of interest the rule block may take a specified action as described above and a result of a rule evaluation may be to publish a certain type of message back to the message bus such that other systems may be notified of the action.

Accordingly embodiments of the platform shown in may be used to implement a rules based system dealing with substantially any kind of content. The specifics of the contents including attributes and methods of particular objects publishers and subscribers are provided by the clients while programming specifics concerning software code syntax and database particulars are provided by the platform . In this manner the platform may be used to process data and rules and mediate messages in any of a variety of systems and maybe put to any use. As an example an application is described below for processing charity pledges made by individuals using mobile devices. This application is provided by way of example only and it is to be understood that the platform may be used in the service of virtually any end application.

Referring now to a system is shown for processing charity pledges using an example of the platform . While charity pledges are given as an example the system may generally be used to manage any type of SMS campaign. A pledge database is coupled to the data block for storing pledge information including but not limited to email contact information mobile phone numbers and pledge amounts. By utilizing the data block to interface with the pledge database the pledge database may be changed without requiring any changes in software run by mobile contributors or the SMS gateway as generally described above.

An SMS gateway may be established as a publisher with the messaging block . The messaging block may for example expose a web service to the SMS gateway . In some embodiments an SMS message preparation block may be provided to format text messages received from the SMS gateway into messages suitable for the messaging block as generally described above. Any number of other subscribers may also be registered with the messaging block . A user may utilize a mobile device to transmit a text message containing an amount of a pledge they wish to make to the SMS gateway . The mobile device may take substantially any form including but not limited to a cell phone or a digital assistant. Other devices which may not be mobile may also be used including a kiosk a POS terminal a set top box or other devices. The mobile device may also be utilized to text a help command to the SMS gateway as may be required by an SMS aggregator for the use of an SMS system in some examples. An owner of an SMS short code used to address text messages may be required to respond to such a help message with instructions. Accordingly the platform may be able to distinguish between a pledge message containing a pledge amount and a help message requiring an instructional response. While a text messaging example has been described the client device may communicate using other mechanisms for example a pledge may be initiated through a web browser on the client device an email message another mobile web application or through a native application on the client device.

An incoming communication such as a text message sent from the mobile device may be received by the SMS gateway and packaged into a message suitable for the messaging block by the SMS message preparation block . In other embodiments the SMS gateway itself may be configured to package the text message into a message suitable for the messaging block . The resulting message generated by the SMS message preparation block may be passed to the messaging block and stored for example using the data block . The data block may communicate information such as pledge amounts mobile device IDs and phone numbers to the pledge database . The storage of data using the data block may cause the data block to publish a message to a message bus of the messaging block . So for example the data block may publish a message indicative of a new message received event onto the message bus. The rule block may be subscribed to new message received events and may accordingly receive the message. The rule block may be configured to examine the message stored in the data block and take one of two actions 1 publish a pledge confirmation event to the message bus or 2 publish a help message event to the message bus depending on whether the message stored in the data block was a pledge or help message. Other actions may be taken by the rule block in other embodiments.

A pledge confirmation system may be subscribed to pledge confirmation events and receive a pledge confirmation message published to the message bus by the rule block . On receipt of the pledge confirmation message the pledge confirmation system may be configured to for example email a confirmation message to the entity who originated the pledge.

A help processing system may be subscribed to help message events and on receipt of a help message event the help processing system may take action by sending a text message containing requisite instructions to a mobile phone ID associated with the event.

While SMS is used in this example the mobile device may also run a mobile web application for pledging. The mobile web application may record a pledge amount and an associated mobile device ID such as a phone number or any other identifier of a user pledging such as an email address. Other information may be captured in other embodiments.

Embodiments of a platform according to the present invention may also be used to implement a point of sale system an example of which is shown in . A client device may be used to initiate a request to place an order or publish content or data. The client device may be any of a variety of electronic devices including but not limited to a cell phone kiosk or a point of sale terminal which may include payment capability such as a credit card reader or more generally any device with an Internet browser or messaging capability. The client device may be mobile or fixed. An application operating on the client device may be used to indicate what type of purchase is desired. For example a user at a concert or other event may indicate they are interested in purchasing a concession by for example selecting a concessions link or application on the client device .

Responsive to the indication the user is interested in concessions an application on the client device may communicate with the messaging block by for example calling a web service exposed by the messaging block to publish a looking for concessions message on the message bus. In some embodiments the client device may communicate with a gateway or other communication hub that in turn communicates with the messaging block as shown in . In some embodiments a message preparation block may be used to format messages from the gateway or other communication hub for the messaging block . That is an application operating on the client device or gateway may be registered as a publisher with the messaging block and may publish an event corresponding to a user indicating a desire for concessions. The messaging block may accordingly identify subscribers to that type of message as generally described above. In some examples a message preparation block may be used between the gateway or other communication hub and the messaging block to format a message in a suitable manner for the messaging block .

A concession manager application may be registered as a subscriber with the messaging block and may have a subscription to looking for concessions messages. Accordingly when the messaging block publishes such a message the concession manager may be notified. The concession manager may access a concession inventory accessible at a location where the user indicated his desire for concessions. The data block may facilitate data access and storage to the concession inventory . The concession manager or the data block may publish a message to the message bus containing information about the types sizes promotions and other data pertaining to the concessions.

A profile manager application may also be registered as a subscriber with the messaging block and may also have a subscription to looking for concessions messages. Responsive to such a message the profile manager may utilize the data block to access profile storage to access concession related preferences of a user issuing the request for concessions. The profile manager or data block may then publish a message to the message bus containing the user s concession related preferences.

The rule block may be subscribed to the concession availability messages and the profile messages published by the concession manager and the profile manager respectively. The messages may contain metadata indicating they are responsive to the same initial request from a user. Accordingly on receipt of both messages at the rule block the rule block may evaluate which of the concession items satisfy the concession preferences. For example if one concession preference is for large sizes the rule block may return all available concessions that are of size large or bigger. The rule block may then publish a message to the message bus containing preference matched concessions.

The gateway or other communication hub or both may be subscribed to the preference matched concession messages and may then communicate with the client device to display the choices specified by the preference matched concession messages.

A user may then make a selection at the client device from among the preference matched concession choices. The selection is communicated to the gateway or other communication hub or both that may publish an order event to the message bus. Although not shown in an ordering system and a payment system may be subscribed to the order messages and receive notification of the order.

Although an gateway and message preparation block are shown in in other examples a different interface may be provided to the platform such as a web interface or kiosk connection. The type of interface implemented will depend in part on the type of client device used. The platform may have more than one interface to accommodate a variety of client device types. Generally any number of communication hubs may be present and any number of client devices may communicate with each hub.

Referring again to in some examples the client device may be mobile. As a user enters a location such as a store they may be recognized by their client device for example through use of an RFID tag on the client device and a tag reader positioned at the location or by bluetooth communications. In some examples other positioning technologies may be used such as GPS cell tower triangulation WiFi based positioning or combinations thereof. The detection of the user may be an event that is communicated to the message bus of the platform . An identification of the user the client device or both may also be published to the message bus.

The concession manager system may be subscribed to detected user events and may be notified of the user s presence at a location. Using methods as described generally above the platform may then notify the client device of available concessions or other items at the location which match preferences of the user. The notification may proceed through generally any manner including but not limited to SMS email message notification in an application on the mobile device or combinations thereof. In this manner a retail location may interact with the platform to notify incoming potential customers of items that match one or more of the potential customer s preferences. The system remains sufficiently robust that operation may continue if the retail location s database changes or migrates to a new data format.

From the foregoing it will be appreciated that although specific embodiments of the invention have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention.

The following is an example of a code excerpt implementing a portion of a data engine generic API. The code is commented to describe what each portion accomplishes. The example is not intended to be limiting other methods parameter types values databases and languages may be supported in other examples.

In Example 1 the example API made use of the function CreateDbCommand. An example of an implementation of this command is 

  dbProvider is used to create the command. The Factory object  dbProvider once properly constructed knows how to instantiate the appropriate ADO.NET objects specific to each DataProvider. The  dbProvider object can be initialized with reference to the constructor of the Web Service 

 The providerName is a String in the configuration file. Examples of such a string are System.Data.SqlClient or System.Data.OracleClient. Once we get an instance of the Provider Factory object we can use it to create on the fly appropriate ADO.NET object for any Data Provider.

An example of functions of a data engine generic API according to the present invention are shown below. Functions to manage entities in target databases may be implemented using the ExecuteSP function described in Example 1. Specifically in this example four functions for managing an entity are implemented CreateEntity ReadEntity UpdateEntity and DeleteEntity. CreateEntity is implemented as follows 

Similarly the other functions of the API are ExecuteSP DataReader ExecuteSP DataSet ExecuteSP None ExecuteSP Scalar They all are implemented by passing in appropriate parameters into the same function ExecuteSP. For example ExecuteSP DataReader is implemented as 

If you look back at the signature of the function ExecuteSP you can see that it has a very flexible signature that allows us to serve any type of request from the previously presented functions 

Entity represents the XML string passed into the API SPSuffix represents a string that gets prepended to the passed in Stored Procedure Name. For example in the case of the CRUD functions presented previously the Create Read Update and Delete suffixes can be prepended to the Stored Procedure name. In this manner an Entity with the same XML payloads as we showed previously as the Person Entity can be managed. The third parameter allows different types of returned objects from the API.

Examples of methods provided by an API implemented by the messaging engine are provided below. In particular the methods below are an example of software code used to implement CreatePublisher ReadPublisher DeletePublisher ReadSubscription and CreateEvent for operation with a BizTalk message bus. While BizTalk is used here as an example any messaging system including a custom system may be used and appropriate software code drafted using the particularities of the message system.

The function of the CreatePublisher method is to create a publisher using specific BizTalk objects. Basically creation of a publisher in BizTalk may include creating a ReceivePort with a same name as the Publisher creating a ReceiveLocation associated with the ReceivePort having a same Name TransportType ReceivePipeline and LocationURI of the Publisher creating a SendPortGroup having a same Name and Filter as the Publisher.

This method creates a Publishers array checks the PublisherName passed in for an empty name returns publishers identified by that Name allocates an array of Publisher objects when the PublisherName is empty and adds publishers emitted by the BizTalk catalog object to the empty PublisherName. The ReadPublisher method uses a GetPublisher method to implement a search for a given Publisher by looking up the BizTalk object model starting with a ReceivePort object. An example of code used to implement GetPublisher is 

The ReadSubscription method builds an array with all subscriptions in the system when there is no given PublisherName and no given SubscriberName as part of the incoming Subscription parameter. A total number of SendPortGroups in the BizTalk database is retrieved and array of Subscriptions objects of that size allocated. A list of associated SendPorts is retrieved for each SendPortGroup. For each SendPort a Subscription object is created. The Subscription PublisherName is set to the SendPortGroup Name. The Subscription SubscriberName is set to the current SendPort Name in the iteration. The Subscription object is attached to the array of Subscriptions that will be returned.

The CreateEvent method may allow clients to push an Event on a message bus. The above implementation reflects a case when a Publisher pushes events by copying an XML payload into a folder on a target machine. Other implementations may also be used. Generally messages may be written by any mechanism to a Receive Port s location from where the message bus may pick the messages up and process them. The mechanism used to push a file into the Location of a Receive Port may include but is not limited to manually copying the files an http post or having an application create files in a specific location.

The CreateEvent method above generally gets meta data associated with the Publishers of the Name passed in. For a zero length PublisherName all Publisher objects are obtained. For a given PublisherName a specific Publisher is obtained. For each Publisher object returned the TransportType and URL of the Publisher is obtained. A file is created with a name having a unique identifier. The Content field of the passed in Event object is written to the file and the file is closed.

