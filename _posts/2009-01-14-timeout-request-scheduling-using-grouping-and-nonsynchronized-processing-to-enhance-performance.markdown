---

title: Timeout request scheduling using grouping and nonsynchronized processing to enhance performance
abstract: An invention is disclosed for a computer software timeout algorithm that reduces the amount of list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests to determine whether the expiration time has been reached for execution of an input/output (I/O) request, thereby requiring action to cancel the I/O operation if it has not yet been completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707464&OS=07707464&RS=07707464
owner: International Business Machines Corporation
number: 07707464
owner_city: Armonk
owner_country: US
publication_date: 20090114
---
This application is a continuation of and claims priority to and claims the benefit of U.S. patent application Ser. No. 11 465 797 titled TIMEOUT REQUEST SCHEDULING USING GROUPING AND NONSYNCHRONIZED PROCESSING TO ENHANCE PERFORMANCE which was filed in the U.S. Patent and Trademark Office on Aug. 18 2006 and which is incorporated herein by reference in its entirety.

This invention relates to use of event completion style input output I O models in computer system or network applications and specifically to a computer software timeout algorithm that reduces the amount of list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests.

Input Output I O operations encompass all types of actions and communications between a computer and its users and or its processing storage or peripheral devices as well as with other system computers via a network such as a local area network LAN or a wide area network WAN or the Internet using a communications protocol such as Transmission Control Protocol over Internet Protocol TCP IP or the outside world including read operations where information is extracted from a stored location in a system or network device as well as write operations where information is stored in a system or network location and transfer operations where information is transmitted from one system or network location or device to another . I O event completion models are based upon use of application programming interfaces APIs that allow a software application to communicate with a computer or network operating system for the purpose of requesting performance of a particular I O operation. When such I O operations take place over a computer system or network I O read and or write or other requests are made by a user code or thread of the requesting application in order to send or retrieve data or instructions for the purpose of transmitting them from one system or network location or device to another.

System or network communication software often needs to provide timeout functionality for the reading and writing of data or instructions and other I O operations in order to allow the next I O request to be processed in the event that some system event or problem prevents processing of the current request. For example a read I O request will expire or timeout within a certain period of time often seconds if the read operation has not been completed by that time after a read API has been called by the user code to execute that request. Most of the time such an I O request will be completed within the required timeout period and the timeout will not be signaled to the calling code for execution. However problems can occur if the system or network is not optimized for performance in a way that prevents system processing resources from being unnecessarily used to schedule and cancel possible timeout actions. For example if 10 000 read requests are initiated during a 5 second time interval and each of them has a timeout that is scheduled to occur within 60 to 120 seconds after initiation of the request and each read is subsequently executed within 30 seconds after its initiation then the system resources that were used to schedule and subsequently cancel those timeout requests were wasted by being occupied with those requests instead of contributing to system processing activity or through put .

Most system or network timeout algorithms involve keeping track of when outstanding I O requests will timeout through use of a list that is periodically checked for example once per second to determine whether the timeout expiration time has been reached for a given request and if so a timeout action is taken to cancel the associated I O operation. The list is then accessed to remove a timeout entry when its I O operation has been timely completed so that it will not be errantly triggered. However the processing of such timeout lists causes a significant degradation in system performance since the list must be ordered according to the point in time when an entry will timeout due to expiration of its I O request requiring the list to be searched for the proper location to insert a new entry as well as for removal of an entry when it is no longer needed due to timely execution of the request . Such a list must also be periodically processed to find any active entry requiring a timeout action to be taken due to expiration of its I O operation without completion. Software synchronization logic is required to coordinate the timing of most of these types of list manipulation actions with a further resulting degradation in system processing performance.

An invention is disclosed for a computer software timeout algorithm program that reduces the amount of timeout list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests to determine whether the timeout period or expiration time has been reached for execution of an input output I O request thereby requiring a timeout action to cancel the I O operation if it has not yet been completed.

Specifically the timeout algorithm is comprised of software components programmed to execute at least the following functions 

It is therefore an object of the present invention to overcome the disadvantages of the prior art by providing improved use of event completion style input output I O models in computer system or network applications through disclosure of a computer software timeout algorithm program that reduces the amount of timeout list manipulation needed to satisfy system or network requirements for scheduling and cancelling timeout requests to determine whether the timeout period or expiration time has been reached for execution of an input output I O request thereby requiring a timeout action to cancel the I O operation if it has not yet been completed.

It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to execute a timeout action that is adjusted to take place at the nearest time interval after the exact time when it should occur for each I O operation to be executed by the system or network in order to allow individual timeout request entries to be chronologically grouped into a subset or timeout bucket of all entries having the same adjusted timeout time so as to allow processing of the timeout list to be accomplished through use of the buckets instead of individual entries by comparison of the system time to the timeout time for each bucket such that if the timeout time has been passed then a timeout action is initiated for an entry if it has not already been cancelled due to timely completion of its associated I O request.

It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to process individual timeout entries each having a data field or timeout status flag that can be set to schedule and subsequently reset to cancel a pending timeout action in order to eliminate the need for removal of an entry from a timeout list after its associated I O request has been timely executed.

It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to process an individual timeout entry that is initially stored in an unordered list or queue before being placed into a timeout bucket to be processed by the timeout algorithm wherein the queue is used by the algorithm code segment which processes the information contained in a timeout list and is programmed to enable a timeout request in the queue to be cancelled and discarded without action before being placed into a timeout bucket.

It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to inactivate the algorithm for a period of time to allow data processing to be accomplished instead of timeout processing.

It is another object of the present invention to overcome the disadvantages of the prior art by providing a timeout algorithm comprised of software components programmed to examine each timeout bucket periodically to determine whether all of its individual timeout entries have been cancelled.

The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention however together with further objects and advantages thereof may best be understood by reference to the following description taken in conjunction with the accompanying drawings.

As illustrated in input output I O event completion models are based upon use of application programming interfaces APIs that allow a software application to communicate with a computer operating system for the purpose of requesting performance of a particular I O operation . When such I O operations take place over a computer system or network I O read or write or other requests are made by a user code segment or thread of the requesting application sending such a request to an event completion code module for the purpose of transmitting data or instructions from one system or network location or device to another. The event completion code then responds by providing notification of completion to the user code after the I O request has been successfully processed.

This invention discloses a computer software timeout algorithm program that reduces the amount of timeout list manipulation and therefore processing resources needed to satisfy computer system or network requirements for scheduling and cancelling timeout requests to determine whether the timeout or expiration time has been reached for execution of an input output I O request thereby requiring a timeout action to cancel the I O operation if it has not yet been completed. As illustrated in the timeout algorithm program is preferably comprised of software components executed by a processor from a memory consisting of many TimeOutRequest objects along with many UserThreads and a TimeOutThread all programmed using conventional techniques to execute at least the functions described herein.

A UserThread is programmed to be executed by the processor to accomplish the following processing functions i a TimeOutRequest object is created when a timeout entry is originated upon initiation of an I O request event and then placed into an unordered queue event with its timeout status flag set to ACTIVE for a pending I O request ii a TimeOutRequest object is then invalidated by resetting its timeout status flag to CANCELLED when a timeout entry is no longer needed because its associated I O request has been timely completed or if its timeout period has expired and a timeout action has been invoked.

A TimeOutRequest object consists of definition of at least the following data fields for each individual timeout entry i a timeout time for which the timeout action will be invoked to cancel the read write or other I O operation if it has not been completed by then which can be the same length or duration for multiple timeout entries ii identifying a timeout action callback routine should execution of a timeout action event be required for that entry and iii setting a timeout status flag as ACTIVE for an individual timeout request if its associated I O request has not yet been executed and its timeout time has not yet been reached or CANCELLED if a timeout request is no longer valid due to timely completion of its I O request or expiration of its timeout period and the subsequent invocation of a timeout action.

A TimeOutThread processes the timeout buckets and timeout lists including the unordered queue and is programmed to be executed by the processor to accomplish the following processing functions in order to eliminate the need for these data structures to be protected by synchronization logic since they will be accessed by only this thread i an individual TimeOutRequest object is removed from the unordered queue and it is ignored if this timeout request has already been cancelled and this processing step is then revisited for the next TimeOutRequest object in the queue otherwise ii the point in time is calculated when that request should signal a timeout action by adding the unelapsed portion of the timeout period for that request to the initiation time of its associated I O request which can be the current chronological time and then adjusting the timeout action to take place at the nearest time interval or increment after that time such as by rounding up to the nearest second or multiple of 1024 .

The list of timeout buckets is then searched for one that has the same adjusted timeout time as the timeout request under examination from the unordered queue and if one is found then the request is inserted into that bucket from the unordered queue event otherwise a new bucket is created with this new timeout time and the timeout request is assigned to that bucket which can hold either a fixed or varying number of entries . The list of timeout buckets is ordered from lowest soonest upcoming timeout time to highest most distant future timeout time so that a new bucket is inserted at that point in the list after a bucket that has a lower and before a bucket that has a higher timeout time than its own so that each bucket represents the correct point in time for occurrence of the timeout with respect to each timeout request in that bucket. This processing step is then revisited for the next TimeOutRequest object in the queue and if there are no more timeout requests stored in the queue then the next processing step is executed.

The current chronological clock time is determined by the processor from the computer system and each timeout bucket is periodically retrieved for examination event according to its order from lowest timeout time to highest timeout time. The system chronological time is then compared to the timeout time for the next bucket. If the timeout time has been passed then each timeout entry in the bucket is examined and the TimeOutThread triggers the timeout callback routine to initiate a timeout action event for the entry if it has not already been cancelled due to timely completion of its associated I O request . It should be noted that the timeout callback routine must in some instances be synchronized with the timeout status flag to ensure that the I O operation is not being completed at essentially the same time when the timeout is detected. The timeout bucket is then discarded after examining each of its timeout entries in this manner. Once a bucket is encountered for which the timeout time has not been reached then no more buckets are examined through that cycle because each subsequent bucket will also have a timeout time that has not been reached. Therefore the next processing step will be executed. The pruning processing step is then executed after the last timeout bucket is examined using this step.

A dead bucket pruning time interval is defined to determine how often each timeout bucket list should be examined to decide if a bucket can be discarded. If this time interval has been triggered then each bucket is examined to determine whether all of its timeout entries have been invalidated. If at least one timeout entry is still ACTIVE then the next bucket is examined since all entries have not yet timed out for that bucket meaning that it cannot yet be discarded . If all entries in a timeout bucket have already been invalidated then its entries are discarded and the bucket is eliminated. The timeout algorithm 1 is inactivated for a certain period of time i.e. sleeps for a lazy interval to allow data processing to be accomplished instead of timeout processing. The timeout algorithm is then repeated in its entirety after expiration of this lazy sleep interval time period.

While certain preferred features of the invention have been shown by way of illustration many modifications and changes can be made that fall within the true spirit of the invention as embodied in the following claims which are to be interpreted as broadly as the law permits to cover the full scope of the invention including all equivalents thereto.

