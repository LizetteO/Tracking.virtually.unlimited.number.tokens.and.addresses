---

title: Static analysis framework for database applications
abstract: A tool facilitating static analysis for database applications, such that the static analysis tool (SAT) can significantly enhance the ability for developers to identify security, correctness and performance problems in database applications during the development phase of an application lifecycle. A static analysis tool for database applications presents a framework for database applications using the ADO.NET data access APIs. The SAT framework consists of a core set of static analysis services upon which verticals such as workload extraction, SQL injection detection, identifying data integrity violations, and SQL performance analysis are built using the core services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08452754&OS=08452754&RS=08452754
owner: Microsoft Corporation
number: 08452754
owner_city: Redmond
owner_country: US
publication_date: 20090508
---
Database application developers use integrated development environments IDEs to write database applications in programming languages such as C C Java from Sun Microsystems Inc. etc. Generally IDEs such as Microsoft Visual Studio provide tools to help developers develop debug and analyze applications during development. Often database applications are written to include data access application programming interfaces APIs to make SQL queries from the applications during execution. Examples of data access APIs for executing SQL statements include ADO.NET Open Database Connectivity ODBC and Java Database Connectivity JDBC .

However current IDEs fail to recognize interactions between applications in development and database management systems DBMSs . Additionally relational database management systems RDBMSs such as SQL Server from Microsoft currently may not recognize when an SQL query made during execution of a database application has been changed or is inconsistent with the application.

A method and system for leveraging data access APIs and database application binaries to provide a set of analysis services via a Static Analysis Tool SAT are described herein. The SAT provides a framework for analyzing database application binaries to automatically identify security correctness and performance problems in the database application via service tools and vertical tools.

In at least one embodiment the service tools of the SAT are provided on top of a compiler facilitating the vertical tools. In at least one embodiment the SAT framework supports analysis within a single basic code block across basic blocks within a function and across functions.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The same numbers are used throughout the disclosure and figures to reference like components and features.

A Static Analysis Tool SAT enables leveraging data access APIs and database application binaries to provide a set of analysis services for database applications. In another aspect the SAT provides a framework for analyzing database application binaries to automatically identify security correctness and performance problems in the database application via tools such as service tools and vertical tools.

Services enabled by the tools include extracting the set of SQL statements that may execute in an application identifying properties of the SQL statements such as tables and columns referenced extracting parameters used in the SQL queries and their binding to program variables extracting properties of how the SQL statement results are used in the application analyzing user input and their propagation to SQL statements. Verticals built using the above services enable detecting SQL injection vulnerability extracting the SQL workload from application binary identifying opportunities for SQL query performance optimizations and identifying potential data integrity violations.

An environment in which these tools may enable these and other techniques is set forth first below. This is followed by other sections describing various inventive techniques and exemplary embodiments of the tools. These sections describe exemplary ways in which the inventive tools enable analysis within a single basic block across basic blocks within a function and across functions.

Before describing the tools in detail the following discussion of an exemplary operating environment is provided to assist the reader in understanding at least one way in which various inventive aspects of the tools may be employed. The environment described below constitutes but one example and is not intended to limit application of the tools to any one particular operating environment. Other environments may be used without departing from the spirit and scope of the claimed subject matter.

Computer readable media can be any available media that can be accessed by a computing device such as computing devices and . Computer readable media includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media comprises computer storage media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device such as computing devices and .

Computing device may be one of a variety of computing devices such as a cell phone laptop computer desktop computer personal digital assistant or server. Each computing device having at least one processor capable of accessing and or executing instructions embodied on the computer readable media. The computing device may also include input output devices such as a keyboard mouse microphone printer monitor and speakers not shown useable to implement one or more embodiments of the tools described herein.

The operating environment also comprises one or more network s and computing device server s . The network enables communication between the computing device s and and can comprise a global or local wired or wireless network such as the Internet a local area network LAN or an intranet. Computer readable media of computing devices such as and comprises or has access to a browser which is a module program or other entity capable of interacting with a network enabled entity such as a server . In aspects of several embodiments server s may be implemented as a web server in a server farm and as content provider s providing content from a database upon which a query may be run and combinations thereof.

In some embodiments the operating environment may further comprise at least a second computing device having one or more processor s and computer readable media similar to computing device . Each computing device comprises a computing device similar to . The computing device s may be the same computing device as computing device or can be a separate or different computing device. Further computing devices and may host or otherwise access any number of databases e.g. database . . . N .

Aspects of computing devices such as computing devices in at least one embodiment include functionality for implementing the static analysis framework for database applications algorithm to implement the static analysis tool SAT individually or encompassing a compiler functionality . For example as shown from server program modules may be implemented as computer readable instructions various data structures and so forth via at least one processing unit to configure a computer having system memory to apply the SAT with compiler functionality within a single basic block across basic blocks within a function and across functions as discussed regarding below. In several embodiments input to the SAT is made up of application binaries e.g. .exe or .dll files and a database. In at least one embodiment this input is received via network and in some embodiments the input may be received via a commonly hosted or otherwise accessed database such as .

Although the subject matter is described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts or to the structural proximity or sequences described herein. Rather the specific features and acts described are disclosed as exemplary forms of implementing the claims.

The following discussion describes an exemplary architecture by which the SAT improves analysis of characteristics such as security performance and correctness of database application binaries still in development. Code Example 1 below presents an example portion of application source code for a C application allowing a user to search a product catalog. In this example the application retrieves rows from a table in a database that contains the user submitted string.

The SAT is made up of a layer of static analysis service tools for database applications services and a layer of vertical tools verticals for database applications. In at least one embodiment verticals are built using services and enable extracting the SQL workload from application binary detecting SQL injection vulnerability identifying opportunities for SQL query performance optimizations and identifying potential data integrity violations.

Workload extraction provides a vertical that identifies during application development time the set of SQL statements that can be executed by the application undergoing development. For example when migrating an application from one DBMS to another or from one release of a DBMS to the next release of the DBMS identifying SQL statements issued by the application is important since some statements may need to be modified to adhere to the syntax and restrictions of the target DBMS. Another example of workload extraction is physical design tuning. While today s DBMSs have tools for tuning physical design that take as input a workload and recommend an appropriate physical design extracting a workload from an application binary facilitates improved initial physical design for the database. This enables less costly refinement after the application is deployed.

Because query strings may be constructed across multiple functions extraction of the workload can be non trivial for arbitrary database applications. In the code sample presented in Code Example 1 two possible SQL queries can execute at Line 5 the second query is executed if SortRows in Line 3 returns TRUE.

In the above example the workload was a set of SQL statements. It can also be useful to extract sequences of SQL statements e.g. a sequence such as CREATE TABLE T INSERT INTO T . . . SELECT . . . FROM S T WHERE . . . DROP TABLE T. Capturing such a sequence from a database application binary enables invoking a tool that can tune a sequence of statements.

SQL injection detection provides a vertical that identifies during application development time SQL injection vulnerability in the application undergoing development by examining the application binary.

In the example sample of application code presented in Code Example 1 above the application retrieves rows from a table in a database that contains the user submitted string. In the function onLookupButtonClick the user input is read from an Edit Box control. In turn the LookupProduct function is invoked. The LookupProduct function does the actual lookup in a Products table using a dynamically constructed SQL query. The query is executed using the ExecuteReader method of the SqlCommand object.

If the user submits a string such as Microsoft Office 2007 then the following query string is constructed at Line 1 in the LookupProduct function.

Thus the original intent of the query would be modified due to the concatenation of user input. As a result when the query is executed on Line 5 this has the undesirable effects of first returning all rows in the Products table to the user and then dropping the table.

As the example above illustrates catching an SQL injection vulnerability is important. Tools such as SAT also need to not return an excessive number of false positives. For example many application developers correctly use the ADO.NET APIs for passing user input as a parameter to a SQL query e.g. AddParameter method . In such cases the SQL injection detection vertical detects that there is no injection vulnerability since the DBMS cannot interpret the user input as code.

Integrity checking provides a vertical that identifies during application development time database integrity constraints in the application undergoing development by examining the application binary. Database integrity constraints may be enforced in the application layer and not the database layer to avoid operational disruptions since it is often easier to deploy a modified application module. For example in hosted web service scenarios the cost of altering an existing table may be more than deploying the modified application module.

Another example relates to performance cost where integrity constraint checking in DBMSs can be expensive. For example if the application developer wants to enforce in the application code the constraint that the price column of the Products table always has a value 0 Code Example 2 may be used.

Given a constraint such as DBName . Products . price 0 as input integrity checking vertical enables automatically identifying all places in the application code where the price column can potentially be updated and enables adding an assertion at such places in the code. For example in the above code section integrity checking vertical would automatically recommend inserting the code Assert myprice 0 before Line 3 to validate the given data integrity constraint DBName . Products . price 0. In order to provide such a recommendation SAT via integrity checking vertical determines that a data manipulation language DML statement affecting the price column is occurring in the application code and identifies the program variable expression that is bound to the price column in the DML statement. below represents a screenshot produced by the SAT after analysis is complete.

SQL Performance Analysis provides a vertical that identifies during application development time opportunities for improved query performance in the application undergoing development by examining the application binary and alerting the developer of the ability to improve performance. For example code such as shown in Code Example 3 below may include queried columns that are not consumed.

Although there are three projection columns in the query sku price and description the application references only two sku and price when consuming the query results. Thus in this example SAT via SQL Performance Analysis vertical detects this and alerts the developer so that the query performance can be improved by rewriting the query as select sku price from Products .

Other functionality is contemplated as a part of the illustrated verticals or via similar individual verticals of SAT . For example a development manager for an application may want to enforce a set of best practices in coding for all developers in the project. Such a best practices vertical may be implemented as part of or as a combination of integrity checking SQL performance analysis or others of the illustrated verticals alternately a separate best practices vertical not shown could be implemented as a part of verticals . The following illustrate examples that could be included in such a best practices vertical.

Such verticals of the SAT leverage understanding of the data access APIs e.g. SQLCommand.ExecuteReader is an API through which a query is executed in ADO.NET .

In addition the SAT for some of the examples may implement a deeper analysis via access to the database schema SQL parser and the query optimizer of the DBMS. One such example occurs when rewriting of the query is recommended. In order to quantify the estimated improvement in performance by such a rewriting a query optimizer may be used to obtain the execution plan of the original and rewritten queries.

Verticals have significant commonality. For example the need to extract the SQL statements that can execute at a particular ExecuteReader call in a program is common to both Workload Extraction and SQL Performance Analysis . Similarly identifying properties of the SQL such as which columns are referenced is important in Workload Extraction and Integrity Checking . Thus Services comprises a library of services for database applications utilized to develop Verticals . In at least one embodiment Services is built on top of a compiler framework . Services of the exemplary SAT comprises five services of use in implementing verticals .

Extract SQL during application development time provides a service that given a function in the program binary returns a set of SQL statement handles. A handle is a unique identifier that is a line number ordinal pair in that function. The handle represents a SQL statement that can execute at that line number. Referring to the LookupProduct function in Code Example 1 above Extract SQL returns two handles e.g. 5 1 5 2 corresponding to the two statements that can execute at line number 5 the ExecuteReader invocation in the function .

The Extract SQL service may be configured to extract a specified portion of the SQL that may be executed by the application. For example when the table names in the query are generated dynamically the strings extracted by static analysis will not be syntactically valid SQL statements due to their dynamic nature. Another example is the presence of an IN clause in the query where the values in the IN clause are generated inside a loop in the program. However in real world database applications a large fraction of the SQL executable by the application may be extracted by static analysis alone.

During the application development time Identify SQL Properties provides a service that given a handle to a SQL statement returns properties of the SQL statement. In at least one embodiment Identify SQL Properties identifies the following properties 1 the SQL string itself 2 number and database types of columns in the result of the SQL statement for SELECT statements 3 tables and columns referenced in the statement and 4 optimizer estimated cost of statement. Identify SQL Properties identifies 2 3 and 4 above via access to the database schema an SQL parser and obtaining the execution plan for a given SQL statement. In at least one embodiment when extracted SQL indicates a derived property Identify SQL Properties derives the property.

In at least one embodiment Identify SQL Properties may obtain the database connection to use when accessing the database in multiple ways in a variety of embodiments. Examples of ways Identify SQL Properties obtains a database connection to use when accessing the database include from a configuration file automatically by Identify SQL Properties analyzing the connection string used in the application and via user input.

Extract Parameters during application development time provides a service that given a handle to a SQL statement returns the parameters of the statement along with the program variable expression that is bound to the respective parameter and the program variable expression data type in the application. For example referring to Integrity Checking the Extract Parameters service returns price myprice double sku mysku int description mydescription String .

Extract Result Usage during application development time provides a service that given a handle to a SQL statement returns properties of how a result set is consumed in the application. In particular Extract Result Usage returns each column in the result set that is bound to a variable in the program along with the type of the bound program variable. Referring to SQL Performance Analysis the Extract Result Usage service returns 0 s int 1 p double assuming the types of variables s and p are int and double respectively.

Analyze User Input during application development time provides a service that given a handle to a SQL statement identifies all user inputs in the program such that the user input value v satisfies a contributes to relationship to the SQL string of the statement. A contributes to relationship is defined as either a v is concatenated into the SQL string or b v is passed into a function whose results are concatenated into the SQL string in at least one embodiment.

The following discussion of describes an exemplary overview operation of at least one embodiment of the static analysis framework for database applications. The discussion references elements discussed above regarding . This implementation takes as input an application binary e.g. a DLL or EXE and database domain information e.g. a database schema data access APIs ADO.NET etc. and at performs custom static analysis on the binary via the SAT . In this example output is a set of security performance and correctness problems as identified by the vertical tools . For certain verticals e.g. identifying potential violations of data integrity constraints the user can specify a set of constraints e.g. Products.Price 0 as user input e.g. constraints functions etc. illustrated at . Also based on user input static analysis on the binary at via the SAT may be customized to analyze one or more functions up to all of the function units in the binary.

The exemplary implementation illustrated relies upon a compiler framework to build out the SAT services and verticals to perform static analysis on the binary of the database application at . In at least one other implementation the SAT services and verticals may be implemented independently from compiler framework to perform static analysis on the binary of the database application at .

In the illustrated example compiler framework converts the application binary in Microsoft Intermediate Language MSIL illustrated at into an intermediate representation IR upon which the the SAT operates to perform static analysis at .

In one aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at iterates over function unit s within the binary. In at least one implementation the iteration is based at least in part on user input although in other implementations no user input need be involved. In another aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at effects data and control flow analysis . In yet another aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at iterates over individual instructions in the IR within a basic block. In still another aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at provides extensions to dynamically extend the framework types like function units and basic blocks. In yet another aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at provides a flow graph in order to iterate over basic blocks within a function unit. In yet another aspect of the example compiler framework via the SAT services and verticals performance of static analysis on the binary of the database application at provides a call graph that represents the control flow across function units. For example referring to Code Example 1 above when there is a call to function LookupProduct from the function onLookupButtonClick at Line number 2.

An example of intermediate representation IR instructions for the function onLookupButtonClick follows as Code Example 4.

In at least one embodiment data structure and control flow analysis for a single basic block for example also referred to as a block is performed via the following operations. Each block represents a sequence of IR instructions. The control flow of the program enters a block at its first instruction and proceeds sequentially through the instructions in the block until it reaches the block s last instruction. The IR instructions corresponding to the function onLookupButtonClick is shown in the code snippet above. Each IR instruction can be mapped into destination operand opcode and source operands. In the example above for the second instruction the destination operand is tv273 the opcode is CALLVIRT and the source operands are System.Windows.Forms.Control get Text and tv272.

SAT maintains a hash table as a data structure that at any point during the analysis captures the current values of the operands referenced in instructions in the basic block. For example as illustrated in at the hash table is created after executing the instructions above. Hash table has the destination operand as the key e.g. temporary variable tv273 in the example and associates the key with a data flow tree . The tree contains nodes that hold the operands and opcode. This may be understood as similar to algebraic expression trees. The leaf nodes are other operands or symbols while the non leaf nodes are the opcodes. When an assignment to an operand is encountered in the instruction stream e.g. ASSIGN IR the assignment results in replacing the current tree associated with the operand with the data flow tree of the source operand that was assigned. Data flow tree is flexible and may be constructed using a variety of algorithms. Examples of such algorithms may be found in A. Aho R. Sethi and J. Ullman. Compilers. Principles Techniques and Tools. Addison Wesley. 1986 .

In addition to the operand opcode information each node of the data flow tree also stores and propagates information for static analysis services . Examples of such information include symbols that are referenced by the node line number associated with the node whether the node is an ADO.NET object e.g. SQLConnection SQLCommand SQLDataReader and whether the node is part of a string concatenation operation.

By customizing what information is stored in each node SAT exposes each of the static analysis services . For example to expose the user input analysis service the operand symbol referenced in a user input function is tracked. This information is propagated through the data flow analysis and thus it enables SAT to track whether the given user input value can contribute to a SQL string issued at a call site.

SAT facilitates exploiting knowledge of data access APIs for data flow analysis. The static analysis services for database applications leverages database domain information including knowledge of data access APIs and the DBMS itself. For example upon encountering an instruction that calls the following ADO.NET API System.Data.SqlClient.SqlCommand ExecuteReader. SAT identifies ExecuteReader as an API for executing a SQL statement. SAT can also identify based on the signature of the API method that the first argument to the ExecuteReader is an SQLCommand object and thus is the second source operand in the instruction. SQLCommand objects have properties like the text of a command parameter list the active SQLConnection object etc. The data flow analysis described regarding a basic block above will give the current values of the various properties of the SQLCommand object including its text field. For example the text field of the SQLCommand object is the SQL string that is executed at the ExecuteReader instruction.

As a specific example the call to ExecuteReader Line 5 of LookupProduct method in Code Example 1 has the following IR representation 

Here tv306 is the destination operand CALLVIRT is the opcode and System.Data System.Data.SqlClient.SqlCommand ExecuteReader cmd are respectively the first and second source operands. Thus SAT is able to infer that the symbol cmd references an ADO.NET SQLCommand Object.

The data flow tree corresponding to the value of cmd in the hash table is shown in at . The data flow tree for the cmd symbol has a root at and two sub trees from nodes and . These sub trees correspond to the SQL text portion and the SQLConnection object portion of the SQLCommand constructor Line 2 of LookupProduct in Code Example 1 . The leaf nodes of the union at corresponding to the SQL text part captures the static parts of the SQL the embedded SQL strings and the dynamic part the searchstring argument . Hence by traversing union via nodes or and concatenating the leaf nodes of the appropriate branch i.e. or e.g. and or or and the SQL executed at this line number may be extracted. In the illustrated embodiment the subtree under newobj node represents a connection string which is not traversed.

In this example the two CALL nodes and that are children of the UNION node refer to string concatenation methods e.g. System.String Concat . In general applications can build SQL strings at different places in the code and concatenate the fragments to build the SQL that is executed. Thus SAT analyzes string concatenation API s to extract the set of strings that can be issued by the application at any call site. As another example for a statement such as cmd.CommandText a b where a and b are strings to build the tree for cmd.CommandText SAT would trace the CALL to the string concatenation function and concatenate the text contributed by the data flow trees for a and b.

In the illustrated example of the UNION node represents the case of the flow occurring over multiple paths e.g. an If Then Else statement and workload is extracted by concatenating the leaf nodes of the path. This is discussed in the context of global data flow analysis below. Although the example illustrates the SAT examining the ADO.NET API ExecuteReader SAT may also examine other ADO.NET APIs in an analogous manner. For example there are other APIs such as ExecuteNonQuery and ExecuteScalar where the application can potentially issue a SQL statement. As another example SAT also analyzes the various parameter collection APIs e.g. System.Data.SqlClient.SqlParameterCollection Add in the data client name space for extracting properties e.g. data types of program variables that are bound to parameters of the SQL statement.

Global data flow analysis extends the analysis to operands defined in other basic blocks in the same or another function. In the examples of single block analysis described thus far for any operand of interest it was assumed that its definition could be traced within the basic block. While this is true for temporary variables defined within the block itself certain operands e.g. the program symbol searchstring in the LookupProduct function may be defined in other basic blocks within the same or in a different function . The purpose of global data flow analysis is to enable tracking the definition of the operand of interest beyond the current basic block.

Global data flow analysis accounts for the plurality of control paths to a call site such as ExecuteReader. Building on that described for a single basic block in the discussion of and SAT first builds the data flow tree for operands within a basic block. If an operand cannot be resolved within the block a backward traversal to one or more predecessor blocks in the call graph is performed until the operand s definition is obtained from the hash table of that block. Code Example 5 below presents a pseudo code example algorithm for resolving an operand outside the current block.

An example algorithm for resolving an operand i.e. node is shown in Code Example 5 above. In this example SAT recursively iterates over each predecessor of the current block. Thus multiple resolutions one per path of the given operand N may occur. If multiple resolutions occur then a UNION node whose children represent the alternatives is used to represent the alternate paths. Note the predecessor block could be in the same or a different function unit the SAT applies the above algorithm to both cases. SAT assigns block id numbers to the blocks in depth first order so that the block id of the current node is always greater than its predecessor. This property allows the SAT to correctly deal with cycles caused by loops.

In at least one embodiment vertical tools introduced in are implemented on top of the functionality described referring to . For example SQL Injection Detection vertical is implemented to detect attacks that occur when unvalidated user input is used to build a SQL string which is then executed on the database server. The adversary injects malicious SQL code in user input that gets executed by the query in the server.

The SQL injection detection tool takes as input a set of function signatures that can supply user input to the program. For example this includes a function such as System.Windows.Forms.Control get Text. Vertical marks any destination operand in an instruction where the above function is a source operand as tainted . For example consider the follow IR instruction 

In the exemplary instruction above destination operand tv273 is assigned the return value of get Text and hence the node is marked UNSAFE. The data flow analysis outlined in the previous sections also propagates the safety attribute SAFE UNSAFE MAYBE UNSAFE from the source where the user input is read to the sink call site where the SQL is executed . Therefore in the case where user data is propagated to the SQL string without passing through any other functions the resulting SQL will also be reported as UNSAFE.

If the user input is passed into a function e.g. a validation function whose return value is propagated to the SQL string it is marked as MAYBE UNSAFE. If the user input is passed in as a parameter to the SQL using one of the ADO.NET APIs for passing parameters the SQL string is marked as SAFE. Note that the SQL that is executed and the sink line number are gathered by using the Extract SQL service . As described above given a handle to the SQL statement we use the Analyze User Input service to identify all user inputs in the program such that the user input value contributes to the SQL.

In typical applications it is common that code where the user data is read in and where the SQL is actually executed are in different functions. In these scenarios the ability of the SAT to perform inter function analysis is utilized to analyze the database application.

As another example Integrity Checking vertical is implemented to enforce data integrity checks in the application code rather than using database integrity checking functionality such as CHECK constraints. The vertical tool for detecting violations of data integrity constraints takes as input a set of constraints specified by the user. In at least one embodiment constraints of the form Database. Table. Column Op Value where Op is a comparison operator and Value is a literal are supported.

Each constraint expression input by the user is parsed to obtain the table and column on which the constraint is specified. During the data flow analysis discussed regarding above the vertical tool looks for INSERT or UPDATE statements on the object referenced in the input constraint expression. This is done by extracting the SQL statement for example using the Extract SQL service and parsing it to extract the table column information as well as statement type INSERT UPDATE Identify SQL Properties service . SAT also captures the association of the parameter name to the column in the INSERT UPDATE statement by analyzing the ADO.NET APIs for passing parameters to SQL Extract Parameters service . The ability of SAT to capture the association of the parameter name to the column in the database enables it to automatically recommend an assertion in the application code that will verify the data integrity constraint specified by the user. SAT provides the application developer such a recommendation and an assertion in the code for review.

As discussed regarding the SAT takes the application binary as input. The user also specifies a database constraint. In the example shown in the constraint shown is Products . Price 0 . illustrates a screenshot of a code sample for the example of detecting potential data integrity violation in the application code using integrity checking vertical introduced regarding . In this example the function button insertclick inserts a row to the Products table in a database. The constraint to be enforced by the application is that the Price column of the Products table is greater than 0 i.e. Products . Price 0.

The following discussion describes an exemplary overview a variety of implementations of at least one embodiment of the static analysis framework for database applications. The implementations for applications discussed are merely illustrative and not limiting. The discussion references elements discussed above regarding previous figures. The implementations discussed relate to operation of SAT on several real world database applications such as Microsoft s Conference Management Toolkit CMT SearchTogether and a security training application STA .

CMT is a web application sponsored by Microsoft Research that handles workflow for an academic conference available at http msrcmtresearch.microsoft.com cmt . SearchTogether is a Microsoft application that allows multiple users to collaborate on web search available at http research.microsoft.com en us um redmond projects searchtogether .STA is an internal Microsoft security training application developed by the security training group at Microsoft to demonstrate SQL injection vulnerability.

For each of the three exemplary applications evaluation of the Workload Extraction vertical is reported in Table 1 below. The methodology was to compare the workload extracted by SAT via vertical with the workload obtained by manual inspection of the application code. The summary of results is shown in Table 1.

The column Total SQL statements reports the number of that SQL statements manually identified by examining the source code of the application. The column SQL statements extracted refers to the number of statements that were extracted by SAT . Along with the SQL statements SAT extracted parameter information via Extract Parameter service as well. Thus even though actual parameter values are not known at compile time SAT is able to extract syntactically valid queries e.g. it is possible to obtain a query execution plan for such queries. Note the CMT and SearchTogether applications both mostly use parameterized stored procedures.

In at least one embodiment a select set of ADO.NET APIs are covered for example not all SQL strings were extracted by the SAT . In other embodiments different sets of ADO.NET APIs may be covered. It is to be understood that expansion to a variety of sets of ADO.NET APIs as well as Open Database Connectivity ODBC APIs and Java Database Connectivity JDBC APIs is expected to follow similar teachings and is considered within the scope of this document.

Furthermore in SearchTogether the SQLCommand object is a member variable of a class in some instances. The object is constructed in one method and referenced in another method. In this situation the global data flow analysis of the test implementation is not sufficient since the variable the SQLCommand object is not passed across the two methods. In another implementation this case would be captured by the SAT tracking an additional state of the SQLCommand object for example.

The SQL injection detection vertical of SAT was also run on the three applications. SAT detected no SQL injection vulnerabilities in CMT and SearchTogether. In these applications user input is bound to parameters and executed as parameterized SQL. In STA the security training application SAT identified the SQL injection vulnerabilities. shows a screenshot of SAT indicating the SQL injection vulnerability in one method. The left hand pane shows the functions in the binary. In the right hand pane the SQL Information grid shows the SQL string and the SQL injection status UNSAFE in this example . Grid also shows the actual line number in the code where the user input leading to this vulnerability originated and the line number where the SQL statement is executed.

For example computing device can represent one or more of the computing devices and computing device server operating in environment . And insofar as the computing device includes conventional computing hardware also represents functionality that can be used to implement other computer related aspects of the environment shown in such as equipment of server and individual computer devices and including processing units databases . . . program modules compiler functionality and so forth . The computing resources shown in can be implemented at a single site or distributed over plural sites.

The computing device in this example includes at least one processing unit and system memory . Depending on the configuration and type of computing device the system memory can be implemented as volatile memory such as RAM non volatile memory such as ROM flash memory etc. or some combination of the two. The system memory can include an operating system one or more program modules program data and so forth. In the context of the present subject matter the program modules can include A the functionality for implementing the SAT via services and verticals of . In at least one embodiment compiler functionality is implemented separately from the SAT Module and in at least one other embodiment the compiler is integrated with the SAT module. In general the program modules can be implemented as computer readable instructions various data structures and so forth that configure a computer to operate SAT . The computer readable instructions can be expressed using any programming technology. The instructions can also include markup language content e.g. XML .

The computing device can include additional features or functionality. For example the computing device can also include additional data storage devices such as removable storage e.g. magnetic disks magnetic tape optical disks static RAM devices and so forth and or non removable storage along with associated media reading writing functionality. Removable storage may include a variety of computer readable media.

The computing device can also include various input device s such as a keyboard a mouse a voice input device a touch input device and so on. The computing device can also include various output device s such as a display speakers printer and so on. Finally the computing device can also include a communication interface that allows the device to communicate with other computing devices over the network of . The communication interface can be implemented in any fashion such as broadband e.g. T1 interface a telephone modem interface a cable modem interface a DSL type interface and so forth. One or more bus structures not shown internally couple each of the above described modules together.

The above described tools systems and methods enable static analysis tools for database applications such that the SAT can significantly enhance the ability for developers to identify security correctness and performance problems in database applications during the development phase of an application lifecycle. This description of static analysis tools for database applications presents a framework for database applications using the ADO.NET data access APIs. The SAT framework consists of a core set of static analysis services. We have built verticals such as SQL injection detection workload extraction and identifying data integrity violations using these services and performed initial evaluation on real world database applications. These and other techniques described herein may provide significant improvements over the current state of the art by leveraging data access APIs and database application binaries to provide a set of analysis services via a Static Analysis Tool SAT . The SAT provides a framework for analyzing database application binaries to automatically identify security correctness and performance problems in the database application via service tools and vertical tools.

Although the system and method has been described in language specific to structural features and or methodological acts it is to be understood that the system and method defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed tools system and method.

