---

title: High volume earth observation image processing
abstract: The present invention is related to the processing of data, and more particularly to a method of and system for processing large volumes of Earth observation imagery data. A system for processing a large volume of Earth observation imaging data is described, comprising a computer including a visual display and a user interface, a plurality of servers, an image database storing said Earth observation imaging data as a plurality of separate image data files, and a network for interconnecting the computer, plurality of servers and image database. The plurality of servers is operable to process the separate data files in a distributed manner, at least one of the plurality of servers is operable to process the separate data files in a multiprocessing environment and at least one of the plurality of servers is operable to collate the processed separate data files into a single imaging result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08768104&OS=08768104&RS=08768104
owner: PCI Geomatics Enterprises Inc.
number: 08768104
owner_city: 
owner_country: CA
publication_date: 20090107
---
The present invention is related to the processing of data and more particularly to a method of and system for processing large volumes of Earth observation imagery data.

Earth observation imagery data has been collected and analysed for decades and is an essential part of many natural resource management geological and mineral exploration agricultural management environmental monitoring and aerial mapping systems to name just a few applications. Whether the data is obtained from satellite airborne sensing or other systems and whether it consists of all or a combination of photogrammetry hyperspectral multitemporal optical thermal and microwave and other similar systems data the problem with analysis is much the same large volumes of data must be processed quickly and accurately without distortion.

For example remote sensing has been a central tool for environmental management and monitoring at local regional and global scales. The need to monitor the habitat of endangered species predict flood patterns and evaluate the health of coral reef environments has never been more acute. To address the increasingly complex web of influences on our ecosystems today s environmental stakeholders are demanding current information new analysis techniques and support for new sensors. These systems often need to integrate datasets from a variety of sources and apply best practice analytical approaches including for example data fusion spectral and spatial analysis classification thematic mapping and integration with Geographic Information Systems GIS .

There is therefore a need for an improved method of and system for processing large volumes of Earth observation imagery data with efficiency accuracy and the ability to integrate several different data systems together.

It is an object of the invention to provide an improved method of and system for processing large volumes of Earth observation imagery data which obviates or mitigates at least one of the disadvantages described above.

An architectural solution is described for processing large volumes of Earth observation data especially imagery involving a number of data and computationally intensive processing steps. Processing requests can be made via a number of mechanisms including Open GIS Consortium OGC Web Processing Service requests or scheduled jobs and the results distributed via a number of mechanisms such as storage in a database accessible to other applications forwarding as e mail attachments or OGC compliant Web Coverage Servers. OGC establishes standards for the formatting of inputs outputs and storage of data allowing interoperability of various systems but of course any standard or proprietary formatting could be used.

The architecture mixes grid distributed computing and multiprocessing to achieve a dynamic flexible system for high throughput using any number of compute servers. The system allows both Windows and Linux based compute servers to be mixed together and can be implemented easily within a typical networked environment without modification that is many grid or distributed systems have modified operating systems and or hardware and are dedicated to a small number of specific tasks while the system described herein can operate on a generic computer or server with a simple client. Servers can differ in capability speed or number of CPUs and advantage can be taken of specialized processing hardware e.g. Cell processors or Graphic Processing Units that may be available on some servers to further improve throughput. A job control system is used to allow multiple jobs to be run simultaneously with the system automatically performing load balancing using distributed processing between servers and multiprocessing within servers . This is enabled in part by the overall architecture of the system the system provides a list of jobs to be performed and compute servers take the initiative to request jobs when they have capacity rather than having a central control system which attempts to distribute jobs in an even way.

To deal with the high volume of data throughput required the architecture makes use of a Virtual Parallel File System distributed over the compute servers or a Database Management System DBMS that accepts remote connections or web services connected to archives of Earth Observation data.

Processing jobs scripts are implemented in a suitable computer language such as but not limited to Python JAVA C or C which chain together processing modules PCI Pluggable Functions which perform the actual work. Whether the job is compiled ahead of time e.g. C or interpreted at run time e.g. Python is dependent on the language chosen. In the preferred embodiment a variety of different scripting languages are used. In some cases a particular scripting language might simply be more convenient or appropriate. Often one of the primary considerations in selecting a suitable language is compatibility with related software that the job communicates with. For example if a job needs to communicate with a third party application written in C the simplest approach is likely to write the job in C . It is an advantage of the system architecture that various scripting languages are easily accommodated.

The processing modules have a standardized application interface and the types of parameters are limited. This allows the application programming interface API to the processing modules and related programmer documentation to be automatically generated for different computer languages and programming environments. That is a translator or interface generator is written for each language. From the standard API one simply runs the appropriate interface generator to translate the API and documentation to the particulars and syntax of a desired language. A new computer language is accommodated by implementing a new interface generator allowing the same module to be called from processing jobs written in different languages e.g. Python JAVA C or C .

Where desirable individual processing modules may be written to detect and take advantage of available specialized hardware on the compute servers such as multiple CPUs a Graphical Processing Units GPUs or Cell processors to increase performance.

As processing jobs are run the inputs and actions for each processing step are archived in the Central Job Database. This record becomes an audit history meta data for derived results and is optionally delivered with the final results typically in XML form adhering to the ISO 19139 standards or via an OGC Catalogue Service. This meta data allows each user to check how each product was derived and to allow identification of results that need to be regenerated should any of the original input data be modified in the future for example if a more accurate elevation model becomes available or one of the processing steps is implemented more accurately.

Two processing examples image correction mosaicing and image feature extraction are described in the context of the architecture.

A processing software architecture is used which combines two levels of parallelism distributed processing of individual images on individual compute servers while on each individual compute server processing modules making use of available hardware to quickly process the image. The processing on individual compute servers could include parallelism if a multi core processor is available use of a Graphics Processing Unit GPU or Cell Broadband Engine processor if available. A detailed description of how processing modules make use of available hardware on a particular compute server is provided in the section titled Processing Modules .

The processing architecture is designed to work in a heterogeneous network e.g. using both Windows and Linux servers without modification to the operating systems. As noted above this is in contrast to many existing systems which are inflexible and dedicated to a limited number of processing tasks. A small job control application is installed on each compute server which monitors the pending job requests and initiates jobs on that compute server . The job control application can be configured for example to utilize only a portion of the available resources on the compute server or only utilize the compute server at particular times. This allows processing to proceed on existing networks of computers with minimal modification and the processing architecture can co exist with other applications. A database for example Oracle or PostgreSQL may be used as the central communication and co ordination mechanism for all job control applications running on compute servers in the network. As each independently running job control application initiates a job accepts the completion of a job detects failure of a job or collects meta data on a job this information is updated in the Central Job Database . At any point the Central Job Database can be queried to obtain information on the status of a particular job and its audit history.

The architecture allows multiple and or different processing jobs to be run simultaneously. On each compute server a small configuration file tells each job control application how many jobs can be run on that compute server . For example if a particular compute server has four CPUs then three jobs could be run simultaneously while another compute server having only one CPU may be configured to run two jobs simultaneously. This allows every compute server to potentially have a different number of CPUs with the job control application automatically preventing the compute server from overloading. Because compute servers are prevented from overloading this leads to implicit load balancing between compute servers . Within a particular compute server the jobs are automatically load balanced between CPUs using the existing symmetric multiprocessing capability that is part of the Windows or Linux OS. Additionally the small configuration file provides information on when the compute server is allowed to accept jobs. For example users desktop computers may be used as compute servers between 8 pm and 5 am after regular office hours. The job control application checks periodically to see whether the small configuration file has been modified and if so re reads it to obtain updated configuration information. This allows dynamic reconfiguration of the job control applications and thus dynamic reconfiguration of the overall distributed computing environment. The configuration file for each compute server is provided by the system manager at the time the compute server is added to the system based on the capabilities of the particular compute server .

When a job is to be run a script for example it is typically launched as a separate process on the compute server and the running job count will be incremented by one . The Central Job Database is then updated on the job being initiated and running and control returns to the beginning of the routine .

Each job is launched as a separate process on a given compute server so there could be several jobs running at the same time on a single server. When each job script is initiated it calls processing modules which access image data and related data taking advantage of any multi processing capabilities of the operating system . Queries are also performed to determine whether a Graphics Processing Unit GPU multiple cores and or Cell processor is available. As the job is run processed image data is stored in the image database or VPFS . Processing history data and or metadata is also sent to the Central Job Database to update the job status.

The compute server will recognize that this job has been complete when the running jobs done query is made at step so the compute server is free to request additional jobs.

Since transparent access to databases and data files is inherent in the operation of most networks compute servers can be located on anywhere on a network either locally e.g. intranet or the Internet. For example processing can be performed simultaneously on a local network of compute servers along with remote compute servers that are rented from one or more third parties.

A major problem in processing large amounts of imagery is data throughput and management of the location of images to minimize network traffic. The processing architecture preferably uses either a database for data storage and management or a parallel virtual file system PVFS which makes local file systems on each compute server appear to be one global file system.

If a PFVS is used then each compute server can be part of the PVFS. The random distribution of data on the PFVS helps to balance the overall network traffic and disk access. While this approach does not guarantee minimal network traffic it does on average provide good performance and removes the complexity of trying to directly optimize data access thus making it much easier to develop processes for creating new products.

A Central Job Database is used to hold information relating to the running and tracking of jobs status and history and is accessed by all the compute servers . The Central Job Database is typically implemented using any relational database that provides record locking to manage concurrent access for example PostgreSQL or Oracle. A custom or proprietary database could also be used though it would be a great deal of work to develop such a system. The Central Job Database is typically independent of any database used to hold imagery data.

Jobs may be written as scripts in languages such as Python JAVA C or C which call a sequence of processing modules PMs to take input data e.g. images process it and create new output products. Since there are many different processing modules available many different kinds of jobs can be created.

As shown in the block diagram of a request to run a particular job is put in a queue in a Central Job Database . When a compute server becomes available and there may be several on the network as show in its job control application queries the Central Job Database for a new job to run. The job control application with an associated configuration file schedules jobs for the particular compute server to run. Each compute server may be configured with different numbers of CPU cores and add on acceleration hardware such as a GPU or Cell Processor. Those jobs access image data from the image database a VPFS or by remote access via the web. When the jobs have been processed the processed data is returned to the same image database . The compute servers will also send status history and metadata information back to the Central Job Database .

A script for a job may indicate that parts of the processing can be independently performed using other jobs. For example a job to ortho correct one hundred images and then mosaic them together could initiate one hundred small jobs each of which ortho corrects a single image. When these are all completed the original job mosaics them all together. The original job can initiate these sub jobs by directly inserting new job requests into the queue in the Central Job Database and then monitoring the Central Job Database until all the requested jobs are complete. Since there may be many compute servers in a cluster this mechanism allows the sub jobs to be spread automatically over the entire cluster as compute servers become available.

The actual processing of data is accomplished by processing modules typically written in C or C . A system may consist of many processing modules such as modules to filter images collect image ground control points perform image classification or ortho correct an image. By scripting together different processing modules a wide variety of outputs can be created. A short list of exemplary processing modules is provided in the Table 1 List of Processing Modules. These represent typical modules to process images in the areas of geometric and ortho correction classification segmentation SAR and Polarimetric SAR processing filtering elevation processing and watershed analysis. Of course many other processing modules are known and or could be used or developed. The invention is not limited by the nature of the processing modules themselves. There are three desirable attributes for processing modules within the context of the system architecture 

1 a consistent application interface which is available in a variety of computer languages such as Python JAVA or C 

2 the ability of a processing module to automatically take advantage of the available hardware of the compute server on which it is run and

A module that has these attributes means that a script written for a particular processing job e.g. in Python could be run on either a Linux or Windows system and processing would automatically take best advantage of underlying hardware. For example a cluster of compute servers may include both Linux and Windows servers each with a different number of CPU cores some even having extra hardware accelerators such as GPUs or Cell processors. When processing images in parallel across this cluster the same script could be used on all compute servers and automatic use would be made of the available hardware.

Individual processing modules may use different strategies in using the underlying hardware to improve performance. For example a numerically floating point intensive routine may first check for a GPU and if this is not available then fall back on using parallelism using multiple CPUs if available. Another processing module may check for and use a Cell processor if available and fall back to a single CPU otherwise single parallelism may not be inherent in the algorithm. Depending on the algorithm being implemented in a particular processing module different hardware optimization strategies are employed. It is a straightforward matter to include lines of code in a processing module to perform these checks and take advantage of the efficiencies that the underlying hardware provides.

Processing modules are written such that they can transparently accept a variety of data input sources including local files network files databases passed memory data structures or data from standardized web services. For example a job script performing ortho correction may have a processing module that can obtain elevation data from a local file and should that not be available falls back to utilizing a web service providing elevation data for the entire planet albeit perhaps with lower quality and slower access .

The system is preferably implemented using a Service Oriented Architecture SOA . That is the requester of a processing job to be run does not need to know anything about the underlying architecture of the system the distributed processing or computer languages used to implement jobs and processing modules. Requests for processing jobs are also preferably accepted via standard protocols such as Open GIS Consortium Web Processing Services or SOAP.

Requests for processing can either be by setting parameters to existing job scripts held in the Central Job Database or the requester can directly submit custom scripts which utilize processing modules available on the system which will be run by the system. Scripts can be generated in any manner such as being written using a GUI or wizard customized pre existing transmitted by email etc.

Thus to summarize scripts are generated in some manner at step of and queued in the Central Job Database . Processing jobs can then be executed on compute servers via scripts calling processing modules. These processing modules access image and related data from the local image database VPFS or remote access via the Web and return processed data for storage . The compute servers also update the Central Job Database on the work that has been done by transmitting corresponding metadata.

The output data may then be displayed transferred stored in other memory devices and or undergo additional processing.

In this example one thousand satellite images need to be ortho corrected to precise Earth co ordinates and then mosaiced stitched together into a single large seamless image covering a very large area. While image ortho correction is a known technique the overall example is novel in performing the ortho correction in parallel on a heterogeneous network of compute servers possibly employing multiple cores or specialized hardware along with the acquisition of Ground Control Points GCPs and Tie Points TPs from multiple sources and the method of computing the colour balancing and cutlines.

The block diagram of presents an exemplary system for affecting this process while presents an exemplary flow diagram.

The process begins with the collection of Earth image data from some source such as from a local source or from an Earth Observation data vendor archive accessed via the web. These images are generally stored in data files whose sizes are kept down to a point that is practical for a typical computer. As a result it is common to require a large number of separate files to perform an analysis. All of these images are then copied to a database such as Oracle 10g or a PVFS.

The images are distributed over the available compute servers to acquire ground control GCPs and tie points TPs between overlapping images . Ground control points can be obtained from multiple sources such as existing ortho corrected imagery image chip databases or geocoded features represented by vectors such as roads or lake polygons using known techniques. Sources can be either local to the network or accessed via standardized web services from data vendors. Tie points are obtained by matching points on overlapping images again using known techniques. The GCPs from multiple sources are merged together to optimize them for accuracy and distribution over the image. Acquired GCPs and TPs for each image are stored in a central location such as in the Image Database .

All the GCPs and TPs are simultaneously used in a block model calculation to create an optimized correction model for each image using a known technique. A large single calculation again a known calculation is then performed on all of block models with the result being an optimized model for each image. The optimized models both correct to ground co ordinates and minimize errors between overlapping images. Because it is a large single calculation it is more efficient to compute them all together on a single compute server. The GCPs and TPs are used as inputs to the optimized correction model and then are no longer used.

The images are then ortho corrected using a known algorithm except that the task is distributed over all the available compute servers . Ortho correction is the correction of terrain induced distortion.

Within each compute server the original image is requested from the image database or PVFS and the ortho correction is speeded up by utilizing any multiple cores or specialized processors such as the Cell processor or GPU that are available on that particular compute server . To reduce data overhead information such as digital elevation data or DEMs which are of reasonable size and do not change from processing job to processing job are stored locally on each compute server . The resulting ortho corrected image is stored in the image database or PVFS.

From the ortho corrected images the cutline and colour balancing is computed . This is typically performed on a single compute server as shown in because all the information from all the images needs to be considered simultaneously. Colour balancing may use a number of steps for example as shown in the flow chart of 

1 radiometric normalization which attempts to remove most of the differences between images using known physical properties such as sensor calibration and top of atmospheric radiance corrections based on sun intensity 

2 remaining colour differences are removed by gathering statistical differences between images in overlapping areas eliminating anomalies such as clouds and shadows via statistical methods such as Thiel Sen robust regression and then

Cutlines i.e. the actual seam lines between images are computed to minimize apparent differences by following natural features in the image such as rivers or roads . Techniques are known for performing these computations. The colour balancing results and cut lines are stored in the image database or PVFS so operations in following steps can use them.

And finally the generation of mosaic tiles based on cutlines colour balancing and ortho corrected images is distributed across all compute servers . Techniques are known for performing these computations. Resulting tiles are stored in the image database PVFS or directly in the final delivery location or media.

In this example a single image is classified interpreted by using a number of different methods in parallel and the results are merged into a single final result as shown in . The processing architecture described in this document allows many different classifiers to be simultaneously run in a reasonable length of time allowing novel computing intensive approaches to be taken.

As with the process of described hereinabove the process begins with the collection of Earth image data from some source such as from a local source or from an Earth Observation data vendor archive accessed via the web. These images are collected and stored in a number of data files in the image database .

A different classification method is then initiated on each compute server . Candidate classification methods could include Maximum likelihood classification Neural Networks Minimum distance KNN or K Means or others depending on specific circumstances or the knowledge of the implementor. While each classification method runs on a different compute server each compute server may have multiple cores which can run portions of the classification in parallel. Each classification method may utilize different sets of ancillary data obtained as part of its classification process either obtained locally or via the web. The results of each classification are stored in the image database or PVFS.

Once all the classification methods are complete a single interpretation is created using a voting system and knowledge rules to create a final result . The flow chart of presents an exemplary method of performing this voting process. When the various classification methods have been completed the system uses knowledge rules to limit the classifiers to those which are most relevant to the current analysis or gives greater weight to more significant classifiers . This step may be performed before or after the voting step depending on the nature of the knowledge rules. Of course several knowledge rules may be applied some before and some after the voting step. For example if there is previous knowledge that a particular classifier has extremely high accuracy for a particular class e.g. water then when that result is obtained for a particular pixel it may over rule the result from the voting system i.e. the knowledge rule being applied after the voting step . As another example other knowledge rules can be applied such as agricultural crops may only exist in known farm boundaries in which case the voting may be restricted to methods known to be good for agricultural crops i.e. the knowledge rule being applied before the voting step .

The voting system then compares the result from each classifier for each image pixel and picks the result which was most common . By using several different interpretation methods none of which is best in all circumstances it is possible to create a result which is better than any single method based on a weighted consensus between many methods.

The optimal result is then stored in the image database and possibly displayed or output in some manner for example on a personal computer having a visual display and user interface.

The present invention has been described with regard to one or more embodiments. However it will be apparent to persons skilled in the art that a number of variations and modifications can be made without departing from the scope of the invention as defined in the claims. For example 

1 the grid of compute servers could be made up systems running operating systems such as UNIX using SUN SGI or IBM processors instead of Windows or Linux on an Intel based processor 

2 high speed storage could be implemented via other methods such as solid state devices e.g. based on RAM or Flash RAM or Storage Area Network devices instead of a Virtual Parallel File System or a Database 

3 while black and white or colour imagery data is most commonly used the scope of the invention includes any raster data sets including multispectral imagery hyperspectral imagery Synthetic Aperture Radar imagery Polarimetric Radar imager and spatial Raster GIS information and 4 Earth observation imagery sources can include those collected from space or airborne sensors.

The method steps of the invention may be embodied in sets of executable machine code stored in a variety of formats such as object code or source code. Such code is described generically herein as programming code or a computer program for simplification. Clearly the executable machine code or portions of the code may be integrated with the code of other programs implemented as subroutines plug ins add ons software agents by external program calls in firmware or by other techniques as known in the art.

The embodiments of the invention may be executed by a computer processor or similar device programmed in the manner of method steps or may be executed by an electronic system which is provided with means for executing these steps. Similarly an electronic memory medium such computer diskettes CD Roms Random Access Memory RAM Read Only Memory ROM or similar computer software storage media known in the art may be programmed to execute such method steps. As well electronic signals representing these method steps may also be transmitted via a communication network.

