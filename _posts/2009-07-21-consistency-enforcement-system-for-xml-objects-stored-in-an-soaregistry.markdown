---

title: Consistency enforcement system for XML objects stored in an SOA-registry
abstract: A consistency enforcement system includes an XML object of an SOA-registry. The XML object includes a plurality of processing task XML elements that define a processing task to be performed the SOA. An updated XML object is received through an interface. The updated object includes at least one additional processing task XML element that defines at least one further processing task to be performed by the SOA. A validation unit is use to query the SOA-registry in order to obtain one or more predefined processing task identifiers. The validation unit matches a processing task identifier of the at least one additional processing task XML element of the updated XML object against the one or more predefined processing task identifiers obtained from the SOA-registry and approves or rejects the updated XML object (â€²) depending on the result of the match.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08176092&OS=08176092&RS=08176092
owner: Software AG
number: 08176092
owner_city: Darmstadt
owner_country: DE
publication_date: 20090721
---
This application claims priority to European Patent Application No. 09163301.6 filed 19 Jun. 2009 the entire contents of which is hereby incorporated by reference.

The present invention relates to a consistency enforcement system for XML objects stored in an SOA registry and a corresponding method.

Complex tasks such as the manufacturing of complex technical products like automobiles airplanes etc. are typically performed with the help of distributed computing environments i.e. a network of individual computer systems each processing certain functionality such as steering a digitally programmed machine tool as part of the overall manufacturing. Such complex inter working computing environments may not only be distributed logically i.e. each computer system processing a certain subtask but also physically. For example during the manufacturing of an automobile some of the computing systems may be located at the car manufacturer to steer the fabrication of the car chassis and engine while other computing systems may be located at various supplier sites for steering the fabrication of the car seats or the entertainment components of the car. The computing systems may be connected over a network such as the internet in order to coordinate the sequence of processing tasks to be performed.

In order for such complex distributed computing environments to properly function it is necessary to unambiguously define the overall processing sequence that has to be performed in order to eventually lead to the desired result e.g. the finished car. At the same time such a processing sequence has to be kept flexible so that it can be easily adapted e.g. when a new supplier is selected for some of the components of the car. This is especially important in the context of large computing environments comprising possibly thousands of individual computing systems governed by different parties where it is on the one hand required that a processing sequence can be adapted by the different individual parties themselves e.g. that one particular supplier can adapt the processing tasks assigned to him in order to adapt them to his individual assembly line. On the other hand however it is absolutely crucial that the processing sequence cannot be adapted in an unallowed manner i.e. in such a way that it would not provide its overall result anymore. Especially in the context of the manufacturing of complex products such as automobiles this could lead to a stop of production or in the worst case to severe damages to the individual computing systems and connected machine tool equipment.

In the field of Service oriented Architectures SOA it is therefore known to maintain definitions of processing tasks as objects within an SOA registry which is helpful in order to coordinate and steer the required sequence of processing tasks. However known SOA registries do not provide a way of ensuring that a predefined sequence of processing tasks is not adapted in an unallowed manner.

It is therefore the technical problem underlying the present invention to provide a system and method that ensures that the information stored in an SOA registry can be flexibly adapted while at the same time guaranteeing that the adaptations are limited to an allowed extent thereby at least partly overcoming the above explained disadvantages of the prior art.

This problem is according to one aspect of the invention solved by a consistency enforcement system for at least one XML object stored in an SOA registry the at least one XML object comprising a plurality of processing task XML elements each defining at least one processing task to be performed by components of the SOA. In the embodiment of claim the consistency enforcement system comprises 

Accordingly the embodiment defines a consistency enforcement system that facilitates a flexible adaptation of XML objects in a SOA registry e.g. defining a complex manufacturing process wherein the system at the same time ensures that the XML objects cannot be changed in an unallowed manner. To this end the SOA registry stores one or more XML objects each comprising a plurality of processing task XML elements. The processing task elements each define one or more processing tasks to be performed by components of the SOA such as computers clients and or servers in order to perform the overall processing.

An interface of the consistency enforcement system receives an updated XML object which comprises one or more additional processing tasks for the SOA components defined in one or more corresponding additional processing task XML elements with respect to the original XML object stored in the SOA registry . Each processing task XML element preferably comprises a processing task identifier such as a unique ID and or a type definition. Furthermore a validation unit of the consistency enforcement system can query the SOA registry in order to receive one or more processing task identifiers preferably in the form of a list of predefined processing task identifiers. The validation unit may then match the processing task identifier of the additional processing task XML element against the list received from the SOA registry and may determine whether the updated XML object is approved or rejected. Querying the SOA registry may comprise submitting an XQuery to the SOA registry calling an API application programming interface provided by the SOA registry or any other suitable querying mechanism as will be further explained in the detailed description below.

To this end the validation unit may in one aspect be adapted for rejecting the updated XML object if the processing task identifier of the at least one additional processing task XML element does not match at least one of the predefined processing task identifiers obtained from the SOA registry. Accordingly the list of predefined processing task identifiers may be regarded as a whitelist . In other words an additional processing task XML element is only considered valid if it is explicitly mentioned in the whitelist of predefined processing task identifiers i.e. if the processing task identifier of the additional processing task XML element is comprised in the list . This aspect is especially advantageous since e.g. a manufacturing supplier wanting to update the XML object is allowed to do so in a flexible manner while the car manufacturer which may maintain the whitelist keeps control over the extent of adaptations that the supplier can perform.

Furthermore the XML object and or the updated XML object and their processing task XML elements respectively may comprise references to further objects such as configuration files. If this is the case it is preferred that the validation of the matching between the at least one additional processing task XML element and the predefined processing task identifiers obtained from the SOA registry also takes into account the further referenced objects e.g. by resolving the references and also validating the content of the referenced objects. An example of this aspect is provided in the detailed description below.

Additionally or alternatively the validation unit may be adapted for rejecting the updated object if the processing task identifier of the at least one additional processing task XML element matches at least one of the predefined processing task identifiers obtained from the SOA registry. Accordingly in this case the list of predefined processing task identifiers may be regarded as a blacklist i.e. any addition of a processing task XML element is allowed by default unless it is explicitly mentioned in the blacklist . It should be appreciated that this aspect achieves a greater flexibility at the cost of slightly less control.

Regardless of the above presented alternatives the validation unit may be further adapted for storing the updated XML object in the SOA registry and or for replacing the at least one XML object stored in the SOA registry only if the updated XML object is approved. Accordingly rejected updated XML objects are effectively prevented from being stored in the SOA registry in order to ensure that such an invalid updated XML object cannot interfere with the processing tasks controlled by the SOA registry. Preferably the updated XML object after being approved by the validation unit of the consistency enforcement system directly overwrites the original XML object within the SOA registry. This aspect ensures that an updated XML object is active immediately i.e. that the corresponding processing tasks are executed in accordance with the updated XML object immediately.

Additionally or alternatively also a rejected updated XML object may be stored in the SOA registry i.e. even if it comprises invalid extensions as will be further explained in the detailed description below. In this case the component or user that is responsible for the update may be notified in order to be able to correct the rejected updated XML object as will be further explained in the detailed description below.

In a further aspect of the present invention the validation unit is adapted for rejecting the updated XML object if the updated XML object comprises at least one termination step XML element defining an end point of a sequence of processing tasks performed by components of the SOA that is not comprised in the at least one XML object stored in the SOA registry. A termination step XML element defines an end point of a processing sequence defined by an XML object in the SOA registry i.e. it determines the final processing task in a series. One example is a termination step XML element named deliver manufactured car as the end point of a processing sequence for manufacturing a car. Accordingly updated XML objects that comprise a new termination step XML element i.e. a termination step XML element that is not comprised in the corresponding original XML object in the SOA registry are not allowed and consequently rejected by the validation unit. Otherwise a processing sequence i.e. the corresponding XML object could be adapted in such a way that it ends before the originally intended result is achieved which would lead to a malfunction of the overall processing.

Additionally or alternatively the validation unit may be further adapted for rejecting the updated XML object if the updated XML object comprises at least one XML element other than a processing task XML element. This aspect imposes even stricter limitations on the adaptability of the XML object since only and exclusively new processing task XML elements are allowed to be added and any other adaptation is rejected.

In yet another aspect of the present invention the validation unit is adapted for rejecting the updated XML object if the XML object stored in the SOA registry comprises at least one processing task XML element that is not comprised in the at least one updated XML object. In other words no processing task XML elements defined in the original XML object are allowed to be deleted from the updated XML object. This aspect ensures that no mission critical processing tasks are deleted from the overall processing sequence so that it is guaranteed at any time that the processing sequence can be performed from the start to the end as originally intended.

Furthermore the at least one XML object stored in the SOA registry may comprise at least one transition XML element the at least one transition XML element referencing at least one source processing task XML element and at least one target processing task XML element in order to define a sequence between the corresponding processing task XML elements. Accordingly the intended sequence between the individual processing tasks is explicitly defined in the XML object in the SOA registry. To this end the at least one transition XML element references two processing task XML elements namely a source and a target element. Preferably the processing task XML elements each comprise an XML attribute defining a unique ID and the transition XML element comprises an XML attribute source and an XML attribute target whose values are set to the corresponding unique IDs of the respective processing task XML elements.

The validation unit may in a further aspect be adapted for rejecting the updated XML object if the at least one additional processing task XML element of the at least one updated XML object is not located within the sequence defined by the at least one transition XML element. Accordingly an adaptation of the XML object is limited to adding an additional processing task XML element between two specific processing task XML elements namely the source and target processing task XML elements defined by the transition XML element. It should be appreciated that it is also possible to restrict updates to an XML object so that an additional processing task XML element can only be inserted between two specific processing task XML elements located anywhere within the processing sequence possibly connected by a series of transition XML elements and intermediary processing task XML elements. To this end the validation unit may be parameterized to define two specific processing task XML elements as boundaries i.e. the validation unit may be adapted for ensuring that the updated XML object only comprises an additional processing task XML element between these two parameterized predefined boundary processing task XML elements.

Furthermore the validation unit may be adapted for rejecting the updated XML object if the updated XML object comprises at least one additional transition XML element defining a sequence of processing tasks that does not lead to a termination step XML element defined in the XML object stored in the SOA registry. Accordingly the validation unit is in this aspect able to avoid the introduction of dead ends i.e. the adaptation of the updated XML object in such a way that there is a sequence of processing steps that reaches a processing step that has no subsequent processing step defined. Such a scenario is only allowed for termination steps. An according invalid updated XML object could lead to a situation that the overall processing cannot be finished and or that the last processing task in the sequence cannot finish its processing since no subsequent processing step is defined. In this case the last processing step would run until the underlying computing environment crashes or even worse until the connected further computing systems machine tools etc. are severely damaged.

In yet another aspect the validation unit may be adapted for rejecting the updated XML object if the updated XML object comprises at least one additional transition XML element defining a sequence of processing tasks that does not lead to the at least one additional processing task XML element. Accordingly an updated XML object is only approved by the validation unit if no back loops are defined i.e. sequences of processing tasks that run in a cycle. Instead only such additional transition XML elements are allowed which connect to an additional processing task XML element. In other words an additional transition XML element may not point to via its target XML attribute one of the processing task XML elements originally defined in the XML object.

The present invention is further directed to a method for enforcing the consistency of at least one XML object stored in an SOA registry using any of the consistency enforcement systems presented above. Lastly the present invention provides a computer program comprising instructions for implementing the above method which may be tangibly stored on a non transitory computer readable storage medium.

In the following a presently preferred embodiment of the invention is described with respect to a consistency enforcement system as schematically shown in . As can be seen the consistency enforcement system comprises an interface and a validation unit . The consistency enforcement system is in communication with an SOA registry comprising an XML object . The XML object comprises two processing task XML elements . It should be appreciated that only shows a simple example and that the SOA registry may comprise a plurality possibly thousands of arbitrarily complex XML objects processable by the consistency enforcement system of the present invention.

The consistency enforcement system is capable of receiving the XML object as well as an updated XML object via the interface . In the example of the updated XML object comprises a further processing task XML element that is not comprised in the XML object stored within the SOA registry .

More specifically shows that the exemplary XML object comprises the two XML elements processingTask and . Each of the XML elements processingTask comprises an XML attribute uid in the example of with the values S and S respectively that represents a processing task identifier for the respective processing task XML element . It should be appreciated that a processing task XML element may alternatively comprise a label in a human readable form e.g. in an XML attribute label which may also serve as processing task identifier. The updated XML object also shown in comprises the same processing task XML elements than the XML object and additionally comprises a further processing task XML element . It should be appreciated that only shows a simple example for the sake of illustration and that much more complex XML objects comprising more complex structural elements are supported by the present invention.

Returning to the consistency enforcement system further comprises a validation unit . The validation unit is capable of querying preferably via an XQuery the SOA registry in order to retrieve a list of predefined processing task identifiers cf. wherein the querying of the SOA registry by the validation unit is indicated by the bottom double headed dashed arrow . The validation unit is capable of matching the processing task identifier of the additional processing task XML element of the updated XML object against the list of predefined processing task identifiers in order to determine whether the updated XML object is allowable in view of the XML object i.e. whether the additional processing task XML element shown in is a valid extension of the XML object . To this end the validation unit determines if the processing task identifier of the additional processing task XML element is comprised in the list of predefined processing task identifiers.

The validation unit may evaluate the result of the matching in two ways. One way is regarding the list of processing task identifiers as a whitelist i.e. the updated XML object is only approved by the validation unit if the processing task identifier is comprised in the list of processing task identifiers otherwise the updated XML object is rejected. Additionally or alternatively the list of processing task identifiers may be regarded as a blacklist i.e. the updated XML object is only approved by the validation unit if the processing task identifier is not comprised in the list of processing task identifiers otherwise the updated XML object is rejected.

Generally the processing task XML elements comprised in the XML objects of the SOA registry may define a number of processing tasks to be performed by components of the SOA e.g. individual computations to be performed by various computing systems of the SOA. To this end the XML objects such as the XML object shown in may comprise one or more transition XML elements that define a sequence upon the processing task XML elements. As can be seen in the exemplary XML object comprises an XML element transition that comprises an XML attribute source and an XML attribute target . The value of the XML attribute source is S and thus references the processing task XML element with the uid S . Similarly the value of the XML attribute target of the transition XML element is S thus referencing the processing task XML element in this example. It should be appreciated that the XML structure shown in is only one of a wide variety of possibilities and that differently structured XML content with differently labeled XML elements XML attributes etc. is also supported by the present invention e.g. defining the source and target references not as XML attributes but rather as XML elements themselves or in any other suitable manner.

In summary an XML object defines a sequence preferably a directed graph of processing tasks also called services in the following to be performed by components of the SOA comprehensively called a process in the following. schematically shows an exemplary process order to cash . The process order to cash defines how an item i.e. a product such as a car is ordered by a customer cf. the processing task Order Item in . After the order is received and accepted cf. the processing tasks Receive Order Identify Customer and Accept Order in wherein Identify Customer defines a composite processing task that itself comprises the further processing tasks Customer Identification Start Create Customer Read Customer Info and Customer Identification End the corresponding ordered item is produced by the processing task Produce Items . Subsequently the produced item is shipped cf. the processing task Ship Items and the logistics department receives an order acknowledgement cf. the processing task Receive Order Acknowledgement in . Lastly the customer receives the ordered item cf. the processing task Receive Item uses the item and the process ends. On a technical level each of the above described processing tasks i.e. services is defined by a corresponding processing task XML element within the XML object stored in the SOA registry . A processing task XML element may further comprise definitions for executing a computer program such as a local and or remote service or web service implementing the necessary processing logic.

In the context of the exemplary process of a company A might instruct their IT department to create the process order to cash as a base process that serves as a process template. This template is compliant to the company rules policies and may be provided to the partners participating in the execution of the process e.g. the suppliers of company A . The partners might use the process template as is and or extend it in a compliant way i.e. in such a manner that no unallowed extensions are performed with respect to the rules of company A . Therefore a governance process has to be installed ensuring that all extended process definitions are valid.

As already mentioned further above the challenge is to provide a balance between flexibility the ability to modify the base process and control ensuring that modified processes are still compliant . The present invention provides an advantageous solution to this challenge. To this end the XML object stored in the SOA registry is in the SOA terminology understood as an asset described by XML artifacts and the present invention facilitates maintaining lifecycle state transitions i.e. changes over time of such assets. The consistency enforcement system of the present invention receives two XML artifacts as input artifact representing the XML object before a lifecycle state transition i.e. before an extension and artifact representing the current state of the XML object i.e. the updated XML object including the extension s . The consistency enforcement system of the present invention then analyses whether the identified changes between the object versions and are valid according to the position of change Where and or the type of change What . Depending on the result the changes are accepted approved or rejected. In the following various analyses and validations that may be performed by the consistency enforcement system of the present invention are presented in more detail. It should be appreciated that these aspects may be implemented independently from each other and that further analyses and validation may be implemented within the present invention as needed.

The first step may be to analyze the XML format of the process i.e. the XML object and derive the constraints for the consistency enforcement system .

One constraint may be that the process designer of the partner is allowed to add new services i.e. processing tasks represented by processing task XML elements . Furthermore the partner may be allowed to add only services and no termination steps. Moreover the partner may not be allowed to delete any existing service from the process defined in the XML object .

A further constraint may be that services i.e. processing tasks represented by processing task XML elements are only allowed to be inserted between two distinct services e.g. the services Produce Items and Ship Items shown in . The exemplary Java code in shows how the validation unit called bpmdc in the code can validate this constraint possibly fed by events from the XML comparator.

The above examples show how the present invention may validate rules how to locate changes to the XML object as defined in the updated XML object and or whether the located changes are valid regarding to the location of their appearance. In the following it is described how the present invention may validate whether new services i.e. processing tasks defined by processing task XML elements in the updated XML object are valid according to their type.

Typically services can be classified within a registry such as the SOA registry with the help of taxonomies. shows an exemplary taxonomy comprising predefined processing task identifiers . The exemplary taxonomy to this end comprises a hierarchical list of service names labels. As already mentioned further above the list may alternatively comprise predefined processing task identifiers in the form of unique identifiers e.g. correlating to the XML attributes uid of the processing task XML elements.

Following the concept of a whitelist the validation unit of the present invention may check whether the new service s defined in the updated XML object is are listed in the SOA registry as valid extension services. The validation unit may therefore execute an XQuery to the SOA registry and check whether the new service is comprised in the query response list. If yes then it matches the extension criteria and the updated XML object is approved otherwise it does not and the updated XML object is rejected.

In summary the present invention is especially advantageous with respect to the following aspects rules can be adapted very fast for example but not limited to the help of an XML comparator and or the information from a registry. The present invention may provide an 80 solution already in form of a template and it is only required to define rules for the template evolution i.e. changes to the template . Lastly the present invention facilitates an especially reliable control of changes to a process since by default everything is under control and no change is ignored unless explicitly ignored.

Therefore the present invention provides a solution for constraining the evolution i.e. changes of an asset i.e. an XML object during lifecycle state transitions i.e. over time and therefore can be easily embedded into SOA governance processes. By analyzing the evolution of an asset the present invention allows a policy designer to define a set of rules to be triggered upon changes during lifecycle transitions. An asset i.e. an XML object may describe all kinds of objects in the registry that have a direct or indirect relationship to services. According to OASIS a service in conjunction with a Service Oriented Architecture SOA is a contracted interface to software functionality . In this context services are usually remotely accessible and can be consumed by a process. Typical questions addressed by the present invention are Is the modification of an asset allowed at this lifecycle stage Which parts of the asset are affected by the modification Does the altered meta data change the behaviour of this asset significantly The present invention addresses these questions by defining where changes are allowed by defining what type of changes are allowed and by enforcing compliance in conjunction with lifecycle state transitions.

The present invention may be advantageously used for but is not limited to the enforcement of the consistency of at least one XML object stored in a SOA registry that represents a business process or workflow. The XML object representing a business process or workflow may comprise a collection of related structured activities represented by the XML element and or XML attributes of the XML object such as the processing task XML elements described further above . Typically activities of a business process represent a mixture of service calls in this context the business process can also be understood as a service orchestration and or one or more tasks performed by human personnel in order to make certain decisions or exception handling .

The following is an example of the use of the present invention in the context of an exemplary business process as shown in . In the example an organization A cf. has one or more franchising partners A A in only organization A is shown . A defines the core business processes and wants to allow only slight modifications. Therefore using the present invention A provides A A with the core processes as well as with a lifecycle definition and policies that are attached to the lifecycle transitions. Policies serve in this context for checking the consistency of the registry objects representing the business processes cf. the XML object and or the updated XML object and their activities cf. the processing task XML elements .

With reference to an exemplary lifecycle for A A looks as follows Zn represents a state represents a transition 

A lifecycle without backloops e.g. corrections may then look like Z Z Z Z Z Z Z Z as depicted in . Using the present invention it is ensured that e.g. within Z the XML object can be modified and stored arbitrarily. During the transition between Z and Z however one or more consistency rules preferably implemented as policy actions may be applied to match the physical XML objects P corresponding to the original XML object and P. corresponding to the updated XML object . In case of a validation to the negative i.e. the updated XML object representing P. is rejected the transition to Z is prevented and therefore also not to Z and the subsequent states . It should be appreciated that as already mentioned above the updated XML object may nevertheless be stored in the SOA registry even if it comprises invalid extensions. However when attempting to move to the next state within the lifecycle model Z in the example of a policy may be triggered that validates the target state compliancy of the selected object and in case of policy violations the transition from the current state to the target state is prohibited.

In case of a positive validation the transition to state Z is performed. In Z connection of P. with services cf. the service bindings are created. During the transition between Z and Z the blacklist whitelist validation may be performed. In case illegal services are encountered during the validation no deployment is performed i.e. no transition to Z . As already presented further above the blacklist whitelist validation may comprise performing the matching not only against the updated XML object but additionally against further configuration files references in the updated XML object since not all information may be stored within the updated XML object itself. For example the XML object may comprise information about the interface of the respective service e.g. its input output interface definition but may not comprise information about which concrete service implements the interface definition i.e. where the service is located server URL port etc. . This information may instead be e.g. comprised in binding and or deployment configuration files which may be located in the SOA registry .

The XML comparator shown in allows to compare XML documents and trees including advanced namespace handling namespace awareness i.e. elements and or attributes residing in the same namespace prefix awareness i.e. elements and or attributes that have the same namespace and prefix and or whitespace awareness. Furthermore sub trees within XML documents can be selected or dropped using XPATH statements. The XML comparator further supports the integration of different or customized comparators for node types. The XML comparator may support three report modes HTML output with highlighting and using customized templates XML output wherein differences are reported as XPATH statements and or Boolean output which determines whether XML documents are identical true or not false . XML Documents can be available in the form of URLs files and or streams. One exemplary implementation of the XML comparator requires JRE 1.4.x and Xalan 2.4 and can be accesses via command line e.g. as follows xdt2 1 file test1.xml 2 file test2.xml xml report.xml xmlns or xdt2 1 file a.xml 2 http a.b.c b.xml x comment xml report.xml.

In the following the various capabilities of the XML comparator are described in more detail with accompanying examples 

