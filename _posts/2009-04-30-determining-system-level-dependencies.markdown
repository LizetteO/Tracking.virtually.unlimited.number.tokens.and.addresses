---

title: Determining system level dependencies
abstract: Techniques for co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution are provided. The techniques include obtaining at least one of a functional design and at least one implementation artifact of a solution, obtaining at least one infrastructure component of a target deployment environment for the solution, and co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution, wherein co-relating comprises discovering at least one system level dependency among the at least one of a functional design and at least one implementation artifact and the at least one infrastructure component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959481&OS=08959481&RS=08959481
owner: International Business Machines Corporation
number: 08959481
owner_city: Armonk
owner_country: US
publication_date: 20090430
---
Embodiments of the invention generally relate to information technology and more particularly to enterprise systems.

Information technology IT enabled enterprise solutions typically provide solutions to some enterprise problems for an organization. Such solutions typically involve a large number of software components deployed on a network of servers and work stations. For example a related enterprise solution is a claim processing solution used by an insurance company where insured members or their authorized delegates can submit claims for covered expenses according to their subscribed benefit plans and get reimbursement payments. Such solutions may involve web based interfaces for interactive access to claim submitters several work station based desktop interfaces for insurance company s claim reviewer users a workflow or process automation component to coordinate activities of these reviewer users and a set of components to store and retrieve records of claims insured members benefit plans pre set payment schedules for covered expenses etc. All of these functional components may be deployed on a server infrastructure including middleware systems software database management system software and networking software which in turn can run on operating systems managing computer hardware.

Embodiments of the present invention provide techniques for determining system wide dependencies in an enterprise information technology IT system.

An exemplary method which may be computer implemented for co relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution according to one aspect of the invention can include steps of obtaining at least one of a functional design and at least one implementation artifact of a solution obtaining at least one infrastructure component of a target deployment environment for the solution and co relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution wherein co relating comprises discovering at least one system level dependency among the at least one of a functional design and at least one implementation artifact and the at least one infrastructure component.

At least one embodiment of the invention can be implemented in the form of a computer product including a computer usable medium with computer usable program code for performing the method steps indicated. Furthermore at least one embodiment of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.

These and other objects features and advantages of the embodiments of the invention will become apparent from the following detailed description which is to be read in connection with the accompanying drawings.

Principles of the present invention include a systematic approach to automatically discover system level dependencies among applications and infrastructure components out of available heterogeneous information sources and constructing a multi layered graph referred to herein for example as an execution graph .

Additionally principles of the invention include targeting the space of an enterprise computing environment involving a multitude of applications and heterogeneous infrastructural systems. One or more embodiments of the present invention synthesize multi layered dependency models of such enterprise systems involving both models of already deployed applications as well as applications not yet deployed. A meta model stitching approach can be used for example to extend such a model synthesizer. Furthermore synthesized models can be fed to multiple external tools for analyzing these models for quality of service QoS properties.

One or more embodiments of the present invention include co relation of functional and or design implementation artifacts with infrastructure components of target deployment environment. Also one or more embodiments of the invention include an open ended extensible meta model stitching based technology for achieving a co relation of functional and or design implementation artifacts with infrastructure components of target deployment environment an aspect that can handle any type of target infra structure environment. Additionally one or more embodiments of the invention include execution models of middleware containers at multiple levels of granularity an aspect that can extend from enterprise level models through multiple layers of mapping to middleware and even deeper into an operating system OS and hardware.

While existing approaches model monitoring data of already deployed applications one or more embodiments of the present invention include models of a system under observation. Also in contrast to existing approaches principles of the present invention relate application and infrastructure components and reason about its run time implications without even actually deploying the application. One or more embodiments of the invention consider the existing IT environment for example servers topology existing components deployed and running on those servers which will share resources used by the new application. Additionally unlike existing approaches one or more embodiments of the invention are extensible wherein one can specify a methodology to add new meta models of any new infrastructure and stitching with existing ones. Also in contrast to existing approaches principles of the present invention span multiple levels of systems. This capability enables users to reason about the kind of queries that can be claimed across the execution stack.

In order to query the properties of the source components their constituents and the relationships among them one or more embodiments of the invention use an extensive knowledge base including models for each type of source component. By way of example in model of application component type l that is component represents a model for which the application component l that is component is an instance. Each model includes a set of element types and a set of relationship definitions among the element types. Additionally the semantics of a relationship definition can be extended by one or more constraints between the participants of a relationship.

A constraint is a predicate relating the properties of the participating element types. A relationship between two elements in a source component is valid if and only if the types of the elements have a relationship definition in the model of the source component and all of the predicates in the constraints of the relationship definition are satisfied by the properties of the elements.

Locating source component instances for a given component type and querying the information of the instances from the model of the component type can be accomplished by source adapters. As depicted in source adapter can locate instances of the model of application component type l that is component in the enterprise IT environment. Moreover a source adapter is capable of querying elements in the source instance. Similarly other source adapters for example and in can connect models of component types to their source instances in an IT environment such as for example environment in . As such source adapters can connect models to actual sources.

In one or more embodiments of the invention a model of a component can be defined in isolation as well as in relation to other existing models by stitching relationships thereby extending an integrated model of an IT environment. In stitching relationships relate elements of model of application component type l that is component with elements of model of infrastructure component type m that is component . Also stitching relationships relate elements of model of application component type l that is component with elements of model of application component type k that is component . Stitching relationships relate elements of model of application component type k that is component with elements of model of infrastructure component type l that is component .

Further stitching relationships relate elements of model of application component type k that is component with elements of model of infrastructure component type m that is component . Stitching relationships relate elements of model of application component type l that is component with elements of model of infrastructure component type l that is component . Additionally stitching relationships relate elements of model of infrastructure component type that is component with elements of model of infrastructure component type m that is component .

The models of component types the relationships within each model the inter model stitching relationships and the source adapter together include the ability to automatically discover and synthesize an integrated information base of applications and infrastructure in an enterprise IT environment. Out of such an integrated information base several different types of queries can be answered. For example finding all instance sources of a given component type or element thereof and establishing relations between two instance level elements are typical queries of interest. Also one or more embodiments of the invention include determining co relations of design artifacts to their execution time implications. Likewise observations from infrastructure can be co related to their implications to functional design artifacts. As detailed herein provides techniques for computing the co relations in terms of the schematic blocks of .

The techniques depicted in compute a path from an instance element of a source component to another instance element of another source component as an ordered list of instance level relationships. By way of example suppose that at the functional design level one element of a design element calls another design element. For instance a process step calls a web service service and one wants to know how the infrastructure level source components for example between a process server and an application server will accomplish such a call. Given type models of processes web services process servers and application servers and the source adapters to find instances of these type models from the IT system the techniques depicted in will find one or more paths tracing how the call with be executed at run time.

An illustrative embodiment of the invention includes semantic integration of information in design artifacts with information from deployment infrastructure. This not only provides a single place to access a total picture but also queries like resource consumptions and enables deployment decisions to be answered. One or more embodiments of the present invention also include open ended extensible meta model stitching techniques applied for analyzing QoS properties and system management concerns back to an enterprise level as well as creating models of behavior of middleware containers.

As described herein models of design artifacts can be semantically integrated with models of deployment infrastructure such that queries about resource consumption implementations of functional design artifacts and their deployment decisions can be answered and queries about functional implementations of infrastructure problems or observations can be answered. As noted above existing approaches contrastingly include design models and infrastructure models that are scattered all over in multiple design tools middleware administration tools and deployment descriptors and in multiple forms.

One or more embodiments of the present invention include semantic integration achieved by a meta model stitching approach where multiple meta models for artifacts can be added. Multiple meta models can be stitched by defining relationships among elements if elements from different meta models are deemed to be semantically related. Additionally one or more embodiments of the invention include an open ended extensible approach rather than enforcing a single standard. Meta models can be for example fewer than the models in the presence of a multitude of system components and from multiple vendors and models of various design artifacts. Model weaving papers can exist in a model driven architecture community but principles of the present invention uniquely adapt the techniques for analyzing QoS properties and mapping systems management concerns back to an enterprise level. Also one or more embodiments of the invention create models of resources and behavior of middleware containers.

The core tool can be initialized for example with the following types of meta models which are typically extensible markup language XML schema. Meta models can be used to generate rules for accessing model elements for example a port element in a web service definition language wsdl file . Behavioral meta models can be used to generate rules that capture run time behavior data and control flow of middleware artifacts such as execution containers . Performance models can also be included therein. Location meta models can be used to generate rules that provide information about how to locate a model and or artifact in an IT infrastructure for example EAR packaging information .

Stitching relationships are the rules that define semantic equivalence between meta model elements for example port in a wsdl file is equivalent to port component in webservices.xml . Meta models and stitching relationships collectively define the basic concepts and their semantics. Higher level relationships and concepts such as a web service is implementedBy an enterprise JavaBeans EJB can be added as implicational rules over the basic concepts and existing higher level concepts.

The executable rule language chosen in an illustrative embodiment can be for example Prolog. A generator can be a program that translates meta models into Prolog rules and loads them into Prolog rules engine for example . As an illustration of an application on top the core tool consider the visualizer application . For an SOA application targeted for a J2EE environment some typical queries that the visualizer needs answers for can include for example ListOfAllWSDLs ListOfAllServlets ListOfAllPossibleRelationships ListOfResourcesThatOccurOnPath etc.

A query engine can receive such queries from the applications for example visualizer and route them to the rules engine . A rules engine can process the queries from the user against the loaded rules. If query processing in the rules engine results in a need to access model elements then the request is routed to an appropriate source connector agent which ultimately maps it to the appropriate query on the model for example Java management extensions JMX query xQuery etc. . Capabilities of a source connector agent accessing server components can include for example finding value corresponding to given windows registry key for example used to find the software installation location executing Xquery on an XML file and executing a Java management extensions JMX query on a JMX engine. Examples of pieces of various components of core tool architecture are detailed below.

Stitching between meta models can include for example the following. Consider meta models of wsdl and webservices.xml both models can be found in any J2EE application package which provides web services . An element named port in wsdl and an element named port component name in webservices.xml are related to each other under some conditions which one can express as rule. Also one can express that rule in prolog by the following example.

Higher level relationships as described herein can be expressed as rules. For example Prolog code to access an element can include the following 

Additionally different granularities of behavior models of server components can be created. is a diagram illustrating an exemplary execution model of an application server according to an embodiment of the present invention. By way of example depicts the elements and or steps of start request type asking if web server is up web server reply message web server not available asking if the JMS server is up Java message service JMS server and reply message JMS server not available .

Illustrated in is an example of a behavior model for an application server. As illustrated in oblong or circular nodes for example and are the resources part of the application server container and the diamond nodes for example and are the decision boxes for deciding which path a particular request will execute. There is a start node and an end node and the edges correspond to the control flow.

One can construct a behavior model to whatever granularity is desired. For example someone else including creator of the model in may have more information about what happens when the request is processed in the web server component and that information can be added as well as illustrated in . As described herein the control and data flow information can be represented using many different models but those models can be integrated with the rest of the system by defining an intermediate model possibly in XML that captures the essential information from the original model and then optionally defining rules that stitch as noted above concepts existing in the execution model with the concepts that are already part of the execution graph synthesizer.

As described herein principles of the invention include an open framework for describing meta models of platform or application components in isolation and semantically relating the meta models using inter model stitching relationships. The meta models and stitching relationships can be translated into a set of executable rules. The resulting network of meta models together with querying mechanisms to discover instances of the meta models from various sources in an IT environment can synthesize automatically and on demand and integrate models of an IT environment as a multilevel graph referred to herein for example as an execution graph .

In one or more embodiments of the present invention one can allow experts to define meta models of artifacts they deal with in their specific specialty. Also these disparate meta models can be semantically related by writing rules. Using the network of meta models thus constructed one can discover instances of these meta models by querying multiple components across systems on demand. The net result is the ability to automatically synthesize integrated models the execution graph of a whole system applications and infrastructure together.

Also one or more embodiments of the invention include exemplary queries and analyses that can be performed on execution graphs. An example of a possible analysis is the ability to trace how a business process execution language BPEL process execution will involve software resources say a thread pool in a middleware.

One or more embodiments of the present invention include the benefits of for example as described below. Automatically constructed execution graphs can feed queuing analysis tools and simulators for performance analysis. Creating realistic modeling of systems for example queuing models by hand is difficult and labor intensive. Automated construction models and analyzable information base created by one or more embodiments of the invention facilitate performance analysis.

Also execution graphs can be constructed on demand as needed by the analysis context due to the federated query based scheme described herein. On demand construction results in more up to date information for analysis compared to existing approaches that discover the dependencies among installed components and store them in a repository because the underlying infrastructure evolves due to updates and upgrades. Moreover the on demand construction of just the necessary parts of an execution graph can be more scalable for large enterprise infrastructure.

Additionally one or more embodiments of the invention are open and can be extended incrementally by experts adding meta models from their own specialty. In contrast existing approaches are based on a single standard. A federated meta model approach of one or more embodiments of the present invention can live with multiple standards as well as evolution of a standard.

Principles of the present invention as described herein include applying meta modeling techniques for modeling deep inside servers in an IT infrastructure. Moreover by integrating meta modeling with mechanisms for actually discovering instances of theses meta models in real enterprise systems the techniques described herein are simultaneously simple as well as powerful in dealing with enterprise level IT complexity.

One or more embodiments of the invention can be founded upon a network of meta models each describing the structure and behavior of a type of system component or an application component. Moreover for each component type a mechanism called the adapters used to locate and query the instances of these meta models in a given IT environment can be defined.

In an illustrative embodiment of the invention one can use a unified modeling language UML class diagram to define structural aspects in a meta model and a UML activity diagram for behavioral aspects. The semantics of these meta models lies in essence in defining the semantics of relationships. One or more embodiments of the invention use an executable rule language for example XSB prolog to specify the semantics of relationships. Having the executable rules allows one to semantically query the instances of these meta models. Furthermore the techniques described herein allow interconnecting related concepts across meta models by a special kind of relationship referred to as a stitching relationship.

As noted above one or more embodiments of the present invention include rule based machinery for meta model semantics. When a new structural meta model in the form of UML class diagram along with adapter is added to the system one or more rules and generation algorithms result. Generated rules get added to the rules repository.

The placeholder ModelType in the template gets replaced by the name of the meta model as the rules are added. When one of these rules is evaluated with given values to the variables used in RHS of the rule each solution for variable M reflects one model of ModelType. The value of variable M could be for example a prolog list of binary functors containing the key value pairs.

The adapter clauses in essence retrieve instances of the meta models from actual source components and create ground facts in Prolog. As described herein adapter clauses are implemented by a variety of query mechanisms such as for example an XQuery for XML files and JMX calls for querying collecting statistics of system resources etc.

The placeholder Element Type gets replaced by the name of the class. When this rule is evaluated with a given value of variable M each solution for variable E reflects an instance of class ElementType in model M of ModelType. The value of variable E would be a prolog list of binary functors named attribute where each unique functor contains the name of one attribute defined in the class ElementType and its value for example if there is an instance of class C containing attributes a and a with values v and v one solution to E would be attribute a v attribute a v .

The placeholder Relation Type gets replaced by the name of the relation ElementType and ElementType get replaced by the name of the source and destination UML classes respectively. Also ModelType gets replaced by the name with which the meta model is added to the system. Constraint gets replaced by the constraint expressed by rules mostly but not limited to in terms of E1 E2 and M. The constraint cannot be automatically generated by plain class diagram. It has to be augmented with constraint expressed in the rule language. In an illustrative embodiment of the invention constraint can be assumed to be specified in prolog syntaxes. When this rule is evaluated with given values of any combination of variables E1 E2 and M each solution to the unbounded variables along with already bounded variables reflects a relation between instances E1 and E2 of type ElementType and ElementType respectively in model M of type ModelType.

In the case of UML composition relationship and certain cases of association relationship the evaluation of constraints may need to consider the conditions that are external to the meta model. In other words those properties are not captured in meta model. In these cases the responsibility can be delegated to figure out the relationship between model elements to the adapter of the meta model by following rule 

Inheritance relation can be treated as a special case and can be handled at meta level only because all of the instances are going to follow it. From instances it is possible to check their type and get access to the attributes in the tree of inheritance hierarchy. One expedient way of defining meta models within one or more embodiments of the invention is to start with XML schemas because most of the meta models of application components in SOA environment are defined through specifications augmented by XML schemas and file system packaging instructions. Standard mechanisms can be used to represent XML schemas into UML class diagrams and generate corresponding Xqueries based adapters to instantiate the model elements and relationships among them. These UML class diagrams can be further enhanced for example by adding more associations and semantic constraints.

The structure of middleware components can be described in a UML class diagram and the rules can be generated using similar techniques as used for meta models of application components. For capturing the behavioral details of middleware components one can use a UML activity diagram with following additions. Each data type associated with data pins should be one of the types defined in one of the structural meta models. Also if an action invokes the operation it should be on one of the instances of a type defined in the structural meta model. Additionally several annotations can be used on different kind of elements in a UML activity meta model for capturing properties that are of interest in a QoS analysis such as for example upper Bound for pins to indicate the buffer size of the pin reentrant for action to indicate the parallel processing of action on data in a buffer at input pins resource for a central buffer to differentiate the middleware resources from the data etc.

The following are exemplary semantics that can be for example extracted out of the above activity diagram. The Establish TCP connection action is activated when a TCP connect request arrives at an input data pin of the action. The buffer size of an input data pin is specified by serverSocket.backlog configuration that is if a TCP connect request arrives while the buffer is full it will be rejected . The action Establish TCP connection works on TCP connect request one by one and produces two outputs one control output and one data output. The control output activates the Obtain Reader Thread action and data output that is con TCPConnection flows to Read Request action that also requires one Thread in order to get activated . Many instances of the Read Request action can execute concurrently to work on a buffer of TCPConnections on its input pin because it is marked as . shows that if Obtain Reader Thread does not finish after the ThreadPool.timeout period of its start it will finish the flow. The rest of the actions and control and data flow edges can be explained in a similar manner.

Each of the actions can be further explained in more granularities either with in same behavioral model or in separate suitable models. For example Establish TCP Connection and Obtain Reader Thread actions can have detailed state machine based models to explain the further internal details of the actions while the process request and write response action can be better elaborated in an activity based model to highlight the details of how a web resource requested is located and or instantiated and executed as well as the role of cache and session management in the process etc.

Similarly behavior of other infrastructure components can be described using UML activity models. The semantics of UML activity meta model can be captured as shown partially in using the same technique as described for the meta models of application components. is a diagram illustrating a meta model of an UML activity diagram according to an embodiment of the present invention.

The generated rules can be universally applied to any activity diagram describing a middleware component. As described herein only a few exemplary rules are discussed to demonstrate the semantics of behavior models of middleware containers primarily those rules necessary to know the sequencing of resources consumed in processing of any activity model.

As described herein a model adapter is a component in one or more embodiments of the invention that is responsible for creating instances of meta models that is models model elements and basic relationships describing meta model semantics . There are a variety of ways in the techniques described herein to locate and discover instances of models of different meta models and to extract the model elements represented by adapter rules starting with for example model and element predicates respectively. For example in order to locate an instance of J2EE application meta model an adapter needs to know how to get the ear files on a J2EE application server and given an ear file how to extract instances of elements in the model following the packaging standards and XML schemas of descriptors of J2EE application.

In an illustrative embodiment of the invention the adapter would accept the element ApplicationServer in a model of type J2EE Application Server meta model and would be able to locate the models of type J2EE Application corresponding to each application deployed on the server. Further for each application model the adapter would extract the instances of elements of module by firing proper XQuery on application.xml found in a META INF folder under the root folder of ear file. One of the adapter rules accepts the properties object in place of any other model or model element. Such a provision can for example be used for bootstrapping the system to enable it find the models of at least one meta model without depending on other models or model elements. In an illustrative embodiment of the invention there can be such a bootstrapping adapter that accepts a list of IP addresses and locates the J2EE application server models. Such a provision also enables the integration of external repositories into the framework for example a change and configuration management database CCMDB .

In one or more embodiments of the present invention each of the meta models can be combined to create a network of semantically integrated meta models of a system. Stitching between meta models can be defined as the process of capturing the relationship among different meta models. The relationship can exist between elements of a meta model and another meta model or between two elements from two separate meta models. For example whenever a new stitch with relationship name RelationType is added into our framework one of the rules get generated as per the template described below.

Consider a composite SOA application where a BPEL process includes services from several web services and the web services are implemented by J2EE components. Multiple layers of artifacts are involved. For example process and web service components can be packaged as service component architecture SCA models where inter component linkages are expressed as wires. An SCA component encapsulating a BPEL process refers to SCA components encapsulating web services as import references. Inside BPEL components the activities that invoke the services can be referred to as partner links. The concept partner link in BPEL models should advantageously be semantically linked with references in SCA models. As shown in this semantic relationship is expressed as a stitching relationship connected. 

An exemplary stitching rule for calls relationship between invoke element of BPEL meta model and port element of WSDL meta model is also depicted in . The rule is defined in terms of other rules including BPEL meta model semantics rule as a uses relationship between invoke and partner link elements and other stitching rules such as a connectedTo relationship between the partnerlink element of BPEL meta model and the reference element of a SCA meta model.

Activity models of different infrastructure components can be related as one activity of one component s activity model can be described in detail by another component s activity model. This provides an opportunity to describe activity models of different components independently and subsequently link them. For example in the activity model of application server an activity corresponds to the request handling by a web container which is described in detail by the activity model of the web container. This type of relationship is already captured as a call behavior relationship between the action element and activity element in the meta model of UML activity.

The relations between infrastructure structural meta model elements and management meta model elements can be captured using the same technique as described earlier for meta model stitching. An example of this can be a sameAs relationship between element ThreadPool in a structural meta model of Web Container and a management meta model of Web Container. 

The execution of application components can be carried out by middleware containers. Such a relationship of application components to the middleware containers can be captured for example as stitching rule deployedOn in the form as follows.

Additionally the infrastructure management meta model describes management aspects such as for example performance monitoring of application components for example average time spent in execution of a servlet . This relation can be described for example as stitching relation sameAs between an element of application meta model and a corresponding element of management meta model for example the sameAs relationship between servlet elements in both meta models for the servlet example .

An integrated model can be a multi layered graph where model elements are treated as nodes and the relations between them is captured as edges among them. By following a path one can trace how a new composite application will execute on a given platform all the way down to resources in the underlying infrastructure. In order to query the integrated model two types of queries can be supported on this data model. Meta model queries are for finding the all node types and possible relationship types between them. Integrated model queries are for finding the actual instances of the discovered node types and the relation types among them. This also includes queries that are based on the semantics added to the rules repository using the basic rules for getting nodes and relating them.

A complete graph need not for example be stored in a repository but can be incrementally created by resolving the queries and using appropriate adapters to fetch the desired data at run time. Additionally caching can be used for performance and a federated methodology makes the techniques described herein scalable.

For example instances of a J2EE application server meta model can be discovered via execution of a corresponding adapter. For each of these discovered models an ApplicationServer element is extracted and another adapter corresponding to the J2EE Application meta model is invoked by passing an ApplicationServer element. Instances of J2EE Application meta model can also be discovered.

For each of the discovered J2EE Application models module elements are extracted and using each of these a J2EE Web Service meta model can be discovered by a corresponding adapter. Also webservice elements of each J2EE Web Service model can give the desired answers for the mentioned query. In the exemplary the result includes only one web service W .

Explaining a particular step in the above mentioned process in more detail could include for example firing the XQuery and or application and or module on application.xml by an adapter corresponding to the J2EE Application meta model for instantiating the module element for a discovered model instance of a J2EE Application meta model.

As depicted in consider a complex query of finding the resources used while processing a request for web service W . This query can be decomposed to several sub queries including finding the application component call path the hostedOn relation between a component and container and queries for finding the resources of the container which in turn uses the structure model and the activity model of containers. In this example because web service W is implemented by servlet S the component level call path includes servlet S . Web service W and servlet S both are deployed on web container WC as App.Ear is deployed on AppServer AS which contains Web Container WC . Using the activity diagram of Web Container while handling the request first a thread from Th Reader thread pool is obtained the request is read the thread is released and a thread from Th Worker thread pool is obtained the request is processed and the thread is released. So the ordered list of resources consumed inside WC are Th Reader and Th Worker .

One or more embodiments of the invention include a meta model driven approach that is part of the model driven architecture MDA movement. The techniques described herein extend the model driven concepts from development tools to the arena of model driven systems management. It is in the systems where enterprise IT complexity lies.

The techniques depicted in can also include answering a query of run time implications of a design in terms of potential resources consumed by operations of a designed artifact. Additionally the techniques depicted in can include answering a query of enterprise implications of infrastructure observations and or issues including an exception a monitored event and or a failure.

The techniques depicted in can also as described herein be run on a system wherein the system includes distinct software modules each of the distinct software modules being embodied on a tangible computer readable recordable storage medium.

Also one or more embodiments of the invention include a system for co relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution. Such a system can include for example a synthesizer that integrates input models source connectors that import respective models from a source and wherein the source is a design tool a file system and or an infrastructure component. Such a system can also include meta models wherein each meta model captures semantics of a corresponding model in terms of entity type relationship type and or behavior of a given kind of model as well as stitching relationships among elements of the meta models that describe relationships among a set of meta model elements from multiple meta models that are semantically related.

Query mechanisms for source connectors can further be of several ways inclusive of for example Xquery Xpath for models expressed as XML files and JMX if it is supported in the infrastructure. The synthesizer for example an execution graph synthesizer can for example process submitted queries by using information from multiple meta models by traversing stitching relationships to decompose submitted queries into sub queries on appropriate models. A synthesizer can also for example direct the sub queries to at least one respective model via the source connectors to retrieve information from actual sources.

New meta models can be added to the system and related to the meta models by adding at least one appropriate stitching relationship thereby making the system extensible. Also the input models can include for example functional design and implementation artifacts placement directives for deploying the functional artifacts on a target infrastructure and or a model of properties and contents of components of the target infrastructure. Each model can include specific entities and relationships describing structure and or behavior of functional design artifacts a target infrastructure component and or placement directives.

The meta models can include for example meta models of structure and or behavior of typical development artifacts in an SOA system meta models of structure and behavior of infrastructure components and or meta models of structure and behavior of management facilities including for example JMX simple network management protocol SNMP etc. for infrastructure components and functional components wherein each meta model describes structure and or behavior of models admitted by the meta model. Structural meta models can be further expressed by representations such as for example UML class diagrams UML composite structure diagrams and or XML schemas.

The meta models of structure and behavior of typical development artifacts in an SOA system can include for example definitions of a BPEL process web services and or implementation artifacts of the web services such as for example enterprise JavaBeans EJBs servlets etc. . The meta models of structure and behavior of infrastructure components can include for example a process server a web container and or a managed object container in an application server which are typical of contemporary J2EE or .Net middleware environment and resource sub components of these infrastructure components. Behavioral meta models can further include UML behavioral models such as activity diagrams sequence diagrams and collaboration diagrams and layered queuing networks.

Semantics of the stitching relationships and semantics of relationships used in the meta models can be for example expressed in an executable rules language including for example Prolog and or agent building and learning environment ABLE and interpreted by suitable forward and backward chaining traversal algorithms implemented in a conventional programming language including for example Java or C or C . Furthermore implications of multiple relationships can also be expresses as higher level rules. A synthesizer as detailed above can include for example a rules execution engine to interpret and reason with rules to implement query decomposition processing. Additionally the meta models and stitching relationships can be translated into rules in an executable rules language that can be for example inferences with and or by a rules execution engine .

As detailed herein for example path P can be an ordered list of relationship definitions of the form Rk ETi ETi 1 where the relationship Rk is between element type ETi and element type ETi 1 in some model traversed during the construction of model level path P. Additionally for every element type ETi in the model level path P one or more embodiments of the invention can locate an element Ei of element type ETi in a source component Si such that ETi is in a model Mi and wherein source Si is an instance of model Mi. Also the source adapter for a model is capable of locating a source component instance of a model by searching an IT environment.

Further as depicted in one or more embodiments of the invention can include instantiating model level path P to get instantiated path P by substituting E1 for ET and E2 for ET in the relationships in path P and for all other intermediate element types ETi in the relationships in P by substituting each element type ETi by a corresponding instance element Ei as described herein . The techniques detailed herein also include checking the validity of the instantiated path P such that the constraints of every relationship r Ei Ej in path P are satisfied by the properties of the elements Ei and Ej.

If the instantiated path P is not valid then one can find another model level path P and repeat the process. Also one or more embodiments of the invention include returning instantiated path P as result.

Step includes deciding whether to proceed to step or both described herein . Additionally step includes generating executable rules from input model M stitching relationships and mapping file MF into the knowledge base. Step includes generating programs for implementing a source adapter from mapping file MF.

A variety of techniques utilizing dedicated hardware general purpose processors software or a combination of the foregoing may be employed to implement the present invention. At least one embodiment of the invention can be implemented in the form of a computer product including a computer usable medium with computer usable program code for performing the method steps indicated. Furthermore at least one embodiment of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.

At present it is believed that the preferred implementation will make substantial use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input and or output interface formed for example by a display and a keyboard . The term processor as used herein is intended to include any processing device such as for example one that includes a CPU central processing unit and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended to include memory associated with a processor or CPU such as for example RAM random access memory ROM read only memory a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input and or output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer . The processor memory and input and or output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

Accordingly computer software including instructions or code for performing the methodologies of the invention as described herein may be stored in one or more of the associated memory devices for example ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into RAM and executed by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium for example media providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory for example memory magnetic tape a removable computer diskette for example media a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read and or write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input and or output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly such as via bus or through intervening I O controllers omitted for clarity .

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

In any case it should be understood that the components illustrated herein may be implemented in various forms of hardware software or combinations thereof for example application specific integrated circuit s ASICS functional circuitry one or more appropriately programmed general purpose digital computers with associated memory and the like. Given the teachings of the invention provided herein one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.

At least one embodiment of the invention may provide at least one beneficial effect such as for example execution models of middleware containers at multiple levels of granularity.

Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings it is to be understood that the invention is not limited to those precise embodiments and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention.

