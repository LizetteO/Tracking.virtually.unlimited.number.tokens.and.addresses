---

title: Shared script files in multi-tab browser
abstract: A host device executes a browser application that displays web content to a user in plurality of tabs or windows. The browser application includes an interpreter that determines whether an external file referenced in the web content already exists in a shared memory resource available to a plurality of the tabs or windows. If the external file does not exist, the interpreter obtains the external file and generates the intermediate representation of the external file for storage in the shared memory resource. If the external file does exist, the interpreter links an intermediate representation of the code embedded in the web content that is stored in a dedicated memory resource to the corresponding intermediate representation of the external file stored in the shared memory resource.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08683319&OS=08683319&RS=08683319
owner: Telefonaktiebolaget L M Ericsson (publ)
number: 08683319
owner_city: Stockholm
owner_country: SE
publication_date: 20091006
---
The present invention relates generally to web browsers and more particularly to a mechanism for sharing intermediate representation of commonly used script files between different tabs windows frames panels or other browser display component for viewing web content.

JavaScript is a well known scripting language used to allow computer applications to access software objects within other applications. When first invented JavaScript comprised code snippets that were sparsely embedded in a web page and was used to manipulate the Document Object Model DOM . JavaScript has since matured and is now used in a more library like manner. That is instead of embedding JavaScript code among other HyperText Markup Language HTML code in a given web page JavaScript code is encapsulated in separate files. Each file may be associated with a different functionality or set of features and is included in the web pages. In this manner a given JavaScript file can be included in different web pages and one web page can include more than one JavaScript file. This helps improve the reusability and modularity of JavaScript .

By way of example the common features of a website such as common user interface logic may be provided as separate JavaScript files. These files are included in multiple web pages within a website and provided to a user when the user accesses the website. Thus when the user interacts with one web page to enter data for example the user is presented with a user interface having generally the same look and feel as the other web pages in the website.

The Apple website illustrates this type of usage very well. Particularly it puts most of its JavaScript code into several JavaScript files in a modular manner. Then it uses the same JavaScript files across several different web pages to provide the same or similar functionality across those web pages. At the time of writing Apple s home page www.apple.com Apple s Mac page www.apple.com mac and Apple s iPhone page www.apple.com iphone include seven 7 of the same JavaScript files while the Mac and iPhone pages themselves share three 3 additional JavaScript files between them.

Typically web pages import JavaScript files within the same domain website. In addition however web pages can also import JavaScript files from one or more different domains websites. For example Google Maps Facebook and other such services provide JavaScript Application Programming Interfaces APIs so that other developers can develop applications that access the services provided by their JavaScript files. In such cases the JavaScript files would be located at google.com or facebook.com or some other common repository and included in the web pages from other websites that intend to use Google Maps or Facebook services.

Additionally there is another category of standalone JavaScript files that are used as libraries. Some examples include but are not limited to Prototype JQuery and Yahoo UI YUI Library. These libraries wrap up common logic into related files and abstract the interfaces used to manipulate web pages. Such libraries make creating and building web pages easier and more maintainable. A large number of well known websites some of which are listed by the Pingdom website http royal.pingdom.com 2008 06 11 javascript framework usage among top websites for example are now using such JavaScript libraries to facilitate the construction and maintenance of websites.

Currently most web browsers support the opening of multiple web page instances simultaneously. For example a web browser that opens a web page containing frames in framesets or iframes which load other web pages maintain multiple web page instances. Another example is the multi tab browser. As is known in the art a multi tab browser allows multiple tabs to be open at the same time in a single browser window. Each tab is a display component of a web browser that allows a user to view web content such as a web page. Additionally other display components exist that are able to display web content. Such components include but are not limited to windows frames and panels or other construct that enables a user to view and interact with web content. However for simplicity sake each of these different components are referred to herein as tab or display component. 

Typically multi tab browsers execute on a desktop or laptop computer. However even resource limited devices such as mobile devices provide multi tab browser functionality. For example the iPhone and iPod provide their users with the Safari browser. Similarly Android provides the WebKit based browser. Such browsers although they may not actually visually display multiple tabs still provide the multi tab functionality. In addition there is now an ongoing trend in that each tab executes as its own separate process to facilitate stability and security while the core functions of the browser execute as another process. Some examples of modern browsers that use this approach are Google Chrome and Microsoft s Internet Explorer IE 8.

Based on the current trends of importing external JavaScript files and the use of multi tab browsing as described above there is a high probability that web pages opened in multiple tabs will include or use the same JavaScript files. Such a situation is likely to happen for example when a user clicks a link in one tab to open a new tab that loads a different web page from the same website. In these cases some of the JavaScript files included with the web page in the newly opened tab are likely to be the same as those included with the web page in the current tab. In another scenario a user may simultaneously open a plurality of tabs each loading a different website. The web pages in each different tab may all use a common set of services from another entity such as Google Maps or Facebook and therefore include the same JavaScript files from Google Maps or Facebook. In yet another scenario the web pages in different tabs may all use third party JavaScript libraries such as Prototype or JQuery and therefore include copies of the same JavaScript files.

JavaScript is used in an increasingly library like manner. Thus the size of external JavaScript files tends to increase and the logical structure of the JavaScript files tend to become more complex. Still given these facts no one has attempted to optimize the resource usage and performance of a browser. Where different tabs include the same JavaScript files the browser will repeat the parsing of each file to the JavaScript syntax tree and just in time compile the files to bytecode. Additionally largely same copies of the data structures will also be stored in multiple places in the memory.

The present invention provides a mechanism that allows multiple instances of a browser window such as a tab a window a frame or a panel for example. In one embodiment a host device has memory to store one or more software applications and one or more processors to execute the software applications. One of the applications executed by the host device is a web browser application. The browser application includes a browser engine to display a plurality of web documents in a corresponding number of different display components of a graphical user interface and an interpreter to interpret embedded code in the web documents.

The browser application may allow a user to invoke multiple display components such as browser windows or tabs each having different web content. The interpreter generates an intermediate representation of the embedded code in the web documents and stores the intermediate representation in a dedicated memory resource available to that display component. The interpreter also determines whether the intermediate representation of an external file referenced by the web content is stored in a shared memory resource available to two or more display components. If the interpreter determines that the intermediate representation of the external file is available in the shared memory resource the interpreter will link the intermediate representation of the external file to the dedicated memory resource. Otherwise the interpreter will obtain the external file from an external source generate the intermediate representation and store the generated intermediate representation in the shared memory resource.

Referring now to the drawings illustrates an exemplary architecture for a multi tab web browser in accordance with one embodiment of the present invention. The web browser is an application program that runs on a host device having processing and memory resources for executing software applications. The host device may comprise for example a general purpose programmable computer a smart phone or personal digital assistant.

The main components of the web browser comprise a browser engine a networking subsystem a JavaScript interpreter and an eXtensible Mark up Language XML parser display back end and data store . The browser engine loads Uniform Resource Identifiers URIs and supports a variety of different browser actions such as forward back and reload. The browser engine also provides various hooks for viewing aspects of a browsing session such as current page load progress. As seen in the browser engine may comprise or interface with other components such as a rendering engine and a user interface layer . The rendering engine produces a visual representation of a web page described in a language such as HTML and XML code. The user interface is the software layer between the user and the browser engine and provides user interface components e.g. toolbar progress meters etc. and services to the desktop environment or operating system. The networking subsystem implements file transfer protocols such as HTTP and FTP. The JavaScript interpreter evaluates and processes JavaScript code embedded in web pages and JavaScript code from the external JavaScript files. The XML parser parses XML documents into a document object model DOM .

Those skilled in the art will understand that although not specifically shown in the figures many browsers will also include other components. One such component is a display back end that provides a set of fonts and user interface widgets which may be used by the user interface. Another component is a data store that stores data associated with browsing activity such as bookmarks toolbar settings cookies and cached files. Both of these components could for example communicate with the browser engine via the user interface .

Memory represents the entire hierarchy of memory in host device and may include both random access memory RAM and read only memory ROM . Software programs and data required for operating host device may be stored in non volatile memory such as EPROM EEPROM and or flash memory and may be implemented as discrete devices stacked devices or integrated with controller . The software programs may include an operating system such as WINDOWS XP or NT UNIX LINUX APPLE COMPUTER S OS X and the like. The software programs may also include user application programs that perform some function for the user. In one embodiment for example memory stores browser that allows a user to connect to and interact with the Internet.

The UI comprises a display and an input device . Display may comprise a traditional CRT monitor a liquid crystal display LCD a plasma screen or the like or may comprise a display sized for a mobile communication device. Controller may output the results obtained from executing the present invention to the display for viewing by the user. The input device may include inter alia a keyboard and or a pointing device such as a mouse or a keypad for smaller mobile devices. The user input device permits a user to enter commands data and generally control the operation of host system .

Host device may further include a communication interface to communicate with one or more remote parties via a communications network. The communications interface comprises a transceiver that allows the host device to communicate with one or more remote parties via a communication network. In one embodiment the communications interface comprises a fully functional cellular radio transceiver that can operate according to any known standard including the standards known generally as the Global System for Mobile Communications GSM cdma2000 Universal Mobile Telecommunications System UMTS Wideband Code Division Multiple Access WCDMA 3GPP Long Term Evolution LTE and Worldwide Interoperability for Microwave Access WiMAX . In other embodiments the communications interface may comprise a suitable interface includes an Ethernet based interface adapter cards such as 10 BASE T Fast Ethernet 10GbE or the like for example that connects host device to a packet data communications network. In yet other embodiment the communication interface may comprise a wireless LAN 802.11x interface or is a wireless interface card operating according to WiFi standards e.g. IEEE 802.11 or BLUETOOTH. Those skilled in the art will appreciate that the interfaces listed herein does not comprise an exhaustive list and that there are many additional interfaces that may be used to connect host device to a communications network.

As previously stated the present invention provides a mechanism that allows browser to share the intermediate representation of external JavaScript files among multiple tabs windows frames panels or other display components in the web browser. The intermediate representation includes but is not limited to the content of the JavaScript file the resultant syntax tree the variable list i.e. the symbol table and in some embodiments the bytecode. Additionally the present invention may allow the multiple display components to share data structures and other related data generated from the external JavaScript files that are used by browser to interpret the JavaScript . Such a mechanism will help to reduce memory usage and significantly improve the performance of both web page rendering and JavaScript execution during multi tab browsing. This is particularly beneficial for resource limited devices like mobile devices.

The intermediate representations of the JavaScript files 1 2 are pulled from the intermediate representations of the JavaScript code embedded in tabs . The intermediate representations are then saved separately in an external JavaScript files pool . Once stored the intermediate representation of embedded JavaScript in the browser tab links to that of JavaScript files 1 and 2 in external JavaScript files pool while the intermediate representation of embedded JavaScript in the browser tab links with that of JavaScript file 1 in external JavaScript files pool . As a result host device does not need to repeatedly parse JavaScript file 1 to a JavaScript syntax tree. Nor does host device need to just in time compile the file to bytecode for both browser tabs and . Further only one instance of the intermediate representation of JavaScript file 1 is saved to memory that all browser tabs can access. This saves memory resources over the conventional method of allocating memory for each browser tab that uses the JavaScript files. This also reduces execution time over the conventional method of compiling JavaScript code and just in time compiling to bytecode repeatedly for each browser tab that uses the JavaScript files.

Since JavaScript is an interpreted language the controller will instantly execute the JavaScript code as the interpreter parses the code. More particularly the JavaScript interpreter resident on host device will first parse the JavaScript code to produce an intermediate representation format like the syntax tree box . A syntax tree is a tree based multi node data structure that represents the grammatical structure of the original JavaScript language. Each node of the tree denotes a unit of expression or statement. Once the syntax tree is created the interpreter recursively traverses the tree and performs the operation corresponding to each node while propagating the execution context state along the traverse box . Some operations may result in the definition of new variables. If so the new variables will be appended to the variable list associated with a specific scope.

As those of ordinary skill in the art know some JavaScript interpreters also provide a just in time compiler that compiles the JavaScript to bytecode prior to executing the generated bytecode. Bytecode compilation allows for a more efficient and dynamic execution of the code than that of binary code. For example the SquirrelFish JavaScript interpreter in the WebKit browser engine compiles a syntax tree to corresponding bytecode. When a new function is defined the content of the function is saved as corresponding syntax tree under the tree node that denotes the function variable. That corresponding syntax tree is not compiled to bytecode however until the first time that the function is invoked. Thereafter the resultant bytecode may be directly used responsive to invocations of that function.

To illustrate method consider Apple s home page and their iPhone web page. The Apple home page i.e. http www.apple.com currently imports approximately fifteen 15 external JavaScript files. According to the present invention launching a browser and visiting apple.com will create fifteen 15 corresponding records in the external JavaScript files pool . Additionally the intermediate representation of the embedded JavaScript and the data structure that represents the DOM structures of the home page in the tab are saved to the dedicated memory space. The Apple s iPhone web page imports fourteen 14 external JavaScript files seven 7 of which are identical to those associated with Apple s home page. If the user opens the iPhone web page in a new tab the interpreter goes through each script tag to determine whether the imported external JavaScript file associated with the script tag is already cached in the pool . In this case the interpreter would find seven 7 records in pool that could be re used and linked to by the newly opened tab.

As previously stated the current trend is to allow each tab to execute as its own separate process. Therefore the memory where the intermediate representations of the external JavaScript files in pool are stored is shared among the multiple processes. As those skilled in the art will readily appreciate there are many methods in which to share memory across processes. However one embodiment of the present invention utilizes an Inter Process Communication IPC mechanism to facilitate such sharing. For example a Portable Operating System Interface for Unix POSIX compliant mmap system call and the Unix System V IPC Shared Memory facilities are both suitable for implementing shared JavaScript .

With some operating systems such as Linux the shared library comprises a read only part and a read write part. The read only part includes the symbol table the text binary of the instructions and read only data. The read write part includes other data such as regular data for example. When multiple programs that link with the same shared library execute simultaneously there is only one copy of the read only part of the shared library in the memory. However there is one copy of the read write part per instance of the program. Therefore the program maintains the modifications of the read write data for itself while the read only part is shared among the other instances of the executing programs. However the language feature of JavaScript dictates that there be no division between read only and read write parts for a JavaScript shared library. Thus any symbol can be rewritten at runtime. Even a function in JavaScript is one of the variable types and is not particularly different from other variable types such as the object type or string type. Moreover the variable type is not strictly bound with the variable and thus the variable can always be re assigned with a value of another variable type at runtime.

When webpage1.html is opened the generated intermediate representation associated with the lib.js of is saved to the external JavaScript libraries pool . In this embodiment the intermediate representation saved to the pool includes the syntax tree that describes the grammatical structure of lib.js the variable list containing the function foo and the object bar. If the JavaScript interpreter uses lazy just in time bytecode compilation the interpreter will delay generating the bytecode for function foo until foo is invoked in webpage1.html. Thereafter the generated bytecode for foo is saved among the other data associated with lib.js in the pool . Once invoked foo is re assigned with a string in webpage1.html. However this modification is not written back to the pool . Instead foo is appended to a dirty variable list of lib.js with a new string value. The dirty variable list of lib.js is then saved with the other intermediate representation of webpage1.html instead of in the external JavaScript files pool . This dirty variable list of lib.js includes all variables of lib.js that have been modified locally in webpage1.html.

When webpage2.html is opened e.g. in a new tab or a new instance of a browser window the interpreter determines that the html code imports the external script file lib.js from an inspection of the URI www.company.se lib.js. However instead of interpreting the JavaScript file lib.js the interpreter first searches the external JavaScript libraries pool to determine whether a record for the lib.js JavaScript file already exists. Upon determining that a record for lib.js already exists in the pool the saved JavaScript syntax tree the variable list and the bytecode associated with lib.js are directly linked to webpage2.html. Thereafter when foo is invoked as a function by webpage2.html the interpreter searches the saved linked variable list of lib.js for the definition of function foo . The bytecode of function foo that was generated during its invocation in webpage1.html is then directly used for execution in webpage2.html.

Any modifications of foo by webpage1.html such as the dirty variable list are not visible to webpage2.html. Nor are modifications of foo by webpage2.html visible to webpage1.html. Therefore if webpage2.html were to modify the property name2 of object bar to 99 the modified bar object is appended to the dirty variable list of lib.js in webpage2.html. Although this modification overwrites the original value for name2 in the original bar object in lib.js the modification is seen only by the code in webpage2.html. Provided webpage1.html did not modify the value for name2 in its copy of bar the code in webpage1.html will still reference the original name2 of 100 value in lib.js.

As previously stated the present invention first searches the pool to determine whether a given JavaScript file or code referenced in a web page should be imported. Such a search is likely to occur for example in three different scenarios. The first scenario occurs whenever a user clicks a link in one tab to open a new tab that loads a different web page from the same website. The second scenario occurs whenever the user simultaneously opens a plurality of tabs each loading a different website. The third scenario occurs when different web pages in different tabs all include copies of the same third party JavaScript files.

For the first and second scenarios the controller could inspect the URI identifying the JavaScript files in the web page HTML code. However HTML code in which a script tag has the same URI as its src attribute does not necessarily mean that it references the same JavaScript file. Even if they are the same the content of the JavaScript file could have changed over time. For example the browser typically generates and sends an HTTP GET message to retrieve a given JavaScript file from a network server. The HTTP GET request message typically includes the URI to identify the JavaScript file. However the URI that is extracted from the HTML code may reference a JavaScript file that has been modified by the server on which it resides. Thus the JavaScript file identified in the HTTP GET request message may be a different version of the file already represented in the pool . Additionally the HTTP server providing the HTTP response may generate the JavaScript file content that is returned in the body of the HTTP response on the fly. In such cases the JavaScript file represented in the pool may not be exactly the same as the actual JavaScript files referenced in the HTML code or provided by the server.

Therefore one embodiment of the present invention illustrated in advantageously utilizes the HTTP cache mechanism in these situations to determine whether a JavaScript file referenced in an HTML web page already exists in the pool . Method of begins with the controller executing code that extracts the URI from the HTML code of a web page box . Once extracted the controller generates an HTTP GET request message to obtain the JavaScript file identified by the extracted URI and sends the message to the server box . The generated HTTP GET request message includes the extracted URI and a modification request indicator that signals the server to determine whether the target JavaScript file has been modified. By way of example the controller may include an HTTP entity tag as a modification request indicator in the HTTP GET request message to the server. Upon receipt the server would determine whether the target file was modified and return an HTTP entity tag as one of the HTTP validators in a response. Upon receiving the response box the controller would inspect the returned entity tag box .

If the server returns for example a 304 Not Modified response message with no file content in the body the browser can safely determine that the URI references the exact same copy of the JavaScript file as that of an existing tab. That is a copy of the intermediate representations for the JavaScript file identified by the URI in the script tag already exists in the pool. In that case the controller would simply link the tab having the webpage to that data in pool box . If the server returns a Modified indicator in the response message however the controller would then extract the JavaScript code from the body of the response message box and create a new record for the intermediate representation data as previously described box before linking the tab with the newly created record box .

If the HTTP response message indicates that the previous cache has expired or that the HTTP response does not support cache mechanism e.g. the HTTP response message is sent with a NO CACHE indicator in the cache control header then the controller extracts the JavaScript file from the new HTTP response and compares it to a cached JavaScript file from the previous response box . The comparison is a literal comparison and will determine whether the JavaScript file identified by the URI is identical to a previously received file. If the comparison indicates that the file are the same the controller will simply link the tab to the associated record stored in memory box . Otherwise controller determines that it is a different JavaScript file extracts the file from the HTTP response box and creates and saves a new record to store the intermediate representation to the external JavaScript file pool .

The literal comparison of box may be performed by any method known in the art. In some embodiments for example a hash value or checksum is used to assist processing the lexical comparison. In another embodiment a lexical comparison of the file content is performed however analyzing the URI of the JavaScript file and performing the lexical comparison of the file content may be somewhat more complex. For example to load the Google Maps JavaScript API the code calling the API would set the src attribute of script tag to 

Regarding the third scenario i.e. when different web pages in different tabs all include copies of the same third party JavaScript files the URI cannot be used to determine whether the JavaScript files already exist in the pool . Because third party JavaScript libraries like Prototype or JQuery are considerably large the user needs to download those libraries to their web server and then include them as local JavaScript files instead of importing them from remote sites. For example the apple.com web pages use Prototype v.1.6.0.2 and include it as a local file at 

In another embodiment the present invention is applied to the just in time compiling feature for multiple Java applications in a Multiple Address Space MAS operating system such as Linux or UNIX. This embodiment is conceptually similar to JavaScript running in multi tab browser. Particularly Java applications typically share classes e.g. java.lang.string . These classes will generally be just in time compiled from bytecode to native binary code prior to execution. If the common classes are compiled within each application as is conventional the costs are high in terms of memory and execution time. However those costs can be lowered by compiling the common classes once and using them for all applications.

In these cases the fork system call in UNIX is used. If the virtual machine execution starts with a main Java application which then launches other Java applications the overhead for the common classes will be shared by all applications. This is of course assuming that these common classes are compiled by the main application. Generally the behavior of the fork system call is particularly important in the context of just in time compilation. That is it allows binary compiled code to be shared in a straight forward way at runtime. However this Java UNIX case is different from the present invention because it relies on the fork system call to clone the application. Particularly the fork system call creates a clone of the parent process including its data. This results in several copies of the same data. In contrast the present invention permits sharing JavaScript code being executed in independent browser tabs. The JavaScript would share some common components but would never be a clone of another process.

A related topic is the shared web worker defined in HTML5. Web worker is a new set of APIs that run JavaScript in parallel in the background. A worker can be defined in a separate JavaScript file and created using a related API e.g. var worker new Worker worker.js . This is different from importing an external JavaScript file in that the JavaScript variables defined in worker.js are not visible externally. The only way to communicate with the worker is via message passing. A shared worker as one category of web worker is able to coordinate with multiple pages as used in W3C Web Worker Working Draft and is equivalent with tab in this context via message passing. A shared worker can also help set up direct message channel between two tabs.

Shared workers are different from the present invention because the present invention proposes a way to share intermediate representation of external JavaScript files imported in multiple tabs. A shared worker in contrast is a new API to facilitate the coordination of message passing between tabs. Further the present invention aims to improve the performance of the current browser s JavaScript interpretation implementation and it requires no changes in the existing W3C web standards.

As mentioned above this invention helps the multi tab browser avoid repeatedly interpreting the duplicated JavaScript files and generating the syntax tree and bytecode. Therefore it will significantly save memory resources eliminate the wasteful runtime overhead associated with interpreting the same file multiple times and reduce execution time as a result. Such improvements are particularly beneficial to resources limited devices like mobile devices.

Table 1 illustrates how much execution time can be potentially reduced using the present invention. The values in Table 1 are collected from a WebKit r38097 Gtk port in Linux executing on an HP Compaq DC7900 Core1 Quad core 2.83 GHz . The JavaScript engine in WebKit r38097 is SquirrelFish Extreme SFX . The clock function from GNU C library was used at the beginning and the end of various steps of JavaScript interpretation and the values were subtracted to get the number of CPU clock ticks elapsed in each step. The number of clock ticks per second measured by clock function is 1 000 000 in this case. The minimum resolution of clock function is 10 000. Therefore where the number of clock ticks was lower than 10 000 that value is displayed as 0.

The WebKit instance was used to browse Apple s home page http www.apple.com . The instance measured the number of CPU clock ticks used in generating syntax tree and bytecode respectively. The SFX is also able to just in time compile bytecode to native code in a x86 platform but this step is not measured because it is not applicable to embedded platforms like ARM yet. The result are shown as follows in Table 1. Not all the JavaScript files used by Apple s home page are listed. Further www.apple.com indicates the JavaScript code embedded in Apple s home page.

Of the JavaScript files listed in Table 1 s code h.js shortcuts.js apple core.js scriptaculous.js and prototype.js are also used by other apple.com web pages including the Mac web page. As a result at least 580 000 CPU clock ticks of execution time can be saved while browsing the Mac web page in a second tab. This corresponds to approximately 0.58 seconds of CPU time. Those skilled in the art will appreciate however that this value is collected using a Core2 Quad core 2.83 GHz desktop PC. This value might be substantially larger for a mobile device.

Similarly the potential memory size that can be saved is measured by the amount of memory required to store the data structure of the syntax tree the bytecode and other artifacts related to the JavaScript files that are shared among tabs. Measuring memory size per application or per data structure is never an easy task. Factors such as shared memory committed memory and others in Linux for example tend to complicate such calculations. However in this example the prototype.js file was retrieved from apple.com and a mock up web page was created to include that JavaScript file. Thereafter the values of free memory size from proc meminfo were read while loading the mock up web page both with and without importing the JavaScript file prototype.js. Both values were then subtracted to get an approximate value of how much memory is allocated for prototype.js and its related data structure. The experiment was conducted several times to get the average figure to minimize error. The final figure is approximately 3.75M. Therefore if the second tab having the apple.com Mac web page can re use the intermediate representation of prototype.js loaded with the first tab having the apple.com home page about 3.75M of memory space can be potentially saved.

The present invention may of course be carried out in other ways than those specifically set forth herein without departing from essential characteristics of the invention. Therefore the present embodiments are to be considered in all respects as illustrative and not restrictive and all changes coming within the meaning and equivalency range of the appended claims are intended to be embraced therein.

